# 行情状态管理器实现版本对比

本文档记录了行情状态管理器 (`IQuoteState`) 的不同实现版本及其性能特征，作为技术探索储备。

## 版本概览

| 版本   | 设计哲学              | 核心数据结构                                          | 适用场景             | 当前状态     |
| ------ | --------------------- | ----------------------------------------------------- | -------------------- | ------------ |
| **v0** | 简单对象存储          | `Record<string, Record<IQuoteKey, [string, number]>>` | 原型开发，小规模测试 | 已弃用       |
| **v1** | 内存局部性优先        | `(string \| number)[]` 单数组连续存储                 | 生产环境，通用场景   | **生产版本** |
| **v2** | 类型一致性优先        | `string[]` + `number[]` 双数组分离存储                | 低内存碎片场景       | 技术储备     |
| **v3** | 字符串池化 + 连续存储 | `Float64Array` + 引用计数字符串池                     | 高重复率字符串场景   | 技术储备     |

## 性能对比摘要

### v1 (Baseline) vs v2 (类型一致性)

**测试环境**：完整性能测试套件，子进程隔离内存测试

| 测试类型     | 产品规模  | v2 相对 v1 性能 | 内存对比       | 关键发现             |
| ------------ | --------- | --------------- | -------------- | -------------------- |
| **初始化**   | 10K 产品  | v2 慢 4.68%     | v2 节省 11.20% | 小数据量差异不明显   |
|              | 100K 产品 | v2 慢 1.93%     | v2 节省 11.31% | 中等数据量差异小     |
|              | 1M 产品   | v2 慢 17.66%    | v1 节省 23.97% | 大数据量 v1 优势明显 |
| **更新操作** | 10K 产品  | v1 快 191.75%   | -              | v2 更新性能显著下降  |
|              | 100K 产品 | v1 快 14.71%    | -              | v2 更新持续较慢      |
|              | 1M 产品   | v1 快 38.78%    | -              | v2 更新持续较慢      |
| **查询操作** | 10K 产品  | v1 快 0.87%     | -              | 差异很小             |
|              | 100K 产品 | v1 快 2.49%     | -              | 差异很小             |
|              | 1M 产品   | v1 快 8.65%     | -              | v2 略慢              |
| **过滤操作** | 10K 产品  | v2 快 85.67%    | -              | v2 显著优势          |
|              | 100K 产品 | v2 快 4.46%     | -              | v2 略优              |
|              | 1M 产品   | v1 快 104.59%   | -              | 大数据量 v1 明显更快 |
| **转储操作** | 10K 产品  | v2 快 37.97%    | -              | v2 优势明显          |
|              | 100K 产品 | v1 快 1.78%     | -              | 差异很小             |
|              | 1M 产品   | v2 快 33.83%    | -              | v2 优势明显          |

**v2 设计总结**：

- ✅ 数组元素类型一致，减少引擎类型检查开销
- ❌ 牺牲内存局部性，更新操作性能显著下降
- ❌ 大数据量时内存使用不如 v1
- 🔄 过滤和转储操作在某些场景有优势

### v1 (Baseline) vs v3 (字符串池化)

**测试环境**：快速性能测试套件（随机测试数据）

| 产品规模    | v3 相对 v1 性能 | 内存对比               | 关键发现               |
| ----------- | --------------- | ---------------------- | ---------------------- |
| 1,000 产品  | v3 慢 59.56%    | v3 多占用 468.27% 内存 | 随机数据下池化开销显著 |
| 10,000 产品 | v3 慢 515.29%   | v3 多占用 151.67% 内存 | 性能下降随数据量加剧   |

**v3 设计总结**：

- ✅ 引用计数字符串池，避免内存泄漏
- ✅ `Float64Array` 连续存储，保持内存局部性
- ❌ 随机测试数据重复率低，池化无法体现优势
- ❌ 引用计数管理开销大（Map 操作 + 计数更新）
- 🔄 适用于**高重复率字符串场景**（如价格字段）

## 架构设计对比

### v1: 内存局部性优先

```typescript
// 核心：单数组连续存储 [值1, 时间1, 值2, 时间2...]
const data: (string | number)[] = [];
// 优势：相邻访问缓存友好，更新操作高效
// 劣势：混合类型数组，引擎需类型检查
```

### v2: 类型一致性优先

```typescript
// 核心：双数组分离存储
const values: string[] = []; // 存储字符串值
const timestamps: number[] = []; // 存储时间戳
// 优势：数组元素类型一致，减少类型检查
// 劣势：跨数组访问破坏内存局部性
```

### v3: 字符串池化 + 连续存储

```typescript
// 核心：Float64Array + 引用计数字符串池
const data: Float64Array = new Float64Array(...); // [池索引, 时间戳...]
const stringPool: (string | undefined)[] = [];    // 字符串池
// 优势：连续存储 + 字符串去重
// 劣势：引用计数管理复杂，池化元数据开销
```

## 关键性能洞察

### 1. 内存局部性 > 类型检查开销

- v1 的相邻存储（值和时间戳连续）在更新操作上优势显著（快 192%）
- 在内存受限或 swap 场景下，局部性对页面错误率影响更大

### 2. 字符串池化的适用条件

- **高重复率场景**：价格值在有限集合内变化（如 BTC: 60000-61000）
- **低重复率场景**：随机或连续变化的值，池化反而增加开销
- **需要实际数据验证**重复率阈值（建议 > 20%）

### 3. 数据规模的影响

- 小数据量（<10K 产品）：各版本差异不明显
- 大数据量（>100K 产品）：v1 的内存局部性优势放大
- 超大数据量（>1M 产品）：需要考虑内存碎片和 swap 影响

## 生产环境建议

### 当前推荐：v1

- **理由**：在内存局部性、实现复杂度和综合性能间取得最佳平衡
- **适用**：通用生产场景，特别是更新密集的应用

### 技术储备：v2

- **适用场景**：对内存碎片敏感的低碎片环境
- **优化方向**：结合 v1 的局部性优势，考虑混合存储策略

### 技术储备：v3

- **适用场景**：高字符串重复率的特定业务（如价格字段）
- **优化方向**：
  1. 选择性池化（仅对价格字段）
  2. 减少 Map 操作开销
  3. 数字字符串特殊处理

## 未来探索方向

### 混合存储策略

```typescript
// 根据字段特性选择存储方式
const STRATEGIES = {
  price: 'pooled', // 价格字段：池化存储
  volume: 'separate', // 成交量：分离存储
  timestamp: 'direct', // 时间戳：直接存储
};
```

### 自适应决策

- 运行时统计字符串重复率
- 动态切换存储策略
- 基于内存压力调整池化策略

### 架构演进

1. **分层存储**：热点数据内存 + 历史数据磁盘
2. **WASM 优化**：对超大数据集使用 WebAssembly 内存管理
3. **内存映射文件**：支持超过 RAM 容量的数据集

## 测试方法论

### 性能测试套件

- **位置**: `src/quote/benchmark/`
- **核心工具**: `ForkedQuoteStateComparisonTest`
- **测试模式**: 子进程隔离内存，确保公平性

### 关键测试场景

1. **初始化测试**: 批量数据加载性能
2. **更新测试**: 高频字段更新性能
3. **查询测试**: 随机字段读取性能
4. **过滤测试**: 条件筛选性能
5. **转储测试**: 全量数据导出性能

### 运行测试

```bash
# 完整测试套件
npx ts-node src/quote/state.benchmark.ts --fork-compare

# 快速测试
npx ts-node src/quote/state.benchmark.ts --fork-compare --quick
```

## 版本切换

在 `implementations/index.ts` 中配置当前使用的版本：

```typescript
import { createQuoteStateV1 } from './v1';
import { createQuoteStateV3 } from './v3';

export const implementations = {
  baseline: createQuoteStateV1, // 基准版本
  current: createQuoteStateV3, // 当前使用版本
};
```

---

_最后更新: 2025-12-13_
_性能数据基于随机测试生成，实际业务场景可能有所不同_
