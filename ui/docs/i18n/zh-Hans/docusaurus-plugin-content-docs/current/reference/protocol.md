# 协议

:::warning[正在进行中]
写作正在进行中。内容可能会在后期发生较大变化。
:::

:::info[技术参考]
这是系统所使用的协议的技术参考。它旨在为开发人员和系统管理员提供参考。

我们的官方 npm 包 `@yuants/protocol` 已经实现了该协议。您可以直接使用它。
:::

我们将协议定义为一组规则，用于规范两个或多个参与方之间的消息交换。协议是系统的基础，负责以下内容：

| 层级       | 参与者                       | 职责                       |
| ---------- | ---------------------------- | -------------------------- |
| 传输层     | TCP 套接字                   | 可靠地传递消息             |
| 消息层[^1] | 主机，终端                   | 网络和路由，基本的安全边界 |
| 消息模式层 | 客户端/服务器，提供者/消费者 | 负载均衡，候选选举         |
| 业务层     | 由方法指定                   | 由方法指定                 |

[^1]: 是的，我们正在重新设计互联网的网络层。我们必须这样做，因为我们需要支持终端之间的对等连接。在传统的网络模型中，浏览器可以主动连接到服务器，但不能被动地为其他终端服务。主机似乎建立了一个虚拟私有网络。但在实践中，建立虚拟私有网络是困难且有风险的。

## 消息层

主机是一个 WebSocket 服务器，监听来自终端的传入连接。终端是连接到主机的 WebSocket 客户端。

主机通常可以通过互联网访问，而终端通常位于本地网络中，无法从互联网访问。因此，终端可以连接到主机并通过主机相互传输消息。终端是对等的，可以被视为一个 P2P 网络。

主机是一个哑组件，仅在终端之间转发消息。而终端是智能组件，可以处理消息。

### 安全性

主机通常可以通过互联网访问。建议部署 TLS 证书以加密终端和主机之间的通信。我们在官方制品中已经完成了这一点。

主机有一个基本的令牌认证机制，以防止未经授权的互联网访问。当终端连接到主机时，需要提供一个令牌。令牌是一个在部署主机时预定义的字符串。

终端在连接到主机时需要在 URL 的查询字符串中提供 host_token。例如：

```
wss://api.ntnl.io/hosts?host_id=amazing_host&host_token=very_long_token&terminal_id=your_terminal_id
```

安全性和效率之间总是存在权衡。
我们选择牺牲内部主机的安全性以提高效率。
因为效率直接关系到机器成本。
更高的效率意味着节省您的资金。

主机是系统的安全边界。假设主机是安全的且可信的。
终端默认信任主机中的其他终端，不会验证身份。

:::warning
切勿将主机令牌泄露给他人。知道主机令牌的任何人都可以连接到主机并向终端发送消息。
这可能会导致严重的安全问题并损失您的资金和秘密。
:::

:::tip
一个终端进程可以同时连接到多个主机。当您想与合作伙伴共享数据时，这非常有用。
主机非常轻量级，您可以为共享目的部署一个共享主机。

```mermaid
graph LR
    A[您的个人主机] <--> B[您的终端]
    B <--> C[共享主机]
    C <--> D[合作伙伴的终端]
    D <--> E[合作伙伴的个人主机]
```

:::

### 终端信息

终端在连接到主机时应声明其终端信息。终端信息是一个 JSON 对象：

```ts
export interface ITerminalInfo {
  terminal_id: string;
  // 其他字段省略
}
```

- terminal_id 是终端的唯一 ID。它在主机中应该是唯一的。
- 终端信息通常包含终端的服务信息。例如，终端可以声明它提供账户信息服务。
- 终端信息用于消息模式层，我们将在后面介绍。

### 消息结构

所有消息都是 JSON 编码的，并具有以下结构：

```ts
export interface ITerminalMessage {
  source_terminal_id: string;
  target_terminal_id: string;

  // 其他字段用于消息模式层，稍后介绍。
}
```

- source_terminal_id 是发送者的终端 ID。
- target_terminal_id 是接收者的终端 ID。
- 主机会读取 target_terminal_id 并将消息转发到目标终端。
- 其他字段用于消息模式层，我们将在后面介绍。

### P2P 直接连接

我们可以使用 WebRTC 在两个终端之间建立 P2P 连接。WebRTC 是一种点对点技术，允许终端直接交换消息。它是我们目的的完美选择。无需通过主机传输消息。它更快，流量成本更低。当建立 P2P 连接时，主机将停止在两个终端之间转发消息。实际上，终端将不再向主机发送消息。主机的操作从未改变。但是，如果 P2P 连接中断，主机将恢复在两个终端之间转发消息。

主机还将在两个终端之间转发 ICE 候选（提议和应答）。因此，两个终端可以建立 P2P 连接。主机既是 STUN 服务器又是 TURN 角色。

对等连接是隐式建立的。当一个终端向另一个终端发送消息时，终端将检查是否与目标终端有 P2P 连接。如果没有，终端将尝试与目标终端建立 P2P 连接。如果建立了 P2P 连接，终端将通过对等连接发送消息。如果 P2P 连接中断，终端将恢复通过主机发送消息。

## 消息模式层

有两种类型的消息模式：客户端/服务器和提供者/消费者。

1. 客户端向服务器发送请求，服务器向客户端发送响应。
2. 提供者向消费者推送消息。

### 客户端/服务器模式（服务模式）

我们使用这种模式来实现请求/响应服务。

客户端向服务器发送请求，服务器向客户端发送响应。
客户端和服务器是同一主机中的两个终端。
请求和响应是终端消息。

服务由方法名称标识。

核心过程是：

1. 定义一个方法来标识请求和响应的格式和行为。
1. 服务器应在终端信息中声明它提供该服务。
1. 客户端应发现服务器并向服务器发送请求。
1. 服务器应处理请求并向客户端发送响应。

更多详细规则：

- 服务器可以在发送响应之前发送多条消息。
- 会话是从请求到响应的过程，由消息中的 trace_id 字段标识。
- 服务器应声明它支持的方法。鉴别器是方法名称和 JSON Schema。
- 客户端应在发送请求之前检查服务器是否支持该方法并通过 JSON Schema 验证请求。
- 如果存在多个有效候选服务器，客户端应选择一个服务器发送请求。建议使用负载均衡算法选择服务器。
- 服务器应在收到请求后 30 秒内发送第一条消息。如果服务器在 30 秒内未发送响应，客户端应抛出超时错误。
- 服务器在发送响应后不应向客户端发送消息。如果有，客户端应忽略它们。

如何使用此模式：

**服务器端**：

```ts
terminal.provideService(
  'SubmitOrder',
  {
    type: 'object',
    properties: {
      account_id: { const: 'MyAccountId' },
    },
  },
  (msg) => {
    // 返回一个 RxJS 可观察的终端消息
  },
);
```

**客户端端**：

```ts
// message$ 是由服务器返回的 RxJS Observable
const message$ = terminal.requestService('SubmitOrder', {
  account_id: 'MyAccountId',
  // ... 其他字段省略
});
```

### 提供者/消费者模式（通道模式）

我们使用这种模式来实现实时消息推送。

消费者订阅某些通道，然后提供者需要实时向消费者推送消息。
消费者和提供者是同一主机中的两个终端。
同一主机中有很多提供者和消费者。

订阅是一个三元关系：（channel_id，provider_terminal_id，consumer_terminal_id）。

通道由 channel_id 标识，其格式由业务层定义。
例如，channel_id `encodePath('AccountInfo', account_id)` 用于传输实时账户信息。
建议使用 `encodePath` 生成 channel_id，使用 `decodePath` 解析 channel_id。因为它简单且易于阅读。
但是，您可以使用任何您喜欢的格式。这不是消息模式层的关注点。

核心过程是：

1. 定义一个通道来标识通道及其有效负载消息。
1. 提供者应在终端信息中声明它提供通道的数据。
1. 消费者应在终端信息中声明它从提供者订阅通道。
1. 提供者应发现消费者并向消费者发送有效负载消息。

更多详细规则：

- 消费者应在订阅之前检查提供者是否支持通道。
- 提供者应收集所有订阅通道的消费者并向他们发送消息。
- 提供者应在消费者离线后停止向消费者发送消息。
- 如果存在多个有效候选提供者，消费者应决定订阅哪个提供者。建议使用负载均衡算法选择提供者。
- 如果从多个提供者订阅相同的通道，消费者应处理冲突。
- 提供者应自行向所有消费者多播消息。
- 如果难以枚举所有通道，提供者可以定义匹配模式来匹配通道。
- 如果当前提供者在 60 秒内未发送消息，消费者应切换到另一个候选提供者。

如何使用此模式：

**提供者端**：

```ts
terminal.provideChannel<IAccountInfo>({ const: 'AccountInfo/MyAccountID' }, () => {
  // 返回一个 RxJS Observable 的有效负载消息
});
```

**消费者端**：

```ts
// message$ 是由提供者返回的 RxJS Subject
const message$ = terminal.consumeChannel<IAccountInfo>('AccountInfo/MyAccountID');
```

1. message$ 是一个 RxJS Subject。您可以订阅它以接收有效负载消息。
2. 匹配 channel_id 并找到候选提供者。
3. 选择一个提供者并声明订阅。
4. 从提供者接收有效负载消息。
5. 如果 message$ 被取消订阅，则取消订阅通道。
6. 如果当前提供者在 60 秒内未发送消息，则切换到另一个候选提供者。

**定义匹配模式**

如果难以枚举所有通道，提供者可以定义匹配正则表达式字符串来匹配通道。

唯一的区别是提供者应声明匹配模式而不是常量 channel_id。

```ts
// JSON Schema
terminal.provideChannel(
  {
    pattern: '^Period/Y/.+/.+$',
  },
  (channel_id) => {
    // 按 channel_id 返回一个 RxJS Observable
  },
);
```

## 进一步阅读

您可以阅读我们官方 npm 包 `@yuants/protocol` 的源代码，以了解更多关于协议的信息。

您可以阅读业务层（TODO）规范，以了解更多关于业务的信息。
