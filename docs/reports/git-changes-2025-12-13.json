{
  "range": {
    "old": "fd005cee1104e8d8a9f3890c21051ecb06dc29aa",
    "new": "3eab2932ebf784ad6ffdeebb72791764e85d24bb",
    "label": "fd005cee1..3eab2932e",
    "startDate": "2025-12-12",
    "endDate": "2025-12-13",
    "commitCount": 8,
    "generatedAt": "2025-12-13T00:06:16.422Z"
  },
  "contributors": [
    {
      "name": "CZ",
      "email": "zheng.chen@no-trade-no.life",
      "commits": 4
    },
    {
      "name": "humblelittlec1[bot]",
      "email": "208195530+humblelittlec1[bot]@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Siyuan Wang",
      "email": "c.one@thrimbda.com",
      "commits": 1
    }
  ],
  "directoryAnalysis": {
    "topLevel": [
      {
        "dir": "apps",
        "fileCount": 34
      },
      {
        "dir": "libraries",
        "fileCount": 14
      },
      {
        "dir": "common",
        "fileCount": 9
      },
      {
        "dir": "docs",
        "fileCount": 2
      }
    ],
    "projects": [
      {
        "project": "apps/virtual-exchange",
        "fileCount": 21,
        "marker": "package.json"
      },
      {
        "project": "libraries/secret",
        "fileCount": 14,
        "marker": "package.json"
      },
      {
        "project": "common",
        "fileCount": 9,
        "marker": null
      },
      {
        "project": "apps/alert-receiver",
        "fileCount": 7,
        "marker": "package.json"
      },
      {
        "project": "apps/agent",
        "fileCount": 3,
        "marker": "package.json"
      },
      {
        "project": "apps/node-unit",
        "fileCount": 3,
        "marker": "package.json"
      },
      {
        "project": "docs",
        "fileCount": 2,
        "marker": null
      }
    ],
    "markersUsed": [
      "package.json",
      "Cargo.toml",
      "go.mod",
      "requirements.txt",
      "pyproject.toml",
      "setup.py",
      "pom.xml",
      "build.gradle",
      "build.gradle.kts",
      "CMakeLists.txt",
      "Makefile",
      "pubspec.yaml",
      "mix.exs",
      "Gemfile",
      "composer.json"
    ]
  },
  "commits": [
    {
      "hash": "8552e9d99d5bbb2b5fbc9b3e0cf83b287ed8a3ce",
      "short": "8552e9d99",
      "author": "humblelittlec1[bot]",
      "email": "208195530+humblelittlec1[bot]@users.noreply.github.com",
      "authoredAt": "2025-12-12 12:19:15 +0800",
      "subject": "feat: add daily git change report for 2025-12-12 - 5 commits (#2307)",
      "conventionalCommit": {
        "type": "feat",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 5791,
          "deletions": 0,
          "path": "docs/reports/git-changes-2025-12-12.json",
          "changeType": "unknown",
          "patch": null,
          "codeSnippets": []
        },
        {
          "additions": 160,
          "deletions": 0,
          "path": "docs/reports/git-changes-report-2025-12-12.md",
          "changeType": "added",
          "patch": "commit 8552e9d99d5bbb2b5fbc9b3e0cf83b287ed8a3ce\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 12:19:15 2025 +0800\n\n    feat: add daily git change report for 2025-12-12 - 5 commits (#2307)\n    \n    Co-authored-by: github-actions[bot] <github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/docs/reports/git-changes-report-2025-12-12.md b/docs/reports/git-changes-report-2025-12-12.md\nnew file mode 100644\nindex 000000000..61c82a407\n--- /dev/null\n+++ b/docs/reports/git-changes-report-2025-12-12.md\n@@ -0,0 +1,160 @@\n+# Git 变更报告（a23c52dc5..fd005cee1）\n+\n+> **时间范围**：2025-12-11 至 2025-12-12\n+> **分析深度**：Level 2\n+\n+## 1. 概览\n+\n+- **提交数量**：5\n+- **主要贡献者**：CZ (2 commits), humblelittlec1[bot] (2 commits), Siyuan Wang (1 commit)\n+- **热点项目**：`apps/virtual-exchange` (6 文件), `apps/alert-receiver` (4 文件), `apps/vendor-okx` (4 文件)\n+- **风险指标**：⚠️ 1 个中等风险项（无测试覆盖）\n+\n+## 2. 核心变更\n+\n+### 2.1 利息结算优化与账户信息增强\n+\n+**相关提交**：`e32477731`, `ddf33c43e`\n+**作者**：CZ\n+\n+**设计意图**：\n+优化虚拟交易所的利息结算逻辑，从固定时间预测改为基于历史利率数据的动态计算。原实现假设结算时间固定间隔，但实际利率数据可能有不规则间隔。新算法通过分析最近两次利率更新时间计算实际间隔，并动态预测下一个结算时间，提高结算时间预测的准确性。同时为账户信息面板添加利息周期显示，增强用户体验。\n+\n+**核心代码**：\n+[position.ts:L21-L40](apps/virtual-exchange/src/position.ts#L21-L40)\n+\n+```typescript\n+const interestRateIntervalCache = createCache(\n+  async (product_id: string) => {\n+    const sql = `select created_at from interest_rate where series_id = ${escapeSQL(\n+      product_id,\n+    )} order by created_at desc limit 2`;\n+    const rates = await requestSQL<{ created_at: string }[]>(terminal, sql);\n+    if (rates.length < 2) return undefined;\n+    const prev = new Date(rates[0].created_at).getTime();\n+    const prevOfPrev = new Date(rates[1].created_at).getTime();\n+    const interval = prev - prevOfPrev;\n+    return {\n+      prev,\n+      prevOfPrev,\n+      interval,\n+    };\n+  },\n+  { swrAfter: 3600_000, expire: 8 * 3600_000 },\n+);\n+```\n+\n+**影响范围**：\n+- 影响模块：`virtual-exchange` 利息结算预测\n+- 需要关注：缓存配置（SWR 1小时，过期8小时）可能影响实时性\n+\n+### 2.2 动态结算时间计算算法\n+\n+**相关提交**：`e32477731`\n+**作者**：CZ\n+\n+**设计意图**：\n+实现精确的利息结算时间预测算法。通过公式 `prev + k * interval > now` 找到最小整数 k，确保预测的结算时间总是未来时间。相比之前简单的 `prev + interval` 方式，新算法能正确处理跨越多个结算周期的情况，避免预测时间落在过去。\n+\n+**核心代码**：\n+[position.ts:L74-L77](apps/virtual-exchange/src/position.ts#L74-L77)\n+\n+```typescript\n+// 找到 prev + k * interval > now 的最小 k，则下一个结算时间为 prev + k * interval\n+const k = Math.ceil((Date.now() - interestRateInterval.prev) / interestRateInterval.interval);\n+pos.settlement_scheduled_at = interestRateInterval.prev + k * interestRateInterval.interval;\n+```\n+\n+**影响范围**：\n+- 影响模块：所有使用虚拟交易所利息结算预测的功能\n+- 需要关注：当 `interval` 为0或负数时的边界情况处理\n+\n+### 2.3 持仓数据增强 - 添加账户ID\n+\n+**相关提交**：`ddf33c43e`\n+**作者**：CZ\n+\n+**设计意图**：\n+在 GetPositions 和 GetOrders 服务的补全逻辑中为持仓数据添加 `account_id` 字段。确保从虚拟交易所获取的持仓数据包含完整的账户标识信息，便于下游系统进行账户级别的数据聚合和分析。\n+\n+**核心代码**：\n+[general.ts:L25-L27](apps/virtual-exchange/src/general.ts#L25-L27)\n+\n+```typescript\n+positions.forEach((pos) => {\n+  pos.account_id = credential.credentialId;\n+});\n+```\n+\n+**影响范围**：\n+- 影响模块：`virtual-exchange` 的 GetPositions 和 GetOrders 服务\n+- 需要关注：确保所有虚拟交易所的持仓数据都包含账户ID\n+\n+### 2.4 警报严重度计算重构\n+\n+**相关提交**：`fd005cee1`\n+**作者**：Siyuan Wang\n+\n+**设计意图**：\n+重构警报接收器的严重度计算逻辑，增强警报消息渲染。通过优化严重度评估算法，提高警报分类的准确性，同时改进消息展示格式，使操作人员能更快速理解警报内容和紧急程度。\n+\n+**影响范围**：\n+- 影响模块：`alert-receiver` 警报处理流水线\n+- 需要关注：严重度计算逻辑变更可能影响现有警报分类\n+\n+### 2.5 OKX 凭证错误信息优化\n+\n+**相关提交**：`e32477731`\n+**作者**：CZ\n+\n+**设计意图**：\n+优化 OKX 交易所凭证验证的错误信息，在凭证无效时提供更详细的上下文信息。将简单的凭证对象替换为完整的 API 响应对象，便于调试和问题诊断。\n+\n+**核心代码**：\n+[exchange.ts:L26-L29](apps/vendor-okx/src/experimental/exchange.ts#L26-L29)\n+\n+```typescript\n+const res = await getAccountConfig(credential);\n+const uid = res.data?.[0]?.uid;\n+if (!uid) throw newError('OKX_CREDENTIAL_INVALID', { res });\n+```\n+\n+**影响范围**：\n+- 影响模块：`vendor-okx` 凭证验证\n+- 需要关注：错误对象结构变更，下游错误处理可能需要适配\n+\n+## 3. 贡献者\n+\n+| 作者 | 提交数 | 主要工作 | 关键提交 |\n+| ---- | ------ | -------- | -------- |\n+| CZ | 2 | 利息结算优化、持仓数据增强 | `e32477731`, `ddf33c43e` |\n+| humblelittlec1[bot] | 2 | 版本更新、文档维护 | `328c98b84`, `f4851cd2c` |\n+| Siyuan Wang | 1 | 警报系统重构 | `fd005cee1` |\n+\n+## 4. 风险评估\n+\n+### 兼容性影响\n+\n+- **低风险**：所有变更均为功能增强或优化，无 API 破坏性变更\n+- **OKX 错误对象**：`OKX_CREDENTIAL_INVALID` 错误现在包含完整响应对象而非原始凭证，可能影响现有错误处理逻辑\n+\n+### 配置变更\n+\n+- **缓存配置**：`interestRateIntervalCache` 新增缓存配置参数 `{ swrAfter: 3600_000, expire: 8 * 3600_000 }`\n+- **UI 配置**：账户信息面板新增 `settlement_interval` 列显示\n+\n+### 性能影响\n+\n+- **缓存优化**：利息间隔缓存增加 SWR 和过期时间配置，减少数据库查询频率\n+- **算法优化**：动态结算时间计算避免不必要的重复计算\n+\n+### 测试覆盖\n+\n+- **中等风险**：所有功能提交均未见测试文件更新\n+- **建议**：为利息结算算法和账户ID添加添加单元测试\n+\n+---\n+\n+**生成时间**：2025-12-12  \n+**数据源**：docs/reports/git-changes-2025-12-12.json  \n+**分析工具**：git-changes-reporter v3.0.0\n\\ No newline at end of file\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "interestRateIntervalCache",
              "code": "const interestRateIntervalCache = createCache(\n  async (product_id: string) => {",
              "lineStart": 27,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "sql",
              "code": "const sql = `select created_at from interest_rate where series_id = ${escapeSQL(\n  product_id,\n)} order by created_at desc limit 2`;",
              "lineStart": 29,
              "lineEnd": 31
            },
            {
              "type": "function",
              "name": "rates",
              "code": "const rates = await requestSQL<{ created_at: string }[]>(terminal, sql);\nif (rates.length < 2) return undefined;",
              "lineStart": 32,
              "lineEnd": 33
            },
            {
              "type": "function",
              "name": "prev",
              "code": "const prev = new Date(rates[0].created_at).getTime();",
              "lineStart": 34,
              "lineEnd": 34
            },
            {
              "type": "function",
              "name": "prevOfPrev",
              "code": "const prevOfPrev = new Date(rates[1].created_at).getTime();",
              "lineStart": 35,
              "lineEnd": 35
            },
            {
              "type": "function",
              "name": "interval",
              "code": "    const interval = prev - prevOfPrev;\n    return {\n      prev,\n      prevOfPrev,\n      interval,\n    };\n  },\n  { swrAfter: 3600_000, expire: 8 * 3600_000 },\n);\n```\n\n**影响范围**：\n- 影响模块：`virtual-exchange` 利息结算预测\n- 需要关注：缓存配置（SWR 1小时，过期8小时）可能影响实时性\n",
              "lineStart": 36,
              "lineEnd": 63
            },
            {
              "type": "function",
              "name": "k",
              "code": "const k = Math.ceil((Date.now() - interestRateInterval.prev) / interestRateInterval.interval);\npos.settlement_scheduled_at = interestRateInterval.prev + k * interestRateInterval.interval;\n```\n\n**影响范围**：\n- 影响模块：所有使用虚拟交易所利息结算预测的功能\n- 需要关注：当 `interval` 为0或负数时的边界情况处理\n\n### 2.3 持仓数据增强 - 添加账户ID\n\n**相关提交**：`ddf33c43e`\n**作者**：CZ\n\n**设计意图**：\n在 GetPositions 和 GetOrders 服务的补全逻辑中为持仓数据添加 `account_id` 字段。确保从虚拟交易所获取的持仓数据包含完整的账户标识信息，便于下游系统进行账户级别的数据聚合和分析。",
              "lineStart": 64,
              "lineEnd": 116
            },
            {
              "type": "function",
              "name": "res",
              "code": "const res = await getAccountConfig(credential);",
              "lineStart": 117,
              "lineEnd": 117
            },
            {
              "type": "function",
              "name": "uid",
              "code": "const uid = res.data?.[0]?.uid;\nif (!uid) throw newError('OKX_CREDENTIAL_INVALID', { res });\n```\n\n**影响范围**：\n- 影响模块：`vendor-okx` 凭证验证\n- 需要关注：错误对象结构变更，下游错误处理可能需要适配\n\n## 3. 贡献者\n\n| 作者 | 提交数 | 主要工作 | 关键提交 |\n| ---- | ------ | -------- | -------- |\n| CZ | 2 | 利息结算优化、持仓数据增强 | `e32477731`, `ddf33c43e` |\n| humblelittlec1[bot] | 2 | 版本更新、文档维护 | `328c98b84`, `f4851cd2c` |\n| Siyuan Wang | 1 | 警报系统重构 | `fd005cee1` |",
              "lineStart": 118,
              "lineEnd": 162
            }
          ]
        }
      ]
    },
    {
      "hash": "e743378705faf3ad48352fe6624ab936ac3eec98",
      "short": "e74337870",
      "author": "CZ",
      "email": "zheng.chen@no-trade-no.life",
      "authoredAt": "2025-12-12 17:47:08 +0800",
      "subject": "feat: implement secret management functions and benchmarks (#2308)",
      "conventionalCommit": {
        "type": "feat",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 49,
          "deletions": 72,
          "path": "apps/virtual-exchange/src/credential.ts",
          "changeType": "modified",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/apps/virtual-exchange/src/credential.ts b/apps/virtual-exchange/src/credential.ts\nindex f83924675..edf0901b4 100644\n--- a/apps/virtual-exchange/src/credential.ts\n+++ b/apps/virtual-exchange/src/credential.ts\n@@ -4 +4 @@ import { Terminal } from '@yuants/protocol';\n-import { ISecret, readSecret, writeSecret } from '@yuants/secret';\n+import { ISecret, listSecrets, readSecret, writeSecret } from '@yuants/secret';\n@@ -9 +9 @@ import { defer, firstValueFrom, map, repeat, retry, shareReplay } from 'rxjs';\n-export interface IExchangeCredential {\n+interface IExchangeCredential {\n@@ -18,6 +18,14 @@ const credentialReader = process.env.NODE_UNIT_PUBLIC_KEY || terminal.keyPair.pu\n-interface ICredentialResolvedStatus {\n-  secret: ISecret;\n-  credential?: IExchangeCredential;\n-  credentialId?: string;\n-  reason?: string;\n-}\n+/**\n+ * 根据 secret sign 解析出对应的 exchange credential\n+ * 此处可以做缓存，因为同一个 secret sign 对应的 credential 信息永远不会变化，可以节约解密和后续 SQL 查询的开销\n+ * 得到 credential 后，此 credential 不一定是有效的，因为可能凭证信息已经过期或被撤销\n+ */\n+const secretSignToCredentialIdCache = createCache(async (sign: string) => {\n+  const sql = `SELECT * FROM secret WHERE sign = ${escapeSQL(sign)} LIMIT 1;`;\n+  const res = await requestSQL<ISecret[]>(terminal, sql);\n+  if (res.length === 0) throw newError('SECRET_NOT_FOUND', { sign });\n+  const secret = res[0];\n+  const decrypted = await readSecret(terminal, secret);\n+  const credential = JSON.parse(new TextDecoder().decode(decrypted)) as IExchangeCredential;\n+  return credential;\n+});\n@@ -24,0 +33,5 @@ interface ICredentialResolvedStatus {\n+/**\n+ * 根据 credential 信息解析出对应的 credential ID\n+ * 此处可以做缓存，因为同一个 credential 永远对应同一个 credential ID，可以节约后续 SQL 查询的开销\n+ * 但是需要注意的是，credential ID 可能会因为凭证被撤销而失效，但是可以在下游调用其他服务时感知到，因此可以永久缓存\n+ */\n@@ -31,16 +44,5 @@ const credentialIdCache = createCache(async (credentialKey: string) => {\n-export const listAllCredentials = async () => {\n-  const secrets = await requestSQL<ISecret[]>(\n-    terminal,\n-    `select * from secret where tags->>'type' = 'exchange_credential' and reader = ${escapeSQL(\n-      credentialReader,\n-    )}`,\n-  );\n-\n-  const results = secrets.map((secret): ICredentialResolvedStatus => ({ secret }));\n-\n-  await Promise.all(\n-    results.map(async (result) => {\n-      try {\n-        const decrypted = await readSecret(terminal, result.secret);\n-        const credential = JSON.parse(new TextDecoder().decode(decrypted)) as IExchangeCredential;\n-        result.credential = credential;\n+const listAllCredentials = async () => {\n+  const secrets = await listSecrets(terminal, {\n+    reader: credentialReader,\n+    tags: { type: 'exchange_credential' },\n+  });\n@@ -48,11 +50 @@ export const listAllCredentials = async () => {\n-        const res = await credentialIdCache.query(JSON.stringify(credential));\n-        if (res) {\n-          result.credentialId = res;\n-        }\n-      } catch (e) {\n-        result.reason = `${e}`;\n-      }\n-    }),\n-  );\n-\n-  return results;\n+  return Promise.allSettled(secrets.map((secret) => getCredentialBySecretId(secret.sign)));\n@@ -79,7 +71,4 @@ terminal.server.provideService<IExchangeCredential, ISecret>(\n-terminal.server.provideService<void, ICredentialResolvedStatus[]>(\n-  'VEX/ListExchangeCredential',\n-  {},\n-  async () => {\n-    return { res: { code: 0, message: 'OK', data: await listAllCredentials() } };\n-  },\n-);\n+// For Debugging Purpose\n+terminal.server.provideService('VEX/ListExchangeCredential', {}, async () => {\n+  return { res: { code: 0, message: 'OK', data: await listAllCredentials() } };\n+});\n@@ -92,3 +81 @@ terminal.server.provideService<void, string[]>('VEX/ListCredentials', {}, async\n-const credentialCache = createCache(() => listAllCredentials(), { swrAfter: 10_000, expire: 3600_000 });\n-\n-export const validCredentials$ = defer(() => credentialCache.query('')).pipe(\n+export const validCredentials$ = defer(() => listAllCredentials()).pipe(\n@@ -99,2 +86,3 @@ export const validCredentials$ = defer(() => credentialCache.query('')).pipe(\n-      if (xx.credentialId && xx.credential) {\n-        map.set(xx.credentialId, xx.credential);\n+      if (xx.status !== 'fulfilled') continue;\n+      if (xx.value.credentialId && xx.value.credential) {\n+        map.set(xx.value.credentialId, xx.value.credential);\n@@ -120,25 +108,14 @@ export const validCredentialTypes$ = validCredentials$.pipe(\n-export const getCredentialById = async (credential_id: string) => {\n-  const credentials = await firstValueFrom(validCredentials$);\n-  return credentials.get(credential_id);\n-};\n-\n-export const getCredentialBySecretId = async (\n-  secret_id: string,\n-): Promise<Required<Pick<ICredentialResolvedStatus, 'secret' | 'credential' | 'credentialId'>>> => {\n-  const allCredentials = await credentialCache.query('');\n-  const theCredential = allCredentials?.find((x) => x.secret.sign === secret_id);\n-  if (!theCredential) {\n-    throw newError('CREDENTIAL_NOT_FOUND', { secret_id });\n-  }\n-  if (!theCredential.credential) {\n-    throw newError('CREDENTIAL_NOT_RESOLVED', { secret_id });\n-  }\n-  if (!theCredential.credentialId) {\n-    throw newError('CREDENTIAL_ID_NOT_RESOLVED', { secret_id });\n-  }\n-\n-  return {\n-    secret: theCredential.secret,\n-    credential: theCredential.credential,\n-    credentialId: theCredential.credentialId,\n-  };\n+/**\n+ * 根据 secret sign 解析出对应的 credential 以及 credential ID\n+ * @param sign - secret sign\n+ * @returns 解析得到的 credential 以及对应的 credential ID\n+ * @throws 如果无法解析出对应的 credential 或 credential ID，则抛出异常\n+ *\n+ * 不依赖 List Credential 服务，可以及时感知凭证的新增和变更\n+ */\n+export const getCredentialBySecretId = async (sign: string) => {\n+  const credential = await secretSignToCredentialIdCache.query(sign);\n+  if (!credential) throw newError('CREDENTIAL_NOT_RESOLVED', { sign });\n+  const credentialId = await credentialIdCache.query(JSON.stringify(credential));\n+  if (!credentialId) throw newError('CREDENTIAL_ID_NOT_RESOLVED', { sign });\n+  return { sign, credential, credentialId };\n",
          "codeSnippets": [
            {
              "type": "interface",
              "name": "IExchangeCredential",
              "code": "interface IExchangeCredential {\n/**\n * 根据 secret sign 解析出对应的 exchange credential\n * 此处可以做缓存，因为同一个 secret sign 对应的 credential 信息永远不会变化，可以节约解密和后续 SQL 查询的开销\n * 得到 credential 后，此 credential 不一定是有效的，因为可能凭证信息已经过期或被撤销\n */",
              "lineStart": 9,
              "lineEnd": 22
            },
            {
              "type": "function",
              "name": "secretSignToCredentialIdCache",
              "code": "const secretSignToCredentialIdCache = createCache(async (sign: string) => {",
              "lineStart": 23,
              "lineEnd": 23
            },
            {
              "type": "function",
              "name": "sql",
              "code": "const sql = `SELECT * FROM secret WHERE sign = ${escapeSQL(sign)} LIMIT 1;`;",
              "lineStart": 24,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "res",
              "code": "const res = await requestSQL<ISecret[]>(terminal, sql);\nif (res.length === 0) throw newError('SECRET_NOT_FOUND', { sign });",
              "lineStart": 25,
              "lineEnd": 26
            },
            {
              "type": "function",
              "name": "secret",
              "code": "const secret = res[0];",
              "lineStart": 27,
              "lineEnd": 27
            },
            {
              "type": "function",
              "name": "decrypted",
              "code": "const decrypted = await readSecret(terminal, secret);",
              "lineStart": 28,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "credential",
              "code": "  const credential = JSON.parse(new TextDecoder().decode(decrypted)) as IExchangeCredential;\n  return credential;\n});\n/**\n * 根据 credential 信息解析出对应的 credential ID\n * 此处可以做缓存，因为同一个 credential 永远对应同一个 credential ID，可以节约后续 SQL 查询的开销\n * 但是需要注意的是，credential ID 可能会因为凭证被撤销而失效，但是可以在下游调用其他服务时感知到，因此可以永久缓存\n */",
              "lineStart": 29,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "listAllCredentials",
              "code": "const listAllCredentials = async () => {",
              "lineStart": 44,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "secrets",
              "code": "  const secrets = await listSecrets(terminal, {\n    reader: credentialReader,\n    tags: { type: 'exchange_credential' },\n  });\n  return Promise.allSettled(secrets.map((secret) => getCredentialBySecretId(secret.sign)));\n// For Debugging Purpose\nterminal.server.provideService('VEX/ListExchangeCredential', {}, async () => {\n  return { res: { code: 0, message: 'OK', data: await listAllCredentials() } };\n});",
              "lineStart": 45,
              "lineEnd": 80
            },
            {
              "type": "function",
              "name": "validCredentials",
              "code": "export const validCredentials$ = defer(() => listAllCredentials()).pipe(\n      if (xx.status !== 'fulfilled') continue;\n      if (xx.value.credentialId && xx.value.credential) {\n        map.set(xx.value.credentialId, xx.value.credential);\n/**\n * 根据 secret sign 解析出对应的 credential 以及 credential ID\n * @param sign - secret sign\n * @returns 解析得到的 credential 以及对应的 credential ID\n * @throws 如果无法解析出对应的 credential 或 credential ID，则抛出异常\n *\n * 不依赖 List Credential 服务，可以及时感知凭证的新增和变更\n */",
              "lineStart": 81,
              "lineEnd": 115
            },
            {
              "type": "function",
              "name": "getCredentialBySecretId",
              "code": "export const getCredentialBySecretId = async (sign: string) => {",
              "lineStart": 116,
              "lineEnd": 116
            },
            {
              "type": "function",
              "name": "credential",
              "code": "const credential = await secretSignToCredentialIdCache.query(sign);\nif (!credential) throw newError('CREDENTIAL_NOT_RESOLVED', { sign });",
              "lineStart": 117,
              "lineEnd": 118
            },
            {
              "type": "function",
              "name": "credentialId",
              "code": "const credentialId = await credentialIdCache.query(JSON.stringify(credential));\nif (!credentialId) throw newError('CREDENTIAL_ID_NOT_RESOLVED', { sign });\nreturn { sign, credential, credentialId };",
              "lineStart": 119,
              "lineEnd": 122
            }
          ]
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json b/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json\nnew file mode 100644\nindex 000000000..dba0c3422\n--- /dev/null\n+++ b/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/app-virtual-exchange\",\n+      \"comment\": \"rewrite credential resolution\",\n+      \"type\": \"patch\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/app-virtual-exchange\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/common/changes/@yuants/secret/2025-12-12-09-42.json b/common/changes/@yuants/secret/2025-12-12-09-42.json\nnew file mode 100644\nindex 000000000..6e2583b0f\n--- /dev/null\n+++ b/common/changes/@yuants/secret/2025-12-12-09-42.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/secret\",\n+      \"comment\": \"reorg code and support many functions\",\n+      \"type\": \"minor\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/secret\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 298,
          "deletions": 0,
          "path": "libraries/secret/benchmark/index.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/benchmark/index.ts b/libraries/secret/benchmark/index.ts\nnew file mode 100644\nindex 000000000..995388f9e\n--- /dev/null\n+++ b/libraries/secret/benchmark/index.ts\n@@ -0,0 +1,298 @@\n+import { createKeyPair, signMessage, verifyMessage, decodeBase58, encodeBase58 } from '@yuants/utils';\n+import { makeSecret } from '../src/makeSecret';\n+import { verifySecretSigner } from '../src/verifySecretSigner';\n+import { getTagsText } from '../src/utils';\n+import { performance } from 'perf_hooks';\n+\n+async function benchmarkMakeSecret(iterations: number = 1000) {\n+  const keyPair = createKeyPair();\n+  const readerKeyPair = createKeyPair();\n+  const secretData = new Uint8Array(32); // 32 bytes of dummy data\n+  crypto.getRandomValues(secretData);\n+\n+  const tags = { env: 'test', user: 'benchmark' };\n+\n+  console.log(`Benchmarking makeSecret for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n+  return { total, avg };\n+}\n+\n+async function benchmarkVerifySecretSigner(iterations: number = 1000) {\n+  const keyPair = createKeyPair();\n+  const readerKeyPair = createKeyPair();\n+  const secretData = new Uint8Array(32);\n+  crypto.getRandomValues(secretData);\n+  const tags = { env: 'test', user: 'benchmark' };\n+\n+  // Create a single secret record to verify repeatedly\n+  const secretRecord = await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n+\n+  console.log(`Benchmarking verifySecretSigner for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    verifySecretSigner(secretRecord);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n+  return { total, avg };\n+}\n+\n+async function benchmarkCombined(iterations: number = 1000) {\n+  const keyPair = createKeyPair();\n+  const readerKeyPair = createKeyPair();\n+  const secretData = new Uint8Array(32);\n+  crypto.getRandomValues(secretData);\n+  const tags = { env: 'test', user: 'benchmark' };\n+\n+  console.log(`Benchmarking makeSecret + verifySecretSigner combined for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    const secretRecord = await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n+    verifySecretSigner(secretRecord);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n+  return { total, avg };\n+}\n+\n+// ===== Fine-grained benchmark functions =====\n+\n+function benchmarkGetTagsText(iterations: number = 100000) {\n+  const tags = { env: 'test', user: 'benchmark', app: 'secret-service', version: '1.0.0' };\n+\n+  console.log(`Benchmarking getTagsText for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    getTagsText(tags);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n+  return { total, avg };\n+}\n+\n+function benchmarkMessageConstruction(iterations: number = 100000) {\n+  const signer = 'signer123';\n+  const reader = 'reader456';\n+  const tags = { env: 'test', user: 'benchmark' };\n+  const data = 'encryptedDataBase64String';\n+  const tagsText = getTagsText(tags);\n+\n+  console.log(`Benchmarking message construction for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    const message = signer + reader + tagsText + data;\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n+  return { total, avg };\n+}\n+\n+function benchmarkVerifyMessage(iterations: number = 10000) {\n+  const keyPair = createKeyPair();\n+  const message = 'test message for signature verification';\n+  const signature = signMessage(message, keyPair.private_key);\n+\n+  console.log(`Benchmarking verifyMessage for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    verifyMessage(message, signature, keyPair.public_key);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(5)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n+  return { total, avg };\n+}\n+\n+function benchmarkSignMessage(iterations: number = 10000) {\n+  const keyPair = createKeyPair();\n+  const message = 'test message for signing';\n+\n+  console.log(`Benchmarking signMessage for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    signMessage(message, keyPair.private_key);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(5)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n+  return { total, avg };\n+}\n+\n+function benchmarkDecodeBase58(iterations: number = 100000) {\n+  // Generate a sample base58 string\n+  const keyPair = createKeyPair();\n+  const base58String = keyPair.public_key; // This is base58 encoded\n+\n+  console.log(`Benchmarking decodeBase58 for ${iterations} iterations...`);\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    decodeBase58(base58String);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n+  return { total, avg };\n+}\n+\n+function benchmarkTextEncoder(iterations: number = 100000) {\n+  const message = 'test message for text encoding';\n+\n+  console.log(`Benchmarking TextEncoder for ${iterations} iterations...`);\n+  const encoder = new TextEncoder();\n+  const start = performance.now();\n+  for (let i = 0; i < iterations; i++) {\n+    encoder.encode(message);\n+  }\n+  const end = performance.now();\n+  const total = end - start;\n+  const avg = total / iterations;\n+  console.log(`Total time: ${total.toFixed(2)} ms`);\n+  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n+  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n+  return { total, avg };\n+}\n+\n+async function main() {\n+  console.log('=== Secret Library Performance Benchmark ===\\n');\n+  console.log('Focus: makeSecret and verifySecretSigner\\n');\n+\n+  // Warm up\n+  console.log('Warming up...');\n+  await benchmarkMakeSecret(10);\n+  await benchmarkVerifySecretSigner(10);\n+\n+  // Actual benchmarks\n+  console.log('\\n--- makeSecret Benchmark ---');\n+  const makeSecretResult = await benchmarkMakeSecret(1000);\n+\n+  console.log('\\n--- verifySecretSigner Benchmark ---');\n+  const verifyResult = await benchmarkVerifySecretSigner(10000); // More iterations for synchronous function\n+\n+  console.log('\\n--- Combined Workflow Benchmark ---');\n+  const combinedResult = await benchmarkCombined(500); // Fewer iterations due to async crypto\n+\n+  console.log('\\n--- Fine-grained Benchmarks ---');\n+\n+  console.log('\\n1. Component-level benchmarks:');\n+  const tagsTextResult = benchmarkGetTagsText(100000);\n+  const messageConstructionResult = benchmarkMessageConstruction(100000);\n+  const decodeBase58Result = benchmarkDecodeBase58(100000);\n+  const textEncoderResult = benchmarkTextEncoder(100000);\n+\n+  console.log('\\n2. Crypto primitive benchmarks:');\n+  const signMessageResult = benchmarkSignMessage(10000);\n+  const verifyMessageResult = benchmarkVerifyMessage(10000);\n+\n+  console.log('\\n3. verifySecretSigner breakdown (using previous result):');\n+\n+  console.log('\\n--- Summary ---');\n+  console.log(`makeSecret average: ${makeSecretResult.avg.toFixed(3)} ms`);\n+  console.log(`verifySecretSigner average: ${verifyResult.avg.toFixed(5)} ms`);\n+  console.log(`Combined average: ${combinedResult.avg.toFixed(3)} ms`);\n+  console.log(`\\nPerformance analysis:`);\n+  console.log(\n+    `- makeSecret dominates total time: ${((makeSecretResult.avg / combinedResult.avg) * 100).toFixed(\n+      1,\n+    )}% of combined workflow`,\n+  );\n+  console.log(\n+    `- verifySecretSigner is ${(makeSecretResult.avg / verifyResult.avg).toFixed(0)}x faster than makeSecret`,\n+  );\n+\n+  console.log(`\\nFine-grained analysis of verifySecretSigner (~${verifyResult.avg.toFixed(3)} ms):`);\n+  console.log(\n+    `  - getTagsText: ${tagsTextResult.avg.toFixed(6)} ms (${(\n+      (tagsTextResult.avg / verifyResult.avg) *\n+      100\n+    ).toFixed(2)}%)`,\n+  );\n+  console.log(\n+    `  - message construction: ${messageConstructionResult.avg.toFixed(6)} ms (${(\n+      (messageConstructionResult.avg / verifyResult.avg) *\n+      100\n+    ).toFixed(2)}%)`,\n+  );\n+  console.log(\n+    `  - decodeBase58 (2x): ${(decodeBase58Result.avg * 2).toFixed(6)} ms (${(\n+      ((decodeBase58Result.avg * 2) / verifyResult.avg) *\n+      100\n+    ).toFixed(2)}%)`,\n+  );\n+  console.log(\n+    `  - TextEncoder.encode: ${textEncoderResult.avg.toFixed(6)} ms (${(\n+      (textEncoderResult.avg / verifyResult.avg) *\n+      100\n+    ).toFixed(2)}%)`,\n+  );\n+  console.log(\n+    `  - verifyMessage (crypto): ${verifyMessageResult.avg.toFixed(5)} ms (${(\n+      (verifyMessageResult.avg / verifyResult.avg) *\n+      100\n+    ).toFixed(2)}%)`,\n+  );\n+  console.log(\n+    `  - estimated overhead: ${(\n+      verifyResult.avg -\n+      tagsTextResult.avg -\n+      messageConstructionResult.avg -\n+      decodeBase58Result.avg * 2 -\n+      textEncoderResult.avg -\n+      verifyMessageResult.avg\n+    ).toFixed(5)} ms`,\n+  );\n+\n+  console.log(`\\nCrypto primitive comparison:`);\n+  console.log(`  - signMessage: ${signMessageResult.avg.toFixed(5)} ms`);\n+  console.log(`  - verifyMessage: ${verifyMessageResult.avg.toFixed(5)} ms`);\n+  console.log(`  - ratio (verify/sign): ${(verifyMessageResult.avg / signMessageResult.avg).toFixed(2)}x`);\n+}\n+\n+if (require.main === module) {\n+  main().catch(console.error);\n+}\n+\n+export {\n+  benchmarkMakeSecret,\n+  benchmarkVerifySecretSigner,\n+  benchmarkCombined,\n+  benchmarkGetTagsText,\n+  benchmarkMessageConstruction,\n+  benchmarkVerifyMessage,\n+  benchmarkSignMessage,\n+  benchmarkDecodeBase58,\n+  benchmarkTextEncoder,\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "benchmarkMakeSecret",
              "code": "async function benchmarkMakeSecret(iterations: number = 1000) {",
              "lineStart": 7,
              "lineEnd": 7
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 8,
              "lineEnd": 8
            },
            {
              "type": "function",
              "name": "readerKeyPair",
              "code": "const readerKeyPair = createKeyPair();",
              "lineStart": 9,
              "lineEnd": 9
            },
            {
              "type": "function",
              "name": "secretData",
              "code": "const secretData = new Uint8Array(32); // 32 bytes of dummy data\ncrypto.getRandomValues(secretData);\n",
              "lineStart": 10,
              "lineEnd": 12
            },
            {
              "type": "function",
              "name": "tags",
              "code": "const tags = { env: 'test', user: 'benchmark' };\n\nconsole.log(`Benchmarking makeSecret for ${iterations} iterations...`);",
              "lineStart": 13,
              "lineEnd": 15
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 16,
              "lineEnd": 16
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n}",
              "lineStart": 17,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 20,
              "lineEnd": 20
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 21,
              "lineEnd": 21
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n  return { total, avg };\n}\n",
              "lineStart": 22,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "benchmarkVerifySecretSigner",
              "code": "async function benchmarkVerifySecretSigner(iterations: number = 1000) {",
              "lineStart": 29,
              "lineEnd": 29
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 30,
              "lineEnd": 30
            },
            {
              "type": "function",
              "name": "readerKeyPair",
              "code": "const readerKeyPair = createKeyPair();",
              "lineStart": 31,
              "lineEnd": 31
            },
            {
              "type": "function",
              "name": "secretData",
              "code": "const secretData = new Uint8Array(32);\ncrypto.getRandomValues(secretData);",
              "lineStart": 32,
              "lineEnd": 33
            },
            {
              "type": "function",
              "name": "tags",
              "code": "const tags = { env: 'test', user: 'benchmark' };\n\n// Create a single secret record to verify repeatedly",
              "lineStart": 34,
              "lineEnd": 36
            },
            {
              "type": "function",
              "name": "secretRecord",
              "code": "const secretRecord = await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n\nconsole.log(`Benchmarking verifySecretSigner for ${iterations} iterations...`);",
              "lineStart": 37,
              "lineEnd": 39
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 40,
              "lineEnd": 40
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  verifySecretSigner(secretRecord);\n}",
              "lineStart": 41,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 44,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 45,
              "lineEnd": 45
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n  return { total, avg };\n}\n",
              "lineStart": 46,
              "lineEnd": 52
            },
            {
              "type": "function",
              "name": "benchmarkCombined",
              "code": "async function benchmarkCombined(iterations: number = 1000) {",
              "lineStart": 53,
              "lineEnd": 53
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 54,
              "lineEnd": 54
            },
            {
              "type": "function",
              "name": "readerKeyPair",
              "code": "const readerKeyPair = createKeyPair();",
              "lineStart": 55,
              "lineEnd": 55
            },
            {
              "type": "function",
              "name": "secretData",
              "code": "const secretData = new Uint8Array(32);\ncrypto.getRandomValues(secretData);",
              "lineStart": 56,
              "lineEnd": 57
            },
            {
              "type": "function",
              "name": "tags",
              "code": "const tags = { env: 'test', user: 'benchmark' };\n\nconsole.log(`Benchmarking makeSecret + verifySecretSigner combined for ${iterations} iterations...`);",
              "lineStart": 58,
              "lineEnd": 60
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 61,
              "lineEnd": 61
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {",
              "lineStart": 62,
              "lineEnd": 62
            },
            {
              "type": "function",
              "name": "secretRecord",
              "code": "  const secretRecord = await makeSecret(secretData, tags, readerKeyPair.public_key, keyPair);\n  verifySecretSigner(secretRecord);\n}",
              "lineStart": 63,
              "lineEnd": 65
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 66,
              "lineEnd": 66
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 67,
              "lineEnd": 67
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(3)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n  return { total, avg };\n}\n\n// ===== Fine-grained benchmark functions =====\n",
              "lineStart": 68,
              "lineEnd": 76
            },
            {
              "type": "function",
              "name": "benchmarkGetTagsText",
              "code": "function benchmarkGetTagsText(iterations: number = 100000) {",
              "lineStart": 77,
              "lineEnd": 77
            },
            {
              "type": "function",
              "name": "tags",
              "code": "const tags = { env: 'test', user: 'benchmark', app: 'secret-service', version: '1.0.0' };\n\nconsole.log(`Benchmarking getTagsText for ${iterations} iterations...`);",
              "lineStart": 78,
              "lineEnd": 80
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 81,
              "lineEnd": 81
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  getTagsText(tags);\n}",
              "lineStart": 82,
              "lineEnd": 84
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 85,
              "lineEnd": 85
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 86,
              "lineEnd": 86
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n  return { total, avg };\n}\n",
              "lineStart": 87,
              "lineEnd": 93
            },
            {
              "type": "function",
              "name": "benchmarkMessageConstruction",
              "code": "function benchmarkMessageConstruction(iterations: number = 100000) {",
              "lineStart": 94,
              "lineEnd": 94
            },
            {
              "type": "function",
              "name": "signer",
              "code": "const signer = 'signer123';",
              "lineStart": 95,
              "lineEnd": 95
            },
            {
              "type": "function",
              "name": "reader",
              "code": "const reader = 'reader456';",
              "lineStart": 96,
              "lineEnd": 96
            },
            {
              "type": "function",
              "name": "tags",
              "code": "const tags = { env: 'test', user: 'benchmark' };",
              "lineStart": 97,
              "lineEnd": 97
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data = 'encryptedDataBase64String';",
              "lineStart": 98,
              "lineEnd": 98
            },
            {
              "type": "function",
              "name": "tagsText",
              "code": "const tagsText = getTagsText(tags);\n\nconsole.log(`Benchmarking message construction for ${iterations} iterations...`);",
              "lineStart": 99,
              "lineEnd": 101
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 102,
              "lineEnd": 102
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {",
              "lineStart": 103,
              "lineEnd": 103
            },
            {
              "type": "function",
              "name": "message",
              "code": "  const message = signer + reader + tagsText + data;\n}",
              "lineStart": 104,
              "lineEnd": 105
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 106,
              "lineEnd": 106
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 107,
              "lineEnd": 107
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n  return { total, avg };\n}\n",
              "lineStart": 108,
              "lineEnd": 114
            },
            {
              "type": "function",
              "name": "benchmarkVerifyMessage",
              "code": "function benchmarkVerifyMessage(iterations: number = 10000) {",
              "lineStart": 115,
              "lineEnd": 115
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 116,
              "lineEnd": 116
            },
            {
              "type": "function",
              "name": "message",
              "code": "const message = 'test message for signature verification';",
              "lineStart": 117,
              "lineEnd": 117
            },
            {
              "type": "function",
              "name": "signature",
              "code": "const signature = signMessage(message, keyPair.private_key);\n\nconsole.log(`Benchmarking verifyMessage for ${iterations} iterations...`);",
              "lineStart": 118,
              "lineEnd": 120
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 121,
              "lineEnd": 121
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  verifyMessage(message, signature, keyPair.public_key);\n}",
              "lineStart": 122,
              "lineEnd": 124
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 125,
              "lineEnd": 125
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 126,
              "lineEnd": 126
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(5)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n  return { total, avg };\n}\n",
              "lineStart": 127,
              "lineEnd": 133
            },
            {
              "type": "function",
              "name": "benchmarkSignMessage",
              "code": "function benchmarkSignMessage(iterations: number = 10000) {",
              "lineStart": 134,
              "lineEnd": 134
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 135,
              "lineEnd": 135
            },
            {
              "type": "function",
              "name": "message",
              "code": "const message = 'test message for signing';\n\nconsole.log(`Benchmarking signMessage for ${iterations} iterations...`);",
              "lineStart": 136,
              "lineEnd": 138
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 139,
              "lineEnd": 139
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  signMessage(message, keyPair.private_key);\n}",
              "lineStart": 140,
              "lineEnd": 142
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 143,
              "lineEnd": 143
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 144,
              "lineEnd": 144
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(5)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(1)}`);\n  return { total, avg };\n}\n",
              "lineStart": 145,
              "lineEnd": 151
            },
            {
              "type": "function",
              "name": "benchmarkDecodeBase58",
              "code": "function benchmarkDecodeBase58(iterations: number = 100000) {\n  // Generate a sample base58 string",
              "lineStart": 152,
              "lineEnd": 153
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = createKeyPair();",
              "lineStart": 154,
              "lineEnd": 154
            },
            {
              "type": "function",
              "name": "base58String",
              "code": "const base58String = keyPair.public_key; // This is base58 encoded\n\nconsole.log(`Benchmarking decodeBase58 for ${iterations} iterations...`);",
              "lineStart": 155,
              "lineEnd": 157
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 158,
              "lineEnd": 158
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  decodeBase58(base58String);\n}",
              "lineStart": 159,
              "lineEnd": 161
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 162,
              "lineEnd": 162
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 163,
              "lineEnd": 163
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n  return { total, avg };\n}\n",
              "lineStart": 164,
              "lineEnd": 170
            },
            {
              "type": "function",
              "name": "benchmarkTextEncoder",
              "code": "function benchmarkTextEncoder(iterations: number = 100000) {",
              "lineStart": 171,
              "lineEnd": 171
            },
            {
              "type": "function",
              "name": "message",
              "code": "const message = 'test message for text encoding';\n\nconsole.log(`Benchmarking TextEncoder for ${iterations} iterations...`);",
              "lineStart": 172,
              "lineEnd": 174
            },
            {
              "type": "function",
              "name": "encoder",
              "code": "const encoder = new TextEncoder();",
              "lineStart": 175,
              "lineEnd": 175
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 176,
              "lineEnd": 176
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {\n  encoder.encode(message);\n}",
              "lineStart": 177,
              "lineEnd": 179
            },
            {
              "type": "function",
              "name": "end",
              "code": "const end = performance.now();",
              "lineStart": 180,
              "lineEnd": 180
            },
            {
              "type": "function",
              "name": "total",
              "code": "const total = end - start;",
              "lineStart": 181,
              "lineEnd": 181
            },
            {
              "type": "function",
              "name": "avg",
              "code": "  const avg = total / iterations;\n  console.log(`Total time: ${total.toFixed(2)} ms`);\n  console.log(`Average per call: ${avg.toFixed(6)} ms`);\n  console.log(`Calls per second: ${(1000 / avg).toFixed(0)}`);\n  return { total, avg };\n}\n",
              "lineStart": 182,
              "lineEnd": 188
            },
            {
              "type": "function",
              "name": "main",
              "code": "async function main() {\n  console.log('=== Secret Library Performance Benchmark ===\\n');\n  console.log('Focus: makeSecret and verifySecretSigner\\n');\n\n  // Warm up\n  console.log('Warming up...');\n  await benchmarkMakeSecret(10);\n  await benchmarkVerifySecretSigner(10);\n\n  // Actual benchmarks\n  console.log('\\n--- makeSecret Benchmark ---');",
              "lineStart": 189,
              "lineEnd": 199
            },
            {
              "type": "function",
              "name": "makeSecretResult",
              "code": "const makeSecretResult = await benchmarkMakeSecret(1000);\n\nconsole.log('\\n--- verifySecretSigner Benchmark ---');",
              "lineStart": 200,
              "lineEnd": 202
            },
            {
              "type": "function",
              "name": "verifyResult",
              "code": "const verifyResult = await benchmarkVerifySecretSigner(10000); // More iterations for synchronous function\n\nconsole.log('\\n--- Combined Workflow Benchmark ---');",
              "lineStart": 203,
              "lineEnd": 205
            },
            {
              "type": "function",
              "name": "combinedResult",
              "code": "const combinedResult = await benchmarkCombined(500); // Fewer iterations due to async crypto\n\nconsole.log('\\n--- Fine-grained Benchmarks ---');\n\nconsole.log('\\n1. Component-level benchmarks:');",
              "lineStart": 206,
              "lineEnd": 210
            },
            {
              "type": "function",
              "name": "tagsTextResult",
              "code": "const tagsTextResult = benchmarkGetTagsText(100000);",
              "lineStart": 211,
              "lineEnd": 211
            },
            {
              "type": "function",
              "name": "messageConstructionResult",
              "code": "const messageConstructionResult = benchmarkMessageConstruction(100000);",
              "lineStart": 212,
              "lineEnd": 212
            },
            {
              "type": "function",
              "name": "decodeBase58Result",
              "code": "const decodeBase58Result = benchmarkDecodeBase58(100000);",
              "lineStart": 213,
              "lineEnd": 213
            },
            {
              "type": "function",
              "name": "textEncoderResult",
              "code": "const textEncoderResult = benchmarkTextEncoder(100000);\n\nconsole.log('\\n2. Crypto primitive benchmarks:');",
              "lineStart": 214,
              "lineEnd": 216
            },
            {
              "type": "function",
              "name": "signMessageResult",
              "code": "const signMessageResult = benchmarkSignMessage(10000);",
              "lineStart": 217,
              "lineEnd": 217
            },
            {
              "type": "function",
              "name": "verifyMessageResult",
              "code": "const verifyMessageResult = benchmarkVerifyMessage(10000);\n\nconsole.log('\\n3. verifySecretSigner breakdown (using previous result):');\n\nconsole.log('\\n--- Summary ---');\nconsole.log(`makeSecret average: ${makeSecretResult.avg.toFixed(3)} ms`);\nconsole.log(`verifySecretSigner average: ${verifyResult.avg.toFixed(5)} ms`);\nconsole.log(`Combined average: ${combinedResult.avg.toFixed(3)} ms`);\nconsole.log(`\\nPerformance analysis:`);\nconsole.log(\n  `- makeSecret dominates total time: ${((makeSecretResult.avg / combinedResult.avg) * 100).toFixed(\n    1,\n  )}% of combined workflow`,\n);\nconsole.log(",
              "lineStart": 218,
              "lineEnd": 299
            }
          ]
        },
        {
          "additions": 13,
          "deletions": 0,
          "path": "libraries/secret/etc/secret.api.md",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/etc/secret.api.md b/libraries/secret/etc/secret.api.md\nindex d805c001e..eb2ba92e0 100644\n--- a/libraries/secret/etc/secret.api.md\n+++ b/libraries/secret/etc/secret.api.md\n@@ -6,0 +7 @@\n+import { IEd25519KeyPair } from '@yuants/utils';\r\n@@ -17,0 +19,9 @@ export interface ISecret {\n+// @public\r\n+export const listSecrets: (terminal: Terminal, filter: {\r\n+    tags?: Record<string, string>;\r\n+    reader?: string;\r\n+}) => Promise<ISecret[]>;\r\n+\r\n+// @public\r\n+export const makeSecret: (secret: Uint8Array, tags: Record<string, string>, reader: string, signerKeyPair: IEd25519KeyPair) => Promise<ISecret>;\r\n+\r\n@@ -23,0 +34,3 @@ export const setupSecretProxyService: (terminal: Terminal, trusted_public_keys?:\n+// @public\r\n+export const verifySecretSigner: (secret: ISecret) => boolean;\r\n+\r\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "listSecrets",
              "code": "export const listSecrets: (terminal: Terminal, filter: {\r\n    tags?: Record<string, string>;\r\n    reader?: string;\r\n}) => Promise<ISecret[]>;\r\n\r\n// @public\r",
              "lineStart": 20,
              "lineEnd": 25
            },
            {
              "type": "function",
              "name": "makeSecret",
              "code": "export const makeSecret: (secret: Uint8Array, tags: Record<string, string>, reader: string, signerKeyPair: IEd25519KeyPair) => Promise<ISecret>;\r\n\r\n// @public\r",
              "lineStart": 26,
              "lineEnd": 34
            },
            {
              "type": "function",
              "name": "verifySecretSigner",
              "code": "export const verifySecretSigner: (secret: ISecret) => boolean;\r\n\r",
              "lineStart": 35,
              "lineEnd": 37
            }
          ]
        },
        {
          "additions": 7,
          "deletions": 174,
          "path": "libraries/secret/src/index.ts",
          "changeType": "modified",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/index.ts b/libraries/secret/src/index.ts\nindex 8b767a426..ab01ee9c6 100644\n--- a/libraries/secret/src/index.ts\n+++ b/libraries/secret/src/index.ts\n@@ -1,174 +1,7 @@\n-import { Terminal } from '@yuants/protocol';\n-import { buildInsertManyIntoTableSQL, escapeSQL, requestSQL } from '@yuants/sql';\n-import {\n-  decodeBase64,\n-  decryptByPrivateKeyAsync,\n-  encodeBase64,\n-  encodePath,\n-  encryptByPublicKeyAsync,\n-  fromPrivateKey,\n-  newError,\n-  signMessage,\n-  verifyMessage,\n-} from '@yuants/utils';\n-\n-/**\n- * Arbitrary secret data storage interface\n- *\n- * @public\n- */\n-export interface ISecret {\n-  /**\n-   * Signature of the secret record (signer + reader + tags + data) (Primary Key)\n-   */\n-  sign: string;\n-  /**\n-   * Public key of the signer of the secret record (Indexed)\n-   */\n-  signer: string;\n-  /**\n-   * Public key of the reader authorized to decrypt the secret data (Indexed)\n-   */\n-  reader: string;\n-  /**\n-   * JSONB object of tags (GIN indexed)\n-   */\n-  tags: Record<string, string>;\n-  /**\n-   * Base64 encoded encrypted data\n-   */\n-  data: string;\n-}\n-\n-const getTagsText = (tags: Record<string, string>) =>\n-  Object.entries(tags)\n-    .sort(([k1], [k2]) => k1.localeCompare(k2))\n-    .map(([k, v]) => `${k}=${v}`)\n-    .join('');\n-\n-/**\n- * Write a secret to the database\n- * @param terminal - The terminal instance\n- * @param tags - The tags associated with the secret\n- * @param secret - The secret data\n- * @param reader - The public key of the reader\n- *\n- * @public\n- */\n-export const writeSecret = async (\n-  terminal: Terminal,\n-  reader: string,\n-  tags: Record<string, string>,\n-  secret: Uint8Array,\n-  signer_private_key: string = terminal.keyPair.private_key,\n-): Promise<ISecret> => {\n-  const data = encodeBase64(await encryptByPublicKeyAsync(secret, reader));\n-  const tagsText = getTagsText(tags);\n-  const signer = terminal.keyPair.public_key;\n-  const message = signer + reader + tagsText + data;\n-  const signature = signMessage(message, signer_private_key);\n-\n-  const record: ISecret = {\n-    sign: signature,\n-    signer: signer,\n-    reader: reader,\n-    tags: tags,\n-    data: data,\n-  };\n-\n-  await requestSQL(\n-    terminal,\n-    buildInsertManyIntoTableSQL([record], 'secret', {\n-      ignoreConflict: true,\n-    }),\n-  );\n-\n-  return record;\n-};\n-\n-/**\n- * Read and decrypt a secret\n- * @param terminal - The terminal instance\n- * @param secret - The secret record to read\n- * @param reader_private_key - The private key of the reader\n- * @returns The decrypted secret data\n- *\n- * @public\n- */\n-export const readSecret = async (\n-  terminal: Terminal,\n-  secret: ISecret,\n-  reader_private_key: string = terminal.keyPair.private_key,\n-): Promise<Uint8Array> => {\n-  const message = secret.signer + secret.reader + getTagsText(secret.tags) + secret.data;\n-\n-  const valid = verifyMessage(message, secret.sign, secret.signer);\n-  if (!valid) throw newError('InvalidSecretSignature', { message });\n-\n-  const keyPair = fromPrivateKey(reader_private_key);\n-\n-  if (secret.reader !== keyPair.public_key) {\n-    const data_base64 = await terminal.client.requestForResponseData<\n-      { secret_sign: string; public_key: string },\n-      string\n-    >(encodePath('ReadSecret', secret.reader), {\n-      secret_sign: secret.sign,\n-      public_key: terminal.keyPair.public_key,\n-    });\n-    return terminal.security.decryptDataWithRemotePublicKey(decodeBase64(data_base64), secret.reader);\n-  }\n-  const decrypted = await decryptByPrivateKeyAsync(decodeBase64(secret.data), reader_private_key);\n-  return decrypted;\n-};\n-\n-/**\n- * Setup secret proxy service on the terminal\n- *\n- * @param terminal - The terminal instance\n- * @param trusted_public_keys - Set of trusted public keys allowed to read secrets\n- * @returns Set of trusted public keys\n- *\n- * @public\n- */\n-export const setupSecretProxyService = (terminal: Terminal, trusted_public_keys = new Set<string>()) => {\n-  trusted_public_keys.add(terminal.keyPair.public_key);\n-\n-  terminal.server.provideService<\n-    {\n-      secret_sign: string;\n-      public_key: string;\n-    },\n-    string\n-  >(\n-    encodePath('ReadSecret', terminal.keyPair.public_key),\n-    {\n-      type: 'object',\n-      required: ['secret_sign', 'public_key'],\n-      properties: {\n-        secret_sign: { type: 'string' },\n-        public_key: { type: 'string' },\n-      },\n-    },\n-    async ({ req }) => {\n-      if (!trusted_public_keys.has(req.public_key))\n-        throw newError('PublicKeyNotTrusted', { public_key: req.public_key });\n-\n-      const [secret] = await requestSQL<ISecret[]>(\n-        terminal,\n-        `select * from secret where sign = ${escapeSQL(req.secret_sign)}`,\n-      );\n-\n-      if (!secret) throw newError('SecretNotFound', { secret_sign: req.secret_sign });\n-\n-      const data = await readSecret(terminal, secret);\n-\n-      const dataForRemote = await terminal.security.encryptDataWithRemotePublicKey(data, req.public_key);\n-\n-      const data_base64 = encodeBase64(dataForRemote);\n-\n-      return { res: { code: 0, message: 'OK', data: data_base64 } };\n-    },\n-  );\n-\n-  return trusted_public_keys;\n-};\n+export { listSecrets } from './listSecrets';\n+export { makeSecret } from './makeSecret';\n+export { readSecret } from './readSecret';\n+export { setupSecretProxyService } from './setupSecretProxyService';\n+export { ISecret } from './types';\n+export { verifySecretSigner } from './verifySecretSigner';\n+export { writeSecret } from './writeSecret';\n",
          "codeSnippets": []
        },
        {
          "additions": 31,
          "deletions": 0,
          "path": "libraries/secret/src/listSecrets.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/listSecrets.ts b/libraries/secret/src/listSecrets.ts\nnew file mode 100644\nindex 000000000..eebd17c1a\n--- /dev/null\n+++ b/libraries/secret/src/listSecrets.ts\n@@ -0,0 +1,31 @@\n+import { Terminal } from '@yuants/protocol';\n+import { escapeSQL, requestSQL } from '@yuants/sql';\n+import { ISecret } from './types';\n+\n+/**\n+ * List secrets with filtering options\n+ * @param terminal - The terminal instance\n+ * @param filter - Filter options including tags and reader\n+ * @returns\n+ * @public\n+ */\n+export const listSecrets = async (\n+  terminal: Terminal,\n+  filter: { tags?: Record<string, string>; reader?: string },\n+): Promise<ISecret[]> => {\n+  const conditions: string[] = [];\n+  if (filter.reader) {\n+    conditions.push(`reader = ${escapeSQL(filter.reader)}`);\n+  }\n+  if (filter.tags) {\n+    for (const [k, v] of Object.entries(filter.tags)) {\n+      conditions.push(`tags->>${escapeSQL(k)} = ${escapeSQL(v)}`);\n+    }\n+  }\n+\n+  const secrets = await requestSQL<ISecret[]>(\n+    terminal,\n+    `select * from secret ${conditions.length ? 'where ' + conditions.join(' and ') : ''}`,\n+  );\n+  return secrets;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "listSecrets",
              "code": "export const listSecrets = async (\n  terminal: Terminal,\n  filter: { tags?: Record<string, string>; reader?: string },\n): Promise<ISecret[]> => {",
              "lineStart": 12,
              "lineEnd": 15
            },
            {
              "type": "function",
              "name": "conditions",
              "code": "const conditions: string[] = [];\nif (filter.reader) {\n  conditions.push(`reader = ${escapeSQL(filter.reader)}`);\n}\nif (filter.tags) {\n  for (const [k, v] of Object.entries(filter.tags)) {\n    conditions.push(`tags->>${escapeSQL(k)} = ${escapeSQL(v)}`);\n  }\n}\n",
              "lineStart": 16,
              "lineEnd": 25
            },
            {
              "type": "function",
              "name": "secrets",
              "code": "  const secrets = await requestSQL<ISecret[]>(\n    terminal,\n    `select * from secret ${conditions.length ? 'where ' + conditions.join(' and ') : ''}`,\n  );\n  return secrets;\n};",
              "lineStart": 26,
              "lineEnd": 32
            }
          ]
        },
        {
          "additions": 33,
          "deletions": 0,
          "path": "libraries/secret/src/makeSecret.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/makeSecret.ts b/libraries/secret/src/makeSecret.ts\nnew file mode 100644\nindex 000000000..9f8263884\n--- /dev/null\n+++ b/libraries/secret/src/makeSecret.ts\n@@ -0,0 +1,33 @@\n+import { IEd25519KeyPair, encodeBase64, encryptByPublicKeyAsync, signMessage } from '@yuants/utils';\n+import { ISecret } from './types';\n+import { makeSecretSignerMessage } from './utils';\n+\n+/**\n+ * Make a secret record\n+ * @param secret - The secret data to encrypt\n+ * @param tags - The tags associated with the secret\n+ * @param reader - The public key of the reader\n+ * @param signerKeyPair - The key pair of the signer\n+ * @returns The secret record\n+ * @public\n+ */\n+export const makeSecret = async (\n+  secret: Uint8Array,\n+  tags: Record<string, string>,\n+  reader: string,\n+  signerKeyPair: IEd25519KeyPair,\n+) => {\n+  const data = encodeBase64(await encryptByPublicKeyAsync(secret, reader));\n+  const signer = signerKeyPair.public_key;\n+  const message = makeSecretSignerMessage(signer, reader, tags, data);\n+  const signature = signMessage(message, signerKeyPair.private_key);\n+\n+  const record: ISecret = {\n+    sign: signature,\n+    signer: signer,\n+    reader: reader,\n+    tags: tags,\n+    data: data,\n+  };\n+  return record;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "makeSecret",
              "code": "export const makeSecret = async (\n  secret: Uint8Array,\n  tags: Record<string, string>,\n  reader: string,\n  signerKeyPair: IEd25519KeyPair,\n) => {",
              "lineStart": 14,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data = encodeBase64(await encryptByPublicKeyAsync(secret, reader));",
              "lineStart": 20,
              "lineEnd": 20
            },
            {
              "type": "function",
              "name": "signer",
              "code": "const signer = signerKeyPair.public_key;",
              "lineStart": 21,
              "lineEnd": 21
            },
            {
              "type": "function",
              "name": "message",
              "code": "const message = makeSecretSignerMessage(signer, reader, tags, data);",
              "lineStart": 22,
              "lineEnd": 22
            },
            {
              "type": "function",
              "name": "signature",
              "code": "const signature = signMessage(message, signerKeyPair.private_key);\n",
              "lineStart": 23,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "record",
              "code": "  const record: ISecret = {\n    sign: signature,\n    signer: signer,\n    reader: reader,\n    tags: tags,\n    data: data,\n  };\n  return record;\n};",
              "lineStart": 25,
              "lineEnd": 34
            }
          ]
        },
        {
          "additions": 42,
          "deletions": 0,
          "path": "libraries/secret/src/readSecret.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/readSecret.ts b/libraries/secret/src/readSecret.ts\nnew file mode 100644\nindex 000000000..4700b001f\n--- /dev/null\n+++ b/libraries/secret/src/readSecret.ts\n@@ -0,0 +1,42 @@\n+import { Terminal } from '@yuants/protocol';\n+import { decodeBase64, decryptByPrivateKeyAsync, encodePath, fromPrivateKey, newError } from '@yuants/utils';\n+import { ISecret } from './types';\n+import { verifySecretSigner } from './verifySecretSigner';\n+\n+/**\n+ * Read and decrypt a secret\n+ * @param terminal - The terminal instance\n+ * @param secret - The secret record to read\n+ * @param reader_private_key - The private key of the reader\n+ * @returns The decrypted secret data\n+ *\n+ * @public\n+ */\n+export const readSecret = async (\n+  terminal: Terminal,\n+  secret: ISecret,\n+  reader_private_key: string = terminal.keyPair.private_key,\n+): Promise<Uint8Array> => {\n+  const valid = verifySecretSigner(secret);\n+  if (!valid) throw newError('InvalidSecretSignature', { secret });\n+\n+  const keyPair = fromPrivateKey(reader_private_key);\n+\n+  let decrypted: Uint8Array;\n+  if (secret.reader !== keyPair.public_key) {\n+    const data_base64 = await terminal.client.requestForResponseData<\n+      { secret_sign: string; public_key: string },\n+      string\n+    >(encodePath('ReadSecret', secret.reader), {\n+      secret_sign: secret.sign,\n+      public_key: terminal.keyPair.public_key,\n+    });\n+    decrypted = await terminal.security.decryptDataWithRemotePublicKey(\n+      decodeBase64(data_base64),\n+      secret.reader,\n+    );\n+  } else {\n+    decrypted = await decryptByPrivateKeyAsync(decodeBase64(secret.data), reader_private_key);\n+  }\n+  return decrypted;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "readSecret",
              "code": "export const readSecret = async (\n  terminal: Terminal,\n  secret: ISecret,\n  reader_private_key: string = terminal.keyPair.private_key,\n): Promise<Uint8Array> => {",
              "lineStart": 15,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "valid",
              "code": "const valid = verifySecretSigner(secret);\nif (!valid) throw newError('InvalidSecretSignature', { secret });\n",
              "lineStart": 20,
              "lineEnd": 22
            },
            {
              "type": "function",
              "name": "keyPair",
              "code": "const keyPair = fromPrivateKey(reader_private_key);\n",
              "lineStart": 23,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "decrypted",
              "code": "let decrypted: Uint8Array;\nif (secret.reader !== keyPair.public_key) {",
              "lineStart": 25,
              "lineEnd": 26
            },
            {
              "type": "function",
              "name": "data_base64",
              "code": "  const data_base64 = await terminal.client.requestForResponseData<\n    { secret_sign: string; public_key: string },\n    string\n  >(encodePath('ReadSecret', secret.reader), {\n    secret_sign: secret.sign,\n    public_key: terminal.keyPair.public_key,\n  });\n  decrypted = await terminal.security.decryptDataWithRemotePublicKey(\n    decodeBase64(data_base64),\n    secret.reader,\n  );\n} else {\n  decrypted = await decryptByPrivateKeyAsync(decodeBase64(secret.data), reader_private_key);\n}\nreturn decrypted;",
              "lineStart": 27,
              "lineEnd": 43
            }
          ]
        },
        {
          "additions": 57,
          "deletions": 0,
          "path": "libraries/secret/src/setupSecretProxyService.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/setupSecretProxyService.ts b/libraries/secret/src/setupSecretProxyService.ts\nnew file mode 100644\nindex 000000000..f5931ca87\n--- /dev/null\n+++ b/libraries/secret/src/setupSecretProxyService.ts\n@@ -0,0 +1,57 @@\n+import { Terminal } from '@yuants/protocol';\n+import { escapeSQL, requestSQL } from '@yuants/sql';\n+import { encodeBase64, encodePath, newError } from '@yuants/utils';\n+import { readSecret } from './readSecret';\n+import { ISecret } from './types';\n+\n+/**\n+ * Setup secret proxy service on the terminal\n+ *\n+ * @param terminal - The terminal instance\n+ * @param trusted_public_keys - Set of trusted public keys allowed to read secrets\n+ * @returns Set of trusted public keys\n+ *\n+ * @public\n+ */\n+export const setupSecretProxyService = (terminal: Terminal, trusted_public_keys = new Set<string>()) => {\n+  trusted_public_keys.add(terminal.keyPair.public_key);\n+\n+  terminal.server.provideService<\n+    {\n+      secret_sign: string;\n+      public_key: string;\n+    },\n+    string\n+  >(\n+    encodePath('ReadSecret', terminal.keyPair.public_key),\n+    {\n+      type: 'object',\n+      required: ['secret_sign', 'public_key'],\n+      properties: {\n+        secret_sign: { type: 'string' },\n+        public_key: { type: 'string' },\n+      },\n+    },\n+    async ({ req }) => {\n+      if (!trusted_public_keys.has(req.public_key))\n+        throw newError('PublicKeyNotTrusted', { public_key: req.public_key });\n+\n+      const [secret] = await requestSQL<ISecret[]>(\n+        terminal,\n+        `select * from secret where sign = ${escapeSQL(req.secret_sign)}`,\n+      );\n+\n+      if (!secret) throw newError('SecretNotFound', { secret_sign: req.secret_sign });\n+\n+      const data = await readSecret(terminal, secret);\n+\n+      const dataForRemote = await terminal.security.encryptDataWithRemotePublicKey(data, req.public_key);\n+\n+      const data_base64 = encodeBase64(dataForRemote);\n+\n+      return { res: { code: 0, message: 'OK', data: data_base64 } };\n+    },\n+  );\n+\n+  return trusted_public_keys;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "setupSecretProxyService",
              "code": "export const setupSecretProxyService = (terminal: Terminal, trusted_public_keys = new Set<string>()) => {\n  trusted_public_keys.add(terminal.keyPair.public_key);\n\n  terminal.server.provideService<\n    {\n      secret_sign: string;\n      public_key: string;\n    },\n    string\n  >(\n    encodePath('ReadSecret', terminal.keyPair.public_key),\n    {\n      type: 'object',\n      required: ['secret_sign', 'public_key'],\n      properties: {",
              "lineStart": 16,
              "lineEnd": 45
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data = await readSecret(terminal, secret);\n",
              "lineStart": 46,
              "lineEnd": 47
            },
            {
              "type": "function",
              "name": "dataForRemote",
              "code": "const dataForRemote = await terminal.security.encryptDataWithRemotePublicKey(data, req.public_key);\n",
              "lineStart": 48,
              "lineEnd": 49
            },
            {
              "type": "function",
              "name": "data_base64",
              "code": "      const data_base64 = encodeBase64(dataForRemote);\n\n      return { res: { code: 0, message: 'OK', data: data_base64 } };\n    },\n  );\n\n  return trusted_public_keys;\n};",
              "lineStart": 50,
              "lineEnd": 58
            }
          ]
        },
        {
          "additions": 27,
          "deletions": 0,
          "path": "libraries/secret/src/types.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/types.ts b/libraries/secret/src/types.ts\nnew file mode 100644\nindex 000000000..59d465ba2\n--- /dev/null\n+++ b/libraries/secret/src/types.ts\n@@ -0,0 +1,27 @@\n+/**\n+ * Arbitrary secret data storage interface\n+ *\n+ * @public\n+ */\n+export interface ISecret {\n+  /**\n+   * Signature of the secret record (signer + reader + tags + data) (Primary Key)\n+   */\n+  sign: string;\n+  /**\n+   * Public key of the signer of the secret record (Indexed)\n+   */\n+  signer: string;\n+  /**\n+   * Public key of the reader authorized to decrypt the secret data (Indexed)\n+   */\n+  reader: string;\n+  /**\n+   * JSONB object of tags (GIN indexed)\n+   */\n+  tags: Record<string, string>;\n+  /**\n+   * Base64 encoded encrypted data\n+   */\n+  data: string;\n+}\n",
          "codeSnippets": [
            {
              "type": "interface",
              "name": "ISecret",
              "code": "export interface ISecret {\n  /**\n   * Signature of the secret record (signer + reader + tags + data) (Primary Key)\n   */\n  sign: string;\n  /**\n   * Public key of the signer of the secret record (Indexed)\n   */\n  signer: string;\n  /**\n   * Public key of the reader authorized to decrypt the secret data (Indexed)\n   */\n  reader: string;\n  /**\n   * JSONB object of tags (GIN indexed)",
              "lineStart": 6,
              "lineEnd": 28
            }
          ]
        },
        {
          "additions": 14,
          "deletions": 0,
          "path": "libraries/secret/src/utils.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/utils.ts b/libraries/secret/src/utils.ts\nnew file mode 100644\nindex 000000000..c640c1ecb\n--- /dev/null\n+++ b/libraries/secret/src/utils.ts\n@@ -0,0 +1,14 @@\n+export const getTagsText = (tags: Record<string, string>) =>\n+  Object.entries(tags)\n+    .sort(([k1], [k2]) => k1.localeCompare(k2))\n+    .map(([k, v]) => `${k}=${v}`)\n+    .join('');\n+\n+export const makeSecretSignerMessage = (\n+  signer: string,\n+  reader: string,\n+  tags: Record<string, string>,\n+  data: string,\n+): string => {\n+  return signer + reader + getTagsText(tags) + data;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "getTagsText",
              "code": "export const getTagsText = (tags: Record<string, string>) =>\n  Object.entries(tags)\n    .sort(([k1], [k2]) => k1.localeCompare(k2))\n    .map(([k, v]) => `${k}=${v}`)\n    .join('');\n",
              "lineStart": 1,
              "lineEnd": 6
            },
            {
              "type": "function",
              "name": "makeSecretSignerMessage",
              "code": "export const makeSecretSignerMessage = (\n  signer: string,\n  reader: string,\n  tags: Record<string, string>,\n  data: string,\n): string => {\n  return signer + reader + getTagsText(tags) + data;\n};",
              "lineStart": 7,
              "lineEnd": 15
            }
          ]
        },
        {
          "additions": 14,
          "deletions": 0,
          "path": "libraries/secret/src/verifySecretSigner.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/verifySecretSigner.ts b/libraries/secret/src/verifySecretSigner.ts\nnew file mode 100644\nindex 000000000..df792a172\n--- /dev/null\n+++ b/libraries/secret/src/verifySecretSigner.ts\n@@ -0,0 +1,14 @@\n+import { verifyMessage } from '@yuants/utils';\n+import { ISecret } from './types';\n+import { makeSecretSignerMessage } from './utils';\n+\n+/**\n+ * Verify the signature of a secret record is signed by the signer\n+ * @param secret - The secret record to verify\n+ * @returns\n+ * @public\n+ */\n+export const verifySecretSigner = (secret: ISecret): boolean => {\n+  const message = makeSecretSignerMessage(secret.signer, secret.reader, secret.tags, secret.data);\n+  return verifyMessage(message, secret.sign, secret.signer);\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "verifySecretSigner",
              "code": "export const verifySecretSigner = (secret: ISecret): boolean => {",
              "lineStart": 11,
              "lineEnd": 11
            },
            {
              "type": "function",
              "name": "message",
              "code": "  const message = makeSecretSignerMessage(secret.signer, secret.reader, secret.tags, secret.data);\n  return verifyMessage(message, secret.sign, secret.signer);\n};",
              "lineStart": 12,
              "lineEnd": 15
            }
          ]
        },
        {
          "additions": 33,
          "deletions": 0,
          "path": "libraries/secret/src/writeSecret.ts",
          "changeType": "added",
          "patch": "commit e743378705faf3ad48352fe6624ab936ac3eec98\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 17:47:08 2025 +0800\n\n    feat: implement secret management functions and benchmarks (#2308)\n\ndiff --git a/libraries/secret/src/writeSecret.ts b/libraries/secret/src/writeSecret.ts\nnew file mode 100644\nindex 000000000..fe9093708\n--- /dev/null\n+++ b/libraries/secret/src/writeSecret.ts\n@@ -0,0 +1,33 @@\n+import { Terminal } from '@yuants/protocol';\n+import { buildInsertManyIntoTableSQL, requestSQL } from '@yuants/sql';\n+import { fromPrivateKey } from '@yuants/utils';\n+import { ISecret } from './types';\n+import { makeSecret } from './makeSecret';\n+\n+/**\n+ * Write a secret to the database\n+ * @param terminal - The terminal instance\n+ * @param tags - The tags associated with the secret\n+ * @param secret - The secret data\n+ * @param reader - The public key of the reader\n+ *\n+ * @public\n+ */\n+export const writeSecret = async (\n+  terminal: Terminal,\n+  reader: string,\n+  tags: Record<string, string>,\n+  secret: Uint8Array,\n+  signer_private_key: string = terminal.keyPair.private_key,\n+): Promise<ISecret> => {\n+  const record = await makeSecret(secret, tags, reader, fromPrivateKey(signer_private_key));\n+\n+  await requestSQL(\n+    terminal,\n+    buildInsertManyIntoTableSQL([record], 'secret', {\n+      ignoreConflict: true,\n+    }),\n+  );\n+\n+  return record;\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "writeSecret",
              "code": "export const writeSecret = async (\n  terminal: Terminal,\n  reader: string,\n  tags: Record<string, string>,\n  secret: Uint8Array,\n  signer_private_key: string = terminal.keyPair.private_key,\n): Promise<ISecret> => {",
              "lineStart": 16,
              "lineEnd": 22
            },
            {
              "type": "function",
              "name": "record",
              "code": "  const record = await makeSecret(secret, tags, reader, fromPrivateKey(signer_private_key));\n\n  await requestSQL(\n    terminal,\n    buildInsertManyIntoTableSQL([record], 'secret', {\n      ignoreConflict: true,\n    }),\n  );\n\n  return record;\n};",
              "lineStart": 23,
              "lineEnd": 34
            }
          ]
        }
      ]
    },
    {
      "hash": "328e8765b2ccde8e1310cf68e7bbd8b79558d85e",
      "short": "328e8765b",
      "author": "humblelittlec1[bot]",
      "email": "208195530+humblelittlec1[bot]@users.noreply.github.com",
      "authoredAt": "2025-12-12 17:53:14 +0800",
      "subject": "chore: bump version (#2309)",
      "conventionalCommit": {
        "type": "chore",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 17,
          "deletions": 0,
          "path": "apps/agent/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/agent/CHANGELOG.json b/apps/agent/CHANGELOG.json\nindex 868e95fc2..0963ef599 100644\n--- a/apps/agent/CHANGELOG.json\n+++ b/apps/agent/CHANGELOG.json\n@@ -3,0 +4,17 @@\n+    {\n+      \"version\": \"0.8.26\",\n+      \"tag\": \"@yuants/app-agent_v0.8.26\",\n+      \"date\": \"Fri, 12 Dec 2025 09:48:48 GMT\",\n+      \"comments\": {\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ],\n+        \"dependency\": [\n+          {\n+            \"comment\": \"Updating dependency \\\"@yuants/secret\\\" to `0.4.0`\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 6,
          "deletions": 1,
          "path": "apps/agent/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/agent/CHANGELOG.md b/apps/agent/CHANGELOG.md\nindex 0032d5caa..857ad57a1 100644\n--- a/apps/agent/CHANGELOG.md\n+++ b/apps/agent/CHANGELOG.md\n@@ -3 +3,6 @@\n-This log was last generated on Thu, 11 Dec 2025 13:59:57 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+\n+## 0.8.26\n+Fri, 12 Dec 2025 09:48:48 GMT\n+\n+_Version update only_\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "apps/agent/package.json",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/agent/package.json b/apps/agent/package.json\nindex 524b24949..476876de2 100644\n--- a/apps/agent/package.json\n+++ b/apps/agent/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.8.25\",\n+  \"version\": \"0.8.26\",\n",
          "codeSnippets": []
        },
        {
          "additions": 17,
          "deletions": 0,
          "path": "apps/alert-receiver/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/CHANGELOG.json b/apps/alert-receiver/CHANGELOG.json\nindex bf5cecb4b..d51d0a1c0 100644\n--- a/apps/alert-receiver/CHANGELOG.json\n+++ b/apps/alert-receiver/CHANGELOG.json\n@@ -3,0 +4,17 @@\n+    {\n+      \"version\": \"0.5.14\",\n+      \"tag\": \"@yuants/app-alert-receiver_v0.5.14\",\n+      \"date\": \"Fri, 12 Dec 2025 09:48:48 GMT\",\n+      \"comments\": {\n+        \"patch\": [\n+          {\n+            \"comment\": \"feat: refactor alert severity computation and enhance alert message rendering\"\n+          }\n+        ],\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 8,
          "deletions": 1,
          "path": "apps/alert-receiver/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/CHANGELOG.md b/apps/alert-receiver/CHANGELOG.md\nindex 43b3a151d..4b392f4b2 100644\n--- a/apps/alert-receiver/CHANGELOG.md\n+++ b/apps/alert-receiver/CHANGELOG.md\n@@ -3 +3,8 @@\n-This log was last generated on Sat, 06 Dec 2025 06:31:30 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+\n+## 0.5.14\n+Fri, 12 Dec 2025 09:48:48 GMT\n+\n+### Patches\n+\n+- feat: refactor alert severity computation and enhance alert message rendering\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "apps/alert-receiver/package.json",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/package.json b/apps/alert-receiver/package.json\nindex 0ec5ccffd..5a9ece7fc 100644\n--- a/apps/alert-receiver/package.json\n+++ b/apps/alert-receiver/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.5.13\",\n+  \"version\": \"0.5.14\",\n",
          "codeSnippets": []
        },
        {
          "additions": 17,
          "deletions": 0,
          "path": "apps/node-unit/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/node-unit/CHANGELOG.json b/apps/node-unit/CHANGELOG.json\nindex 8206a4828..55874f57a 100644\n--- a/apps/node-unit/CHANGELOG.json\n+++ b/apps/node-unit/CHANGELOG.json\n@@ -3,0 +4,17 @@\n+    {\n+      \"version\": \"0.13.1\",\n+      \"tag\": \"@yuants/node-unit_v0.13.1\",\n+      \"date\": \"Fri, 12 Dec 2025 09:48:48 GMT\",\n+      \"comments\": {\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ],\n+        \"dependency\": [\n+          {\n+            \"comment\": \"Updating dependency \\\"@yuants/secret\\\" to `0.4.0`\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 6,
          "deletions": 1,
          "path": "apps/node-unit/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/node-unit/CHANGELOG.md b/apps/node-unit/CHANGELOG.md\nindex 2a1251560..df1c7aefe 100644\n--- a/apps/node-unit/CHANGELOG.md\n+++ b/apps/node-unit/CHANGELOG.md\n@@ -3 +3,6 @@\n-This log was last generated on Mon, 01 Dec 2025 05:41:28 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+\n+## 0.13.1\n+Fri, 12 Dec 2025 09:48:48 GMT\n+\n+_Version update only_\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "apps/node-unit/package.json",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/node-unit/package.json b/apps/node-unit/package.json\nindex 3683a9fdc..eb484e3ef 100644\n--- a/apps/node-unit/package.json\n+++ b/apps/node-unit/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.13.0\",\n+  \"version\": \"0.13.1\",\n",
          "codeSnippets": []
        },
        {
          "additions": 22,
          "deletions": 0,
          "path": "apps/virtual-exchange/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/virtual-exchange/CHANGELOG.json b/apps/virtual-exchange/CHANGELOG.json\nindex 2eff99642..df0691c9a 100644\n--- a/apps/virtual-exchange/CHANGELOG.json\n+++ b/apps/virtual-exchange/CHANGELOG.json\n@@ -3,0 +4,22 @@\n+    {\n+      \"version\": \"0.8.1\",\n+      \"tag\": \"@yuants/app-virtual-exchange_v0.8.1\",\n+      \"date\": \"Fri, 12 Dec 2025 09:48:48 GMT\",\n+      \"comments\": {\n+        \"patch\": [\n+          {\n+            \"comment\": \"rewrite credential resolution\"\n+          }\n+        ],\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ],\n+        \"dependency\": [\n+          {\n+            \"comment\": \"Updating dependency \\\"@yuants/secret\\\" to `0.4.0`\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 8,
          "deletions": 1,
          "path": "apps/virtual-exchange/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/virtual-exchange/CHANGELOG.md b/apps/virtual-exchange/CHANGELOG.md\nindex cd989fdca..d6932a16d 100644\n--- a/apps/virtual-exchange/CHANGELOG.md\n+++ b/apps/virtual-exchange/CHANGELOG.md\n@@ -3 +3,8 @@\n-This log was last generated on Thu, 11 Dec 2025 13:59:57 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+\n+## 0.8.1\n+Fri, 12 Dec 2025 09:48:48 GMT\n+\n+### Patches\n+\n+- rewrite credential resolution\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "apps/virtual-exchange/package.json",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/virtual-exchange/package.json b/apps/virtual-exchange/package.json\nindex 0ed67aa66..3281548ed 100644\n--- a/apps/virtual-exchange/package.json\n+++ b/apps/virtual-exchange/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.8.0\",\n+  \"version\": \"0.8.1\",\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/app-agent/{main_2025-12-11-14-00.json => main_2025-12-12-09-48.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 10,
          "path": "common/changes/@yuants/app-alert-receiver/2025-12-11-17-39.json",
          "changeType": "deleted",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/common/changes/@yuants/app-alert-receiver/2025-12-11-17-39.json b/common/changes/@yuants/app-alert-receiver/2025-12-11-17-39.json\ndeleted file mode 100644\nindex a9c851af0..000000000\n--- a/common/changes/@yuants/app-alert-receiver/2025-12-11-17-39.json\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-{\n-  \"changes\": [\n-    {\n-      \"packageName\": \"@yuants/app-alert-receiver\",\n-      \"comment\": \"feat: refactor alert severity computation and enhance alert message rendering\",\n-      \"type\": \"patch\"\n-    }\n-  ],\n-  \"packageName\": \"@yuants/app-alert-receiver\"\n-}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/app-alert-receiver/{main_2025-12-06-06-31.json => main_2025-12-12-09-48.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 10,
          "path": "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "changeType": "deleted",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json b/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json\ndeleted file mode 100644\nindex dba0c3422..000000000\n--- a/common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-{\n-  \"changes\": [\n-    {\n-      \"packageName\": \"@yuants/app-virtual-exchange\",\n-      \"comment\": \"rewrite credential resolution\",\n-      \"type\": \"patch\"\n-    }\n-  ],\n-  \"packageName\": \"@yuants/app-virtual-exchange\"\n-}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/app-virtual-exchange/{main_2025-12-11-14-00.json => main_2025-12-12-09-48.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/node-unit/{main_2025-12-01-05-41.json => main_2025-12-12-09-48.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 10,
          "path": "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "changeType": "deleted",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/common/changes/@yuants/secret/2025-12-12-09-42.json b/common/changes/@yuants/secret/2025-12-12-09-42.json\ndeleted file mode 100644\nindex 6e2583b0f..000000000\n--- a/common/changes/@yuants/secret/2025-12-12-09-42.json\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-{\n-  \"changes\": [\n-    {\n-      \"packageName\": \"@yuants/secret\",\n-      \"comment\": \"reorg code and support many functions\",\n-      \"type\": \"minor\"\n-    }\n-  ],\n-  \"packageName\": \"@yuants/secret\"\n-}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/secret/{main_2025-11-29-01-31.json => main_2025-12-12-09-48.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        },
        {
          "additions": 17,
          "deletions": 0,
          "path": "libraries/secret/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/libraries/secret/CHANGELOG.json b/libraries/secret/CHANGELOG.json\nindex b069f1a54..32d67254c 100644\n--- a/libraries/secret/CHANGELOG.json\n+++ b/libraries/secret/CHANGELOG.json\n@@ -3,0 +4,17 @@\n+    {\n+      \"version\": \"0.4.0\",\n+      \"tag\": \"@yuants/secret_v0.4.0\",\n+      \"date\": \"Fri, 12 Dec 2025 09:48:48 GMT\",\n+      \"comments\": {\n+        \"minor\": [\n+          {\n+            \"comment\": \"reorg code and support many functions\"\n+          }\n+        ],\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 8,
          "deletions": 1,
          "path": "libraries/secret/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/libraries/secret/CHANGELOG.md b/libraries/secret/CHANGELOG.md\nindex d3ffc0987..e1a61d2a6 100644\n--- a/libraries/secret/CHANGELOG.md\n+++ b/libraries/secret/CHANGELOG.md\n@@ -3 +3,8 @@\n-This log was last generated on Sat, 29 Nov 2025 01:30:37 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+\n+## 0.4.0\n+Fri, 12 Dec 2025 09:48:48 GMT\n+\n+### Minor changes\n+\n+- reorg code and support many functions\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "libraries/secret/package.json",
          "changeType": "modified",
          "patch": "commit 328e8765b2ccde8e1310cf68e7bbd8b79558d85e\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 17:53:14 2025 +0800\n\n    chore: bump version (#2309)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/libraries/secret/package.json b/libraries/secret/package.json\nindex d27112398..96b72a6aa 100644\n--- a/libraries/secret/package.json\n+++ b/libraries/secret/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.3.13\",\n+  \"version\": \"0.4.0\",\n",
          "codeSnippets": []
        }
      ]
    },
    {
      "hash": "53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a",
      "short": "53e361eb4",
      "author": "Siyuan Wang",
      "email": "c.one@thrimbda.com",
      "authoredAt": "2025-12-12 18:32:09 +0800",
      "subject": "feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)",
      "conventionalCommit": {
        "type": "feat",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 138,
          "deletions": 51,
          "path": "apps/alert-receiver/README.md",
          "changeType": "modified",
          "patch": "commit 53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a\nAuthor: Siyuan Wang <c.one@thrimbda.com>\nDate:   Fri Dec 12 18:32:09 2025 +0800\n\n    feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)\n\ndiff --git a/apps/alert-receiver/README.md b/apps/alert-receiver/README.md\nindex c17ad80e5..81f0137c9 100644\n--- a/apps/alert-receiver/README.md\n+++ b/apps/alert-receiver/README.md\n@@ -1 +1 @@\n-# Yuan Alerting Specification\n+# Alert Receiver 设计说明\n@@ -3 +3 @@\n-Alerts in Yuan follows the specification of prometheus operator [runbook](https://runbooks.prometheus-operator.dev/).\n+`alert-receiver` 是 Yuan 的告警接收与通知服务。它从 Prometheus 获取当前 firing 告警快照，写入数据库形成告警历史，并基于路由规则将告警以飞书卡片的形式发送/更新到各个群聊。\n@@ -5 +5 @@ Alerts in Yuan follows the specification of prometheus operator [runbook](https:\n-Each Alerting Rule is relevant to a specific runbook page, consisting of the following sections:\n+本 README 说明该项目的核心设计、数据模型与运行流程（含流程图），作为维护与排障的主要参考。\n@@ -7,4 +7 @@ Each Alerting Rule is relevant to a specific runbook page, consisting of the fol\n-1. Meaning\n-2. Impact\n-3. Diagnosis\n-4. Mitigation\n+## 目标与原则\n@@ -12 +9 @@ Each Alerting Rule is relevant to a specific runbook page, consisting of the fol\n-the annotations of alerting rules are defined as follows:\n+**目标**\n@@ -14,5 +11,26 @@ the annotations of alerting rules are defined as follows:\n-```yaml\n-annotations:\n-  runbook: <runbook page url>\n-  summary: <alert summary>\n-  description: <alert description>\n+- 可靠记录 Prometheus firing/resolved 的状态演进。\n+- 通过数据库驱动的通知系统，向飞书发送告警卡片，并在状态变化时更新。\n+- receiver 自身不稳定时，仍能在恢复后补齐 missing resolved，避免“只触发不恢复”。\n+\n+**关键原则**\n+\n+- **SOT（唯一事实来源）是 Prometheus `/api/v1/alerts` 的 firing 快照**。receiver 不推导额外状态。\n+- **resolved 的产生来自快照对账**：某个 alert 在 DB 里仍为 firing，但在当前快照中缺席，并在 grace 时间后复核仍缺席，才写 resolved。\n+- 所有写库均为 **幂等 upsert**（以 `id` 作为冲突键）。\n+\n+## 总体架构\n+\n+服务由三个长期运行的 pipeline 组成：\n+\n+- `prometheus-alert`：轮询 Prometheus 获取 firing 快照并对账写库。\n+- `notifier`：从 DB 读取未 finalized 的告警组，按路由生成飞书卡片并发送/更新。\n+- `watchdog`：监控 Prometheus 拉取是否连续成功，失败则触发自身的 watchdog 告警。\n+\n+```mermaid\n+flowchart LR\n+  P[Prometheus /api/v1/alerts] -->|轮询快照| R[prometheus-alert pipeline]\n+  R -->|upsert firing/resolved| DB[(alert_record)]\n+  DB -->|查询未 finalized| N[notifier pipeline]\n+  N -->|发送/更新卡片| F[Feishu 群聊]\n+  R --> W[watchdog pipeline]\n+  W -->|upsert watchdog alert| DB\n@@ -21 +39,13 @@ annotations:\n-and with the following labels:\n+## 数据模型\n+\n+### `alert_record`\n+\n+每条告警实例一行记录，核心字段：\n+\n+- `id`：由 labels 计算出的 fingerprint，作为全局唯一键。\n+- `labels`：原始 labels（含 `alertname`、`severity`、`env`、`prometheus` 等）。\n+- `status`：`firing` 或 `resolved`。只要 `status='firing'` 即视为 open。\n+- `start_time` / `end_time`：开始与结束时间。`end_time` 为 receiver 观测到缺席并复核通过的时刻。\n+- `group_name`：由关键 labels 计算的告警组键。\n+- `message_ids`：已发送到飞书的 route-message 映射，用于后续更新。\n+- `finalized`：告警组全 resolved 后置为 `true`，表示不再参与通知。\n@@ -23,3 +53,32 @@ and with the following labels:\n-```yaml\n-labels:\n-  severity: <unknown | info | warning | error | critical>\n+### `alert_receive_route`\n+\n+告警接收路由配置：\n+\n+- `chat_id`：飞书群聊 ID。\n+- `label_schema`：用于筛选告警的 JSON Schema。\n+- `urgent_on_severity` / `urgent_user_list` / `urgent_type`：满足条件时的加急策略。\n+- `enabled`：是否启用。\n+\n+## Prometheus 快照对账流程\n+\n+对应实现：`apps/alert-receiver/src/pipelines/prometheus-alert.ts`。\n+\n+1. **拉取 firing 快照**：通过 terminal 服务 `prometheus/alerts` 轮询 `/api/v1/alerts`，仅保留 `state='firing'` 的告警。\n+2. **查询 DB 当前 firing**：从 `alert_record` 中选出 `status='firing'` 且同一 `prometheus/env` 范围内的记录。\n+3. **计算缺席候选**：`missing = dbFiring - currentSnapshot`。\n+4. **防抖复核**：对每个 `missing.id` 等待 `ALERT_RESOLVE_GRACE_MS`，到期后再次检查当前快照，若仍缺席则确认为 resolved。\n+5. **写库**：\n+   - 当前快照全量 upsert 为 `firing`。\n+   - 复核通过的缺席候选 upsert 为 `resolved` 并填充 `end_time`。\n+\n+```mermaid\n+flowchart TD\n+  A[定时轮询] --> B[获取 firing 快照]\n+  B --> C[查询 DB firing 记录]\n+  C --> D[缺席候选 = DB - 快照]\n+  B --> E[快照 upsert firing]\n+  D --> F[按 id 分组]\n+  F --> G[等待 grace]\n+  G --> H{最新快照仍缺席?}\n+  H -- 否 --> I[忽略]\n+  H -- 是 --> J[upsert resolved + end_time]\n@@ -28,32 +87,29 @@ labels:\n-it is worth noting that the difference between `summary` and `description` is that `summary` is a short description of what the alert is about, while `description` has more details of what's happening right now, usually with labels detailing which specific time series is firing the alert.\n-\n-## Alert Notification\n-\n-alerts are sent from prometheus alertmanager to an app `alert-receiver` via webhook.\n-\n-as alertmanager's [documentation](https://prometheus.io/docs/alerting/latest/configuration/#webhook_config) states, the messages posted from alertmanager are complied with the following schema:\n-\n-```json\n-{\n-  \"version\": \"4\",\n-  \"groupKey\": <string>,              // key identifying the group of alerts (e.g. to deduplicate)\n-  \"truncatedAlerts\": <int>,          // how many alerts have been truncated due to \"max_alerts\"\n-  \"status\": \"<resolved|firing>\",\n-  \"receiver\": <string>,\n-  \"groupLabels\": <object>,\n-  \"commonLabels\": <object>,\n-  \"commonAnnotations\": <object>,\n-  \"externalURL\": <string>,           // backlink to the Alertmanager.\n-  \"alerts\": [\n-    {\n-      \"status\": \"<resolved|firing>\",\n-      \"labels\": <object>,\n-      \"annotations\": <object>,\n-      \"startsAt\": \"<rfc3339>\",\n-      \"endsAt\": \"<rfc3339>\",\n-      \"generatorURL\": <string>,      // identifies the entity that caused the alert\n-      \"fingerprint\": <string>        // fingerprint to identify the alert\n-    },\n-    ...\n-  ]\n-}\n+**一致性特性**\n+\n+- receiver 宕机期间不会产生 resolved；恢复后第一轮对账会补齐。\n+- grace 只用于防抖（避免短暂抖动误关），不会推导额外状态。\n+- DB 读失败时不会阻塞写入快照（仍会持续 upsert firing）。\n+\n+## 通知发送流程\n+\n+对应实现：`apps/alert-receiver/src/pipelines/notifier.ts`。\n+\n+1. 周期性查询 `alert_record` 中 `finalized=false` 的记录，按 `group_name` 聚合成告警组。\n+2. 为每个告警组：\n+   - 拉取启用的 `alert_receive_route`。\n+   - 依据 `label_schema` 过滤匹配的 alerts，计算组级 severity/status/version。\n+   - 根据 `message_ids` 判断是“发送新卡片”还是“更新已有卡片”。\n+3. 更新 `message_ids` 写回 DB；若组内无 firing，则置 `finalized=true` 并清空 message_ids。\n+4. 对仍 firing 的组按 severity 设定不同的重复更新间隔（防止卡片失活）。\n+\n+```mermaid\n+flowchart TD\n+  A[周期查询未 finalized alerts] --> B[按 group_name 聚合]\n+  B --> C[为每组加载 routes]\n+  C --> D[按 label_schema 匹配]\n+  D --> E[渲染飞书卡片]\n+  E --> F[发送/更新消息]\n+  F --> G[写回 message_ids]\n+  D --> H{组是否 finalized?}\n+  H -- 是 --> I[finalized=true]\n+  H -- 否 --> J[按 severity 定时重复更新]\n@@ -62 +118,32 @@ as alertmanager's [documentation](https://prometheus.io/docs/alerting/latest/con\n-note that the `alerts` field is an array of alerts, which means that alertmanager sends multiple alerts in one message grouped by the keys defined in its [configuration](https://prometheus.io/docs/alerting/latest/configuration/#route).\n+## Watchdog 流程\n+\n+对应实现：`apps/alert-receiver/src/pipelines/watchdog.ts`。\n+\n+- 若连续 60 秒没有 Prometheus 拉取成功信号，则产生 `PrometheusFetchWatchdog` firing。\n+- 一旦再次拉取成功，立即写 resolved。\n+- watchdog 同样写入 `alert_record`，与普通告警统一展示和通知。\n+\n+## 运行与配置\n+\n+**必要环境变量**\n+\n+- `ENV`：环境名（写入 labels/env）。\n+- `PROMETHEUS_NAME`：Prometheus 实例名（写入 labels/prometheus）。\n+\n+**可选环境变量**\n+\n+- `ALERT_RESOLVE_GRACE_MS`：缺席防抖时间，默认 `15000` 毫秒。\n+\n+**依赖的 terminal 服务**\n+\n+- `prometheus/alerts`：获取 Prometheus alerts 快照。\n+- `sql/*`：读写 `alert_record` 与 `alert_receive_route`。\n+- `Feishu/SendMessage`、`Feishu/UpdateMessage`：发送/更新飞书卡片。\n+\n+## 开发与测试\n+\n+在 `apps/alert-receiver` 下运行：\n+\n+```bash\n+npm run build\n+```\n@@ -64 +151 @@ note that the `alerts` field is an array of alerts, which means that alertmanage\n-here we suggest to use `alertname` as the group key, which means that alerts with the same `alertname` will be grouped together in one message to avoid message flooding.\n+包含 TypeScript 编译、Jest 测试与 API Extractor 校验。若 post-build 报 Node 版本范围错误，请切换到仓库支持的 Node 版本后重试。\n",
          "codeSnippets": []
        },
        {
          "additions": 29,
          "deletions": 1,
          "path": "apps/alert-receiver/src/feishu/render-alert-message-card.ts",
          "changeType": "modified",
          "patch": "commit 53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a\nAuthor: Siyuan Wang <c.one@thrimbda.com>\nDate:   Fri Dec 12 18:32:09 2025 +0800\n\n    feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)\n\ndiff --git a/apps/alert-receiver/src/feishu/render-alert-message-card.ts b/apps/alert-receiver/src/feishu/render-alert-message-card.ts\nindex 5328dc9ae..9c9539556 100644\n--- a/apps/alert-receiver/src/feishu/render-alert-message-card.ts\n+++ b/apps/alert-receiver/src/feishu/render-alert-message-card.ts\n@@ -4,0 +5,25 @@ const MAX_ALERT_ITEMS = 30; // 避免超过 Feishu 2.0 卡片 200 元素上限\n+const MAX_LABEL_ITEMS = 8;\n+const MAX_LABEL_VALUE_LENGTH = 64;\n+\n+const formatLabels = (labels: Record<string, string>): string => {\n+  const entries = Object.entries(labels)\n+    .filter(([key, value]) => !!key && value !== undefined && value !== null)\n+    .map(([key, value]) => {\n+      const stringValue = String(value);\n+      return [\n+        String(key),\n+        stringValue.length > MAX_LABEL_VALUE_LENGTH\n+          ? `${stringValue.slice(0, MAX_LABEL_VALUE_LENGTH)}…`\n+          : stringValue,\n+      ] as const;\n+    })\n+    .sort(([a], [b]) => a.localeCompare(b));\n+\n+  if (entries.length === 0) return '';\n+\n+  const visible = entries.slice(0, MAX_LABEL_ITEMS);\n+  const hiddenCount = Math.max(entries.length - visible.length, 0);\n+  const content = visible.map(([key, value]) => `\\`${key}=${value}\\``).join(' ');\n+\n+  return hiddenCount > 0 ? `${content} …(+${hiddenCount})` : content;\n+};\n@@ -21,0 +47 @@ export const renderAlertMessageCard = (group: IAlertGroup) => {\n+    const labelsText = formatLabels(alert.labels);\n@@ -24 +50,3 @@ export const renderAlertMessageCard = (group: IAlertGroup) => {\n-      content: `${prefix} ${alert.start_time} → ${endTime}\\n${summary}`,\n+      content: `**${prefix}** ${alert.start_time} → ${endTime}\\n\\n${summary}${\n+        labelsText ? `\\n\\n${labelsText}` : ''\n+      }`,\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "MAX_LABEL_ITEMS",
              "code": "const MAX_LABEL_ITEMS = 8;",
              "lineStart": 5,
              "lineEnd": 5
            },
            {
              "type": "function",
              "name": "MAX_LABEL_VALUE_LENGTH",
              "code": "const MAX_LABEL_VALUE_LENGTH = 64;\n",
              "lineStart": 6,
              "lineEnd": 7
            },
            {
              "type": "function",
              "name": "formatLabels",
              "code": "const formatLabels = (labels: Record<string, string>): string => {",
              "lineStart": 8,
              "lineEnd": 8
            },
            {
              "type": "function",
              "name": "entries",
              "code": "const entries = Object.entries(labels)\n  .filter(([key, value]) => !!key && value !== undefined && value !== null)\n  .map(([key, value]) => {",
              "lineStart": 9,
              "lineEnd": 11
            },
            {
              "type": "function",
              "name": "stringValue",
              "code": "    const stringValue = String(value);\n    return [\n      String(key),\n      stringValue.length > MAX_LABEL_VALUE_LENGTH\n        ? `${stringValue.slice(0, MAX_LABEL_VALUE_LENGTH)}…`\n        : stringValue,\n    ] as const;\n  })\n  .sort(([a], [b]) => a.localeCompare(b));\n\nif (entries.length === 0) return '';\n",
              "lineStart": 12,
              "lineEnd": 23
            },
            {
              "type": "function",
              "name": "visible",
              "code": "const visible = entries.slice(0, MAX_LABEL_ITEMS);",
              "lineStart": 24,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "hiddenCount",
              "code": "const hiddenCount = Math.max(entries.length - visible.length, 0);",
              "lineStart": 25,
              "lineEnd": 25
            },
            {
              "type": "function",
              "name": "content",
              "code": "  const content = visible.map(([key, value]) => `\\`${key}=${value}\\``).join(' ');\n\n  return hiddenCount > 0 ? `${content} …(+${hiddenCount})` : content;\n};",
              "lineStart": 26,
              "lineEnd": 46
            },
            {
              "type": "function",
              "name": "labelsText",
              "code": "const labelsText = formatLabels(alert.labels);\n  content: `**${prefix}** ${alert.start_time} → ${endTime}\\n\\n${summary}${\n    labelsText ? `\\n\\n${labelsText}` : ''\n  }`,",
              "lineStart": 47,
              "lineEnd": 53
            }
          ]
        },
        {
          "additions": 29,
          "deletions": 1,
          "path": "apps/alert-receiver/src/pipelines/notifier.ts",
          "changeType": "modified",
          "patch": "commit 53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a\nAuthor: Siyuan Wang <c.one@thrimbda.com>\nDate:   Fri Dec 12 18:32:09 2025 +0800\n\n    feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)\n\ndiff --git a/apps/alert-receiver/src/pipelines/notifier.ts b/apps/alert-receiver/src/pipelines/notifier.ts\nindex aa73b7c57..aacbb169e 100644\n--- a/apps/alert-receiver/src/pipelines/notifier.ts\n+++ b/apps/alert-receiver/src/pipelines/notifier.ts\n@@ -32,0 +33,17 @@ const terminal = Terminal.fromNodeEnv();\n+// 同一个 group + route 的加急限频（仅内存，重启后重置）\n+// 默认 10 分钟一次，可通过环境变量调整\n+const URGENT_MIN_INTERVAL_MS = Number(process.env.ALERT_URGENT_MIN_INTERVAL_MS ?? 10 * 60_000);\n+// key: `${group_key}::${chat_id}` -> last urgent timestamp (ms)\n+const lastUrgentAtByGroupRoute = new Map<string, number>();\n+\n+const getGroupRouteKey = (groupKey: string, routeId: string) => `${groupKey}::${routeId}`;\n+\n+const allowUrgentForGroupRoute = (groupKey: string, routeId: string, now: number) => {\n+  const key = getGroupRouteKey(groupKey, routeId);\n+  const lastUrgentAt = lastUrgentAtByGroupRoute.get(key);\n+  // 最近一次加急未超过最小间隔，则本轮不加急\n+  if (lastUrgentAt !== undefined && now - lastUrgentAt < URGENT_MIN_INTERVAL_MS) {\n+    return false;\n+  }\n+  return true;\n+};\n@@ -260 +277,7 @@ const sendOrUpdateMessage = async (\n-  const urgentPayload = makeUrgentPayload(route, routeGroup.severity);\n+  const now = Date.now();\n+  // 先按路由/严重性判定是否“想要加急”\n+  const wantedUrgentPayload = makeUrgentPayload(route, routeGroup.severity);\n+  // 再按 group_key + chat_id 做限频，决定本轮是否真正带 urgent\n+  const urgentAllowed =\n+    wantedUrgentPayload && allowUrgentForGroupRoute(routeGroup.group_key, route.chat_id, now);\n+  const urgentPayload = urgentAllowed ? wantedUrgentPayload : undefined;\n@@ -293,0 +317,5 @@ const sendOrUpdateMessage = async (\n+\n+  // 只有当本次确实带了加急并成功发送/更新后，才写入冷却时间\n+  if (urgentPayload) {\n+    lastUrgentAtByGroupRoute.set(getGroupRouteKey(routeGroup.group_key, route.chat_id), now);\n+  }\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "URGENT_MIN_INTERVAL_MS",
              "code": "const URGENT_MIN_INTERVAL_MS = Number(process.env.ALERT_URGENT_MIN_INTERVAL_MS ?? 10 * 60_000);\n// key: `${group_key}::${chat_id}` -> last urgent timestamp (ms)",
              "lineStart": 35,
              "lineEnd": 36
            },
            {
              "type": "function",
              "name": "lastUrgentAtByGroupRoute",
              "code": "const lastUrgentAtByGroupRoute = new Map<string, number>();\n",
              "lineStart": 37,
              "lineEnd": 38
            },
            {
              "type": "function",
              "name": "getGroupRouteKey",
              "code": "const getGroupRouteKey = (groupKey: string, routeId: string) => `${groupKey}::${routeId}`;\n",
              "lineStart": 39,
              "lineEnd": 40
            },
            {
              "type": "function",
              "name": "allowUrgentForGroupRoute",
              "code": "const allowUrgentForGroupRoute = (groupKey: string, routeId: string, now: number) => {",
              "lineStart": 41,
              "lineEnd": 41
            },
            {
              "type": "function",
              "name": "key",
              "code": "const key = getGroupRouteKey(groupKey, routeId);",
              "lineStart": 42,
              "lineEnd": 42
            },
            {
              "type": "function",
              "name": "lastUrgentAt",
              "code": "  const lastUrgentAt = lastUrgentAtByGroupRoute.get(key);\n  // 最近一次加急未超过最小间隔，则本轮不加急\n  if (lastUrgentAt !== undefined && now - lastUrgentAt < URGENT_MIN_INTERVAL_MS) {\n    return false;\n  }\n  return true;\n};",
              "lineStart": 43,
              "lineEnd": 276
            },
            {
              "type": "function",
              "name": "now",
              "code": "const now = Date.now();\n// 先按路由/严重性判定是否“想要加急”",
              "lineStart": 277,
              "lineEnd": 278
            },
            {
              "type": "function",
              "name": "wantedUrgentPayload",
              "code": "const wantedUrgentPayload = makeUrgentPayload(route, routeGroup.severity);\n// 再按 group_key + chat_id 做限频，决定本轮是否真正带 urgent",
              "lineStart": 279,
              "lineEnd": 280
            },
            {
              "type": "function",
              "name": "urgentAllowed",
              "code": "const urgentAllowed =\n  wantedUrgentPayload && allowUrgentForGroupRoute(routeGroup.group_key, route.chat_id, now);",
              "lineStart": 281,
              "lineEnd": 282
            },
            {
              "type": "function",
              "name": "urgentPayload",
              "code": "const urgentPayload = urgentAllowed ? wantedUrgentPayload : undefined;\n\n// 只有当本次确实带了加急并成功发送/更新后，才写入冷却时间\nif (urgentPayload) {\n  lastUrgentAtByGroupRoute.set(getGroupRouteKey(routeGroup.group_key, route.chat_id), now);\n}",
              "lineStart": 283,
              "lineEnd": 322
            }
          ]
        },
        {
          "additions": 62,
          "deletions": 36,
          "path": "apps/alert-receiver/src/pipelines/prometheus-alert.ts",
          "changeType": "modified",
          "patch": "commit 53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a\nAuthor: Siyuan Wang <c.one@thrimbda.com>\nDate:   Fri Dec 12 18:32:09 2025 +0800\n\n    feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)\n\ndiff --git a/apps/alert-receiver/src/pipelines/prometheus-alert.ts b/apps/alert-receiver/src/pipelines/prometheus-alert.ts\nindex b23fc993b..8f8363af0 100644\n--- a/apps/alert-receiver/src/pipelines/prometheus-alert.ts\n+++ b/apps/alert-receiver/src/pipelines/prometheus-alert.ts\n@@ -2,2 +2,2 @@ import { Terminal } from '@yuants/protocol';\n-import { writeToSQL } from '@yuants/sql';\n-import { formatTime, listWatchEvent } from '@yuants/utils';\n+import { requestSQL, writeToSQL } from '@yuants/sql';\n+import { batchGroupBy, formatTime } from '@yuants/utils';\n@@ -4,0 +5 @@ import {\n+  catchError,\n@@ -6 +7 @@ import {\n-  EMPTY,\n+  exhaustMap,\n@@ -14,0 +16 @@ import {\n+  share,\n@@ -120,32 +122,25 @@ const activeAlertRecords$ = defer(() =>\n-const alertRecordEvents$ = activeAlertRecords$.pipe(\n-  listWatchEvent(\n-    (record) => record.id,\n-    (a, b) => a.id === b.id && a.current_value === b.current_value,\n-  ),\n-  mergeMap((events) =>\n-    from(events).pipe(\n-      mergeMap(([oldRecord, newRecord]) => {\n-        if (newRecord && oldRecord) {\n-          return of({\n-            ...oldRecord,\n-            current_value: newRecord.current_value,\n-            description: newRecord.description,\n-            summary: newRecord.summary,\n-          });\n-        }\n-        if (newRecord) {\n-          return of(newRecord);\n-        }\n-        if (oldRecord) {\n-          return timer(RESOLVE_GRACE_MS).pipe(\n-            withLatestFrom(activeAlertRecords$),\n-            filter(([, current]) => !current.some((record) => record.id === oldRecord.id)),\n-            map(() => ({\n-              ...oldRecord,\n-              status: 'resolved',\n-              end_time: formatTime(Date.now()),\n-              finalized: false,\n-            })),\n-          );\n-        }\n-        return EMPTY;\n+const reconciliation$ = activeAlertRecords$.pipe(\n+  exhaustMap((currentRecords) => {\n+    const sql = `\n+      SELECT\n+        id,\n+        alert_name,\n+        current_value,\n+        status,\n+        severity,\n+        summary,\n+        description,\n+        env,\n+        runbook_url,\n+        group_name,\n+        labels,\n+        finalized,\n+        start_time,\n+        end_time\n+      FROM alert_record\n+      WHERE status = 'firing'\n+    `;\n+    return defer(() => requestSQL<IAlertRecord[]>(terminal, sql)).pipe(\n+      catchError((err) => {\n+        console.error(formatTime(Date.now()), 'FetchFiringAlertRecordsFailed', err);\n+        return of([] as IAlertRecord[]);\n@@ -152,0 +148,31 @@ const alertRecordEvents$ = activeAlertRecords$.pipe(\n+      map((dbFiringRecords) => ({ currentRecords, dbFiringRecords })),\n+    );\n+  }),\n+  share(),\n+);\n+\n+const firingUpserts$ = reconciliation$.pipe(mergeMap(({ currentRecords }) => from(currentRecords)));\n+\n+const missingCandidates$ = reconciliation$.pipe(\n+  mergeMap(({ currentRecords, dbFiringRecords }) => {\n+    const currentIds = new Set(currentRecords.map((record) => record.id));\n+    return of(dbFiringRecords.filter((record) => !currentIds.has(record.id)));\n+  }),\n+);\n+\n+const resolvedUpserts$ = missingCandidates$.pipe(\n+  batchGroupBy((record) => record.id),\n+  mergeMap((group$) =>\n+    group$.pipe(\n+      exhaustMap((record) =>\n+        timer(RESOLVE_GRACE_MS).pipe(\n+          withLatestFrom(activeAlertRecords$),\n+          filter(([, latest]) => !latest.some((r) => r.id === record.id)),\n+          map(() => ({\n+            ...record,\n+            status: 'resolved',\n+            end_time: formatTime(Date.now()),\n+            finalized: false,\n+          })),\n+        ),\n+      ),\n@@ -157 +183 @@ const alertRecordEvents$ = activeAlertRecords$.pipe(\n-merge(alertRecordEvents$, watchdogRecordSubject)\n+merge(firingUpserts$, resolvedUpserts$, watchdogRecordSubject)\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "reconciliation",
              "code": "const reconciliation$ = activeAlertRecords$.pipe(\n  exhaustMap((currentRecords) => {",
              "lineStart": 122,
              "lineEnd": 123
            },
            {
              "type": "function",
              "name": "sql",
              "code": "const sql = `\n  SELECT\n    id,\n    alert_name,\n    current_value,\n    status,\n    severity,\n    summary,\n    description,\n    env,\n    runbook_url,\n    group_name,\n    labels,\n    finalized,\n    start_time,",
              "lineStart": 124,
              "lineEnd": 153
            },
            {
              "type": "function",
              "name": "firingUpserts",
              "code": "const firingUpserts$ = reconciliation$.pipe(mergeMap(({ currentRecords }) => from(currentRecords)));\n",
              "lineStart": 154,
              "lineEnd": 155
            },
            {
              "type": "function",
              "name": "missingCandidates",
              "code": "const missingCandidates$ = reconciliation$.pipe(\n  mergeMap(({ currentRecords, dbFiringRecords }) => {",
              "lineStart": 156,
              "lineEnd": 157
            },
            {
              "type": "function",
              "name": "currentIds",
              "code": "    const currentIds = new Set(currentRecords.map((record) => record.id));\n    return of(dbFiringRecords.filter((record) => !currentIds.has(record.id)));\n  }),\n);\n",
              "lineStart": 158,
              "lineEnd": 162
            },
            {
              "type": "function",
              "name": "resolvedUpserts",
              "code": "const resolvedUpserts$ = missingCandidates$.pipe(\n  batchGroupBy((record) => record.id),\n  mergeMap((group$) =>\n    group$.pipe(\n      exhaustMap((record) =>\n        timer(RESOLVE_GRACE_MS).pipe(\n          withLatestFrom(activeAlertRecords$),\n          filter(([, latest]) => !latest.some((r) => r.id === record.id)),\n          map(() => ({\n            ...record,\n            status: 'resolved',\n            end_time: formatTime(Date.now()),\n            finalized: false,\n          })),\n        ),",
              "lineStart": 163,
              "lineEnd": 184
            }
          ]
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json",
          "changeType": "added",
          "patch": "commit 53e361eb4d0d07a93e2bb3f5ea62e743f0393a5a\nAuthor: Siyuan Wang <c.one@thrimbda.com>\nDate:   Fri Dec 12 18:32:09 2025 +0800\n\n    feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑 (#2310)\n\ndiff --git a/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json b/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json\nnew file mode 100644\nindex 000000000..ed18ec7da\n--- /dev/null\n+++ b/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/app-alert-receiver\",\n+      \"comment\": \"feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑\",\n+      \"type\": \"patch\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/app-alert-receiver\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        }
      ]
    },
    {
      "hash": "037ce992ac73016997f1ceadb9c955e8fb97fefb",
      "short": "037ce992a",
      "author": "humblelittlec1[bot]",
      "email": "208195530+humblelittlec1[bot]@users.noreply.github.com",
      "authoredAt": "2025-12-12 18:33:14 +0800",
      "subject": "chore: bump version (#2311)",
      "conventionalCommit": {
        "type": "chore",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 17,
          "deletions": 0,
          "path": "apps/alert-receiver/CHANGELOG.json",
          "changeType": "added",
          "patch": "commit 037ce992ac73016997f1ceadb9c955e8fb97fefb\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 18:33:14 2025 +0800\n\n    chore: bump version (#2311)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/CHANGELOG.json b/apps/alert-receiver/CHANGELOG.json\nindex d51d0a1c0..c3d577597 100644\n--- a/apps/alert-receiver/CHANGELOG.json\n+++ b/apps/alert-receiver/CHANGELOG.json\n@@ -3,0 +4,17 @@\n+    {\n+      \"version\": \"0.5.15\",\n+      \"tag\": \"@yuants/app-alert-receiver_v0.5.15\",\n+      \"date\": \"Fri, 12 Dec 2025 10:32:49 GMT\",\n+      \"comments\": {\n+        \"patch\": [\n+          {\n+            \"comment\": \"feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑\"\n+          }\n+        ],\n+        \"none\": [\n+          {\n+            \"comment\": \"Bump Version\"\n+          }\n+        ]\n+      }\n+    },\n",
          "codeSnippets": []
        },
        {
          "additions": 8,
          "deletions": 1,
          "path": "apps/alert-receiver/CHANGELOG.md",
          "changeType": "modified",
          "patch": "commit 037ce992ac73016997f1ceadb9c955e8fb97fefb\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 18:33:14 2025 +0800\n\n    chore: bump version (#2311)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/CHANGELOG.md b/apps/alert-receiver/CHANGELOG.md\nindex 4b392f4b2..24296ed39 100644\n--- a/apps/alert-receiver/CHANGELOG.md\n+++ b/apps/alert-receiver/CHANGELOG.md\n@@ -3 +3,8 @@\n-This log was last generated on Fri, 12 Dec 2025 09:48:48 GMT and should not be manually modified.\n+This log was last generated on Fri, 12 Dec 2025 10:32:49 GMT and should not be manually modified.\n+\n+## 0.5.15\n+Fri, 12 Dec 2025 10:32:49 GMT\n+\n+### Patches\n+\n+- feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑\n",
          "codeSnippets": []
        },
        {
          "additions": 1,
          "deletions": 1,
          "path": "apps/alert-receiver/package.json",
          "changeType": "modified",
          "patch": "commit 037ce992ac73016997f1ceadb9c955e8fb97fefb\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 18:33:14 2025 +0800\n\n    chore: bump version (#2311)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/apps/alert-receiver/package.json b/apps/alert-receiver/package.json\nindex 5a9ece7fc..08dd044b1 100644\n--- a/apps/alert-receiver/package.json\n+++ b/apps/alert-receiver/package.json\n@@ -3 +3 @@\n-  \"version\": \"0.5.14\",\n+  \"version\": \"0.5.15\",\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 10,
          "path": "common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json",
          "changeType": "deleted",
          "patch": "commit 037ce992ac73016997f1ceadb9c955e8fb97fefb\nAuthor: humblelittlec1[bot] <208195530+humblelittlec1[bot]@users.noreply.github.com>\nDate:   Fri Dec 12 18:33:14 2025 +0800\n\n    chore: bump version (#2311)\n    \n    Co-authored-by: github-actions[bot] <41898282+github-actions[bot]@users.noreply.github.com>\n\ndiff --git a/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json b/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json\ndeleted file mode 100644\nindex ed18ec7da..000000000\n--- a/common/changes/@yuants/app-alert-receiver/2025-12-12-08-53.json\n+++ /dev/null\n@@ -1,10 +0,0 @@\n-{\n-  \"changes\": [\n-    {\n-      \"packageName\": \"@yuants/app-alert-receiver\",\n-      \"comment\": \"feat: 重构告警记录对账流程，优化数据库查询与状态更新逻辑\",\n-      \"type\": \"patch\"\n-    }\n-  ],\n-  \"packageName\": \"@yuants/app-alert-receiver\"\n-}\n\\ No newline at end of file\n",
          "codeSnippets": []
        },
        {
          "additions": 0,
          "deletions": 0,
          "path": "common/changes/@yuants/app-alert-receiver/{main_2025-12-12-09-48.json => main_2025-12-12-10-32.json}",
          "changeType": "renamed",
          "patch": "",
          "codeSnippets": []
        }
      ]
    },
    {
      "hash": "a2c68d358a786df00ceb5efeb3f8325fa40549a1",
      "short": "a2c68d358",
      "author": "CZ",
      "email": "zheng.chen@no-trade-no.life",
      "authoredAt": "2025-12-12 19:43:15 +0800",
      "subject": "fix: improve listAllCredentials format and update position settlement interval logic (#2312)",
      "conventionalCommit": {
        "type": "fix",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 30,
          "deletions": 4,
          "path": "apps/virtual-exchange/src/credential.ts",
          "changeType": "modified",
          "patch": "commit a2c68d358a786df00ceb5efeb3f8325fa40549a1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 19:43:15 2025 +0800\n\n    fix: improve listAllCredentials format and update position settlement interval logic (#2312)\n\ndiff --git a/apps/virtual-exchange/src/credential.ts b/apps/virtual-exchange/src/credential.ts\nindex edf0901b4..7ff9cfe06 100644\n--- a/apps/virtual-exchange/src/credential.ts\n+++ b/apps/virtual-exchange/src/credential.ts\n@@ -50 +50,28 @@ const listAllCredentials = async () => {\n-  return Promise.allSettled(secrets.map((secret) => getCredentialBySecretId(secret.sign)));\n+  const results = await Promise.allSettled(secrets.map((secret) => getCredentialBySecretId(secret.sign)));\n+  return results.map(\n+    (\n+      result,\n+      index,\n+    ): {\n+      sign: string;\n+      credential: IExchangeCredential | null;\n+      credentialId: string | null;\n+      error: any;\n+    } => {\n+      if (result.status === 'fulfilled') {\n+        return {\n+          sign: secrets[index].sign,\n+          credential: result.value.credential,\n+          credentialId: result.value.credentialId,\n+          error: null,\n+        };\n+      } else {\n+        return {\n+          sign: secrets[index].sign,\n+          credential: null,\n+          credentialId: null,\n+          error: `${result.reason}`,\n+        };\n+      }\n+    },\n+  );\n@@ -86,3 +113,2 @@ export const validCredentials$ = defer(() => listAllCredentials()).pipe(\n-      if (xx.status !== 'fulfilled') continue;\n-      if (xx.value.credentialId && xx.value.credential) {\n-        map.set(xx.value.credentialId, xx.value.credential);\n+      if (xx.credentialId && xx.credential) {\n+        map.set(xx.credentialId, xx.credential);\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "results",
              "code": "const results = await Promise.allSettled(secrets.map((secret) => getCredentialBySecretId(secret.sign)));\nreturn results.map(\n  (\n    result,\n    index,\n  ): {\n    sign: string;\n    credential: IExchangeCredential | null;\n    credentialId: string | null;\n    error: any;\n  } => {\n    if (result.status === 'fulfilled') {\n      return {\n        sign: secrets[index].sign,\n        credential: result.value.credential,",
              "lineStart": 50,
              "lineEnd": 115
            }
          ]
        },
        {
          "additions": 12,
          "deletions": 5,
          "path": "apps/virtual-exchange/src/position.ts",
          "changeType": "modified",
          "patch": "commit a2c68d358a786df00ceb5efeb3f8325fa40549a1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 19:43:15 2025 +0800\n\n    fix: improve listAllCredentials format and update position settlement interval logic (#2312)\n\ndiff --git a/apps/virtual-exchange/src/position.ts b/apps/virtual-exchange/src/position.ts\nindex 41aba2456..cd262867a 100644\n--- a/apps/virtual-exchange/src/position.ts\n+++ b/apps/virtual-exchange/src/position.ts\n@@ -69,0 +70 @@ export const polyfillPosition = async (positions: IPosition[]): Promise<IPositio\n+        const nextSettledAt = new Date(quote.interest_rate_next_settled_at).getTime();\n@@ -71 +72,6 @@ export const polyfillPosition = async (positions: IPosition[]): Promise<IPositio\n-        pos.settlement_scheduled_at = new Date(quote.interest_rate_next_settled_at).getTime();\n+        pos.settlement_scheduled_at = nextSettledAt;\n+        // 优先使用下一个结算时间推算结算间隔\n+        if (interestRateInterval !== undefined) {\n+          const interval = nextSettledAt - interestRateInterval.prev;\n+          pos.settlement_interval = interval;\n+        }\n@@ -78,0 +85,5 @@ export const polyfillPosition = async (positions: IPosition[]): Promise<IPositio\n+      // 如果还没有结算间隔，则使用 interest rate 表的时间间隔作为结算间隔\n+      if (pos.settlement_interval === undefined && interestRateInterval) {\n+        pos.settlement_interval = interestRateInterval.interval;\n+      }\n+\n@@ -90,4 +100,0 @@ export const polyfillPosition = async (positions: IPosition[]): Promise<IPositio\n-\n-    if (interestRateInterval) {\n-      pos.settlement_interval = interestRateInterval.interval;\n-    }\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "nextSettledAt",
              "code": "const nextSettledAt = new Date(quote.interest_rate_next_settled_at).getTime();\npos.settlement_scheduled_at = nextSettledAt;\n// 优先使用下一个结算时间推算结算间隔\nif (interestRateInterval !== undefined) {",
              "lineStart": 70,
              "lineEnd": 74
            },
            {
              "type": "function",
              "name": "interval",
              "code": "    const interval = nextSettledAt - interestRateInterval.prev;\n    pos.settlement_interval = interval;\n  }\n// 如果还没有结算间隔，则使用 interest rate 表的时间间隔作为结算间隔\nif (pos.settlement_interval === undefined && interestRateInterval) {\n  pos.settlement_interval = interestRateInterval.interval;\n}\n",
              "lineStart": 75,
              "lineEnd": 100
            }
          ]
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/app-virtual-exchange/2025-12-12-11-41.json",
          "changeType": "added",
          "patch": "commit a2c68d358a786df00ceb5efeb3f8325fa40549a1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 19:43:15 2025 +0800\n\n    fix: improve listAllCredentials format and update position settlement interval logic (#2312)\n\ndiff --git a/common/changes/@yuants/app-virtual-exchange/2025-12-12-11-41.json b/common/changes/@yuants/app-virtual-exchange/2025-12-12-11-41.json\nnew file mode 100644\nindex 000000000..cad767336\n--- /dev/null\n+++ b/common/changes/@yuants/app-virtual-exchange/2025-12-12-11-41.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/app-virtual-exchange\",\n+      \"comment\": \"fix listAllCredential format and fix position settlement_interval assignment\",\n+      \"type\": \"patch\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/app-virtual-exchange\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        }
      ]
    },
    {
      "hash": "fdd39ba65bcba466d70ba66c6e295596a85ba3b1",
      "short": "fdd39ba65",
      "author": "CZ",
      "email": "zheng.chen@no-trade-no.life",
      "authoredAt": "2025-12-12 22:26:23 +0800",
      "subject": "feat: implement quote service with state management and update actions (#2313)",
      "conventionalCommit": {
        "type": "feat",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 1,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/index.ts",
          "changeType": "added",
          "patch": "commit fdd39ba65bcba466d70ba66c6e295596a85ba3b1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 22:26:23 2025 +0800\n\n    feat: implement quote service with state management and update actions (#2313)\n\ndiff --git a/apps/virtual-exchange/src/index.ts b/apps/virtual-exchange/src/index.ts\nindex 8d7f19a07..67e1963fa 100644\n--- a/apps/virtual-exchange/src/index.ts\n+++ b/apps/virtual-exchange/src/index.ts\n@@ -4,0 +5 @@ import './product-collector';\n+import './quote/service';\n",
          "codeSnippets": []
        },
        {
          "additions": 59,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/service.ts",
          "changeType": "added",
          "patch": "commit fdd39ba65bcba466d70ba66c6e295596a85ba3b1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 22:26:23 2025 +0800\n\n    feat: implement quote service with state management and update actions (#2313)\n\ndiff --git a/apps/virtual-exchange/src/quote/service.ts b/apps/virtual-exchange/src/quote/service.ts\nnew file mode 100644\nindex 000000000..6464c8ead\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/service.ts\n@@ -0,0 +1,59 @@\n+import { Terminal } from '@yuants/protocol';\n+import { createQuoteState } from './state';\n+import { IQuoteKey, IQuoteUpdateAction } from './types';\n+\n+const terminal = Terminal.fromNodeEnv();\n+\n+const quoteState = createQuoteState();\n+\n+terminal.server.provideService<IQuoteUpdateAction>('VEX/UpdateQuotes', {}, async (msg) => {\n+  quoteState.update(msg.req);\n+  return { res: { code: 0, message: 'OK' } };\n+});\n+\n+terminal.server.provideService<{}, IQuoteUpdateAction>('VEX/DumpQuoteState', {}, async (msg) => {\n+  return { res: { code: 0, message: 'OK', data: quoteState.dumpAsObject() } };\n+});\n+\n+terminal.server.provideService<\n+  { product_ids: string[]; fields: IQuoteKey[]; updated_at: number },\n+  IQuoteUpdateAction\n+>(\n+  'VEX/QueryQuotes',\n+  {\n+    type: 'object',\n+    required: ['product_ids', 'fields', 'updated_at'],\n+    properties: {\n+      product_ids: {\n+        type: 'array',\n+        items: { type: 'string' },\n+      },\n+      fields: {\n+        type: 'array',\n+        items: { type: 'string' },\n+      },\n+      updated_at: { type: 'number' },\n+    },\n+  },\n+  async (msg) => {\n+    const { product_ids, fields, updated_at } = msg.req;\n+    // 分析缓存缺失的字段\n+    const cacheMissed: Array<{ product_id: string; field: IQuoteKey }> = [];\n+    for (const product_id of product_ids) {\n+      for (const field of fields) {\n+        const tuple = quoteState.getValueTuple(product_id, field);\n+        if (tuple === undefined || tuple[1] < updated_at) {\n+          cacheMissed.push({ product_id, field });\n+        }\n+      }\n+    }\n+    // TODO: 集中规划需要发送的查询请求，并更新到状态中\n+    // 注意需要限制在途请求数量和复用在途请求的结果，以免过载和浪费资源\n+    // await Promise.all;\n+\n+    // 从状态中获取数据返回\n+    const data = quoteState.filter(product_ids, fields, updated_at);\n+\n+    return { res: { code: 0, message: 'OK', data } };\n+  },\n+);\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "terminal",
              "code": "const terminal = Terminal.fromNodeEnv();\n",
              "lineStart": 5,
              "lineEnd": 6
            },
            {
              "type": "function",
              "name": "quoteState",
              "code": "const quoteState = createQuoteState();\n\nterminal.server.provideService<IQuoteUpdateAction>('VEX/UpdateQuotes', {}, async (msg) => {\n  quoteState.update(msg.req);\n  return { res: { code: 0, message: 'OK' } };\n});\n\nterminal.server.provideService<{}, IQuoteUpdateAction>('VEX/DumpQuoteState', {}, async (msg) => {\n  return { res: { code: 0, message: 'OK', data: quoteState.dumpAsObject() } };\n});\n\nterminal.server.provideService<\n  { product_ids: string[]; fields: IQuoteKey[]; updated_at: number },\n  IQuoteUpdateAction\n>(",
              "lineStart": 7,
              "lineEnd": 40
            },
            {
              "type": "function",
              "name": "cacheMissed",
              "code": "const cacheMissed: Array<{ product_id: string; field: IQuoteKey }> = [];",
              "lineStart": 41,
              "lineEnd": 41
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of product_ids) {",
              "lineStart": 42,
              "lineEnd": 42
            },
            {
              "type": "function",
              "name": "field",
              "code": "for (const field of fields) {",
              "lineStart": 43,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "tuple",
              "code": "    const tuple = quoteState.getValueTuple(product_id, field);\n    if (tuple === undefined || tuple[1] < updated_at) {\n      cacheMissed.push({ product_id, field });\n    }\n  }\n}\n// TODO: 集中规划需要发送的查询请求，并更新到状态中\n// 注意需要限制在途请求数量和复用在途请求的结果，以免过载和浪费资源\n// await Promise.all;\n\n// 从状态中获取数据返回",
              "lineStart": 44,
              "lineEnd": 54
            },
            {
              "type": "function",
              "name": "data",
              "code": "    const data = quoteState.filter(product_ids, fields, updated_at);\n\n    return { res: { code: 0, message: 'OK', data } };\n  },\n);",
              "lineStart": 55,
              "lineEnd": 60
            }
          ]
        },
        {
          "additions": 116,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/state.ts",
          "changeType": "added",
          "patch": "commit fdd39ba65bcba466d70ba66c6e295596a85ba3b1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 22:26:23 2025 +0800\n\n    feat: implement quote service with state management and update actions (#2313)\n\ndiff --git a/apps/virtual-exchange/src/quote/state.ts b/apps/virtual-exchange/src/quote/state.ts\nnew file mode 100644\nindex 000000000..fdfe73151\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/state.ts\n@@ -0,0 +1,116 @@\n+import { newError } from '@yuants/utils';\n+import { IQuoteKey, IQuoteUpdateAction } from './types';\n+\n+// TRICK: 固定字段顺序，方便计算偏移量\n+const FIELDS = ((x: { [key in IQuoteKey]: number }) => Object.keys(x).sort() as IQuoteKey[])({\n+  // TS TRICK: 强制运行时数组具有 IQuoteKey 的所有字段。不重不漏，味道真是好极了\n+  last_price: 0,\n+  ask_price: 0,\n+  ask_volume: 0,\n+  bid_volume: 0,\n+  bid_price: 0,\n+  interest_rate_short: 0,\n+  open_interest: 0,\n+  interest_rate_prev_settled_at: 0,\n+  interest_rate_next_settled_at: 0,\n+  interest_rate_long: 0,\n+});\n+\n+const FIELD_COUNT = FIELDS.length;\n+const mapFieldNameToOffset = Object.fromEntries(FIELDS.map((field, index) => [field, index * 2]));\n+\n+/**\n+ * 高效的行情状态管理器\n+ * 内部使用扁平化数组存储数据，避免内存碎片化和过多的 Map/对象开销\n+ * 提供高效的读写接口，支持按需更新和查询\n+ */\n+export const createQuoteState = () => {\n+  // 内部数据结构的设计需要考虑高效的读写性能，防止内存碎片化\n+  const data: (string | number)[] = [];\n+  const products: string[] = [];\n+  const mapProductIdToIndex = new Map<string, number>();\n+  // 0~20 (10 fields * 2 (value, updated_at))\n+  const getFieldOffset = (product_id: string, field: string): number => {\n+    let baseIndex = mapProductIdToIndex.get(product_id);\n+    if (baseIndex === undefined) {\n+      baseIndex = mapProductIdToIndex.size * FIELD_COUNT * 2;\n+      products.push(product_id);\n+      mapProductIdToIndex.set(product_id, baseIndex);\n+    }\n+    const fieldOffset = mapFieldNameToOffset[field];\n+    if (fieldOffset === undefined) throw newError('INVALID_FIELD_NAME', { field, available_fields: FIELDS });\n+    return baseIndex + fieldOffset;\n+  };\n+\n+  const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {\n+    const offset = getFieldOffset(product_id, field);\n+    const value = data[offset] as string;\n+    if (value === undefined) return undefined;\n+    const updated_at = data[offset + 1] as number;\n+    return [value, updated_at];\n+  };\n+\n+  const setValueTuple = (product_id: string, field: IQuoteKey, value: string, updated_at: number) => {\n+    const offset = getFieldOffset(product_id, field);\n+    data[offset] = value;\n+    data[offset + 1] = updated_at;\n+  };\n+\n+  const update = (action: IQuoteUpdateAction) => {\n+    for (const product_id in action) {\n+      const fields = action[product_id];\n+      for (const field_name in fields) {\n+        const field = field_name as IQuoteKey;\n+        const [value, updated_at] = fields[field]!;\n+        const oldTuple = getValueTuple(product_id, field);\n+        if (oldTuple === undefined || updated_at >= oldTuple[1]) {\n+          setValueTuple(product_id, field, value, updated_at);\n+        }\n+      }\n+    }\n+  };\n+\n+  const dumpAsObject = (): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    for (const product_id of products) {\n+      result[product_id] = {};\n+    }\n+    for (let i = 0; i < data.length; i += 2) {\n+      const value = data[i] as string;\n+      if (value === undefined) continue;\n+      const updated_at = data[i + 1] as number;\n+\n+      const productIndex = Math.floor(i / (FIELD_COUNT * 2));\n+      const product_id = products[productIndex];\n+\n+      const fieldIndex = (i % (FIELD_COUNT * 2)) / 2;\n+      const field_name = FIELDS[fieldIndex];\n+\n+      result[product_id][field_name] = [value, updated_at];\n+    }\n+    return result;\n+  };\n+\n+  /**\n+   * 过滤状态，返回指定 product_id 列表和字段列表中，且更新时间不早于指定时间的字段数据\n+   * @param product_ids - 需要过滤的 product_id 列表\n+   * @param fields - 需要过滤的字段列表\n+   * @param updated_at - 需要过滤的更新时间阈值 (仅返回更新时间不早于该值的字段)\n+   * @returns 过滤后的数据\n+   */\n+  const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    for (const product_id of product_ids) {\n+      result[product_id] = {};\n+      for (const field of fields) {\n+        const tuple = getValueTuple(product_id, field);\n+        if (tuple && tuple[1] >= updated_at) {\n+          result[product_id]![field] = tuple;\n+        }\n+      }\n+    }\n+    return result;\n+  };\n+\n+  return { update, dumpAsObject, getValueTuple, filter };\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "FIELDS",
              "code": "const FIELDS = ((x: { [key in IQuoteKey]: number }) => Object.keys(x).sort() as IQuoteKey[])({\n  // TS TRICK: 强制运行时数组具有 IQuoteKey 的所有字段。不重不漏，味道真是好极了\n  last_price: 0,\n  ask_price: 0,\n  ask_volume: 0,\n  bid_volume: 0,\n  bid_price: 0,\n  interest_rate_short: 0,\n  open_interest: 0,\n  interest_rate_prev_settled_at: 0,\n  interest_rate_next_settled_at: 0,\n  interest_rate_long: 0,\n});\n",
              "lineStart": 5,
              "lineEnd": 18
            },
            {
              "type": "function",
              "name": "FIELD_COUNT",
              "code": "const FIELD_COUNT = FIELDS.length;",
              "lineStart": 19,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "mapFieldNameToOffset",
              "code": "const mapFieldNameToOffset = Object.fromEntries(FIELDS.map((field, index) => [field, index * 2]));\n\n/**\n * 高效的行情状态管理器\n * 内部使用扁平化数组存储数据，避免内存碎片化和过多的 Map/对象开销\n * 提供高效的读写接口，支持按需更新和查询\n */",
              "lineStart": 20,
              "lineEnd": 26
            },
            {
              "type": "function",
              "name": "createQuoteState",
              "code": "export const createQuoteState = () => {\n  // 内部数据结构的设计需要考虑高效的读写性能，防止内存碎片化",
              "lineStart": 27,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data: (string | number)[] = [];",
              "lineStart": 29,
              "lineEnd": 29
            },
            {
              "type": "function",
              "name": "products",
              "code": "const products: string[] = [];",
              "lineStart": 30,
              "lineEnd": 30
            },
            {
              "type": "function",
              "name": "mapProductIdToIndex",
              "code": "const mapProductIdToIndex = new Map<string, number>();\n// 0~20 (10 fields * 2 (value, updated_at))",
              "lineStart": 31,
              "lineEnd": 32
            },
            {
              "type": "function",
              "name": "getFieldOffset",
              "code": "const getFieldOffset = (product_id: string, field: string): number => {",
              "lineStart": 33,
              "lineEnd": 33
            },
            {
              "type": "function",
              "name": "baseIndex",
              "code": "let baseIndex = mapProductIdToIndex.get(product_id);\nif (baseIndex === undefined) {\n  baseIndex = mapProductIdToIndex.size * FIELD_COUNT * 2;\n  products.push(product_id);\n  mapProductIdToIndex.set(product_id, baseIndex);\n}",
              "lineStart": 34,
              "lineEnd": 39
            },
            {
              "type": "function",
              "name": "fieldOffset",
              "code": "  const fieldOffset = mapFieldNameToOffset[field];\n  if (fieldOffset === undefined) throw newError('INVALID_FIELD_NAME', { field, available_fields: FIELDS });\n  return baseIndex + fieldOffset;\n};\n",
              "lineStart": 40,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "getValueTuple",
              "code": "const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {",
              "lineStart": 45,
              "lineEnd": 45
            },
            {
              "type": "function",
              "name": "offset",
              "code": "const offset = getFieldOffset(product_id, field);",
              "lineStart": 46,
              "lineEnd": 46
            },
            {
              "type": "function",
              "name": "value",
              "code": "const value = data[offset] as string;\nif (value === undefined) return undefined;",
              "lineStart": 47,
              "lineEnd": 48
            },
            {
              "type": "function",
              "name": "updated_at",
              "code": "  const updated_at = data[offset + 1] as number;\n  return [value, updated_at];\n};\n",
              "lineStart": 49,
              "lineEnd": 52
            },
            {
              "type": "function",
              "name": "setValueTuple",
              "code": "const setValueTuple = (product_id: string, field: IQuoteKey, value: string, updated_at: number) => {",
              "lineStart": 53,
              "lineEnd": 53
            },
            {
              "type": "function",
              "name": "offset",
              "code": "  const offset = getFieldOffset(product_id, field);\n  data[offset] = value;\n  data[offset + 1] = updated_at;\n};\n",
              "lineStart": 54,
              "lineEnd": 58
            },
            {
              "type": "function",
              "name": "update",
              "code": "const update = (action: IQuoteUpdateAction) => {",
              "lineStart": 59,
              "lineEnd": 59
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id in action) {",
              "lineStart": 60,
              "lineEnd": 60
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = action[product_id];",
              "lineStart": 61,
              "lineEnd": 61
            },
            {
              "type": "function",
              "name": "field_name",
              "code": "for (const field_name in fields) {",
              "lineStart": 62,
              "lineEnd": 62
            },
            {
              "type": "function",
              "name": "field",
              "code": "const field = field_name as IQuoteKey;\nconst [value, updated_at] = fields[field]!;",
              "lineStart": 63,
              "lineEnd": 64
            },
            {
              "type": "function",
              "name": "oldTuple",
              "code": "      const oldTuple = getValueTuple(product_id, field);\n      if (oldTuple === undefined || updated_at >= oldTuple[1]) {\n        setValueTuple(product_id, field, value, updated_at);\n      }\n    }\n  }\n};\n",
              "lineStart": 65,
              "lineEnd": 72
            },
            {
              "type": "function",
              "name": "dumpAsObject",
              "code": "const dumpAsObject = (): IQuoteUpdateAction => {",
              "lineStart": 73,
              "lineEnd": 73
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};",
              "lineStart": 74,
              "lineEnd": 74
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of products) {\n  result[product_id] = {};\n}",
              "lineStart": 75,
              "lineEnd": 77
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < data.length; i += 2) {",
              "lineStart": 78,
              "lineEnd": 78
            },
            {
              "type": "function",
              "name": "value",
              "code": "const value = data[i] as string;\nif (value === undefined) continue;",
              "lineStart": 79,
              "lineEnd": 80
            },
            {
              "type": "function",
              "name": "updated_at",
              "code": "const updated_at = data[i + 1] as number;\n",
              "lineStart": 81,
              "lineEnd": 82
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(i / (FIELD_COUNT * 2));",
              "lineStart": 83,
              "lineEnd": 83
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "const product_id = products[productIndex];\n",
              "lineStart": 84,
              "lineEnd": 85
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = (i % (FIELD_COUNT * 2)) / 2;",
              "lineStart": 86,
              "lineEnd": 86
            },
            {
              "type": "function",
              "name": "field_name",
              "code": "    const field_name = FIELDS[fieldIndex];\n\n    result[product_id][field_name] = [value, updated_at];\n  }\n  return result;\n};\n\n/**\n * 过滤状态，返回指定 product_id 列表和字段列表中，且更新时间不早于指定时间的字段数据\n * @param product_ids - 需要过滤的 product_id 列表\n * @param fields - 需要过滤的字段列表\n * @param updated_at - 需要过滤的更新时间阈值 (仅返回更新时间不早于该值的字段)\n * @returns 过滤后的数据\n */",
              "lineStart": 87,
              "lineEnd": 100
            },
            {
              "type": "function",
              "name": "filter",
              "code": "const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {",
              "lineStart": 101,
              "lineEnd": 101
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};",
              "lineStart": 102,
              "lineEnd": 102
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of product_ids) {\n  result[product_id] = {};",
              "lineStart": 103,
              "lineEnd": 104
            },
            {
              "type": "function",
              "name": "field",
              "code": "for (const field of fields) {",
              "lineStart": 105,
              "lineEnd": 105
            },
            {
              "type": "function",
              "name": "tuple",
              "code": "        const tuple = getValueTuple(product_id, field);\n        if (tuple && tuple[1] >= updated_at) {\n          result[product_id]![field] = tuple;\n        }\n      }\n    }\n    return result;\n  };\n\n  return { update, dumpAsObject, getValueTuple, filter };\n};",
              "lineStart": 106,
              "lineEnd": 117
            }
          ]
        },
        {
          "additions": 28,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/types.ts",
          "changeType": "added",
          "patch": "commit fdd39ba65bcba466d70ba66c6e295596a85ba3b1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 22:26:23 2025 +0800\n\n    feat: implement quote service with state management and update actions (#2313)\n\ndiff --git a/apps/virtual-exchange/src/quote/types.ts b/apps/virtual-exchange/src/quote/types.ts\nnew file mode 100644\nindex 000000000..664658d76\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/types.ts\n@@ -0,0 +1,28 @@\n+import { IQuote } from '@yuants/data-quote';\n+\n+export type IQuoteKey = Exclude<keyof IQuote, 'datasource_id' | 'product_id' | 'updated_at'>;\n+\n+/**\n+ * 用于批量更新的数据结构\n+ * 结构为：\n+ * product_id -> field_name (keyof IQuote) -> [value: string, updated_at: number]\n+ * 这样设计的目的是为了减少更新的数据量，同时保留每个字段的更新时间\n+ *\n+ * 例如：\n+ * ```json\n+ * {\n+ *   \"product_123\": {\n+ *     \"last_price\": [\"100.5\", 1627890123456],\n+ *     \"volume\": [\"1500\", 1627890123456]\n+ *   },\n+ *   \"product_456\": {\n+ *     \"last_price\": [\"200.0\", 1627890123456]\n+ *   }\n+ * }\n+ * ```\n+ * @public\n+ */\n+export type IQuoteUpdateAction = Record<\n+  string,\n+  Partial<Record<IQuoteKey, [value: string, updated_at: number]>>\n+>;\n",
          "codeSnippets": []
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/app-virtual-exchange/2025-12-12-14-12.json",
          "changeType": "added",
          "patch": "commit fdd39ba65bcba466d70ba66c6e295596a85ba3b1\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Fri Dec 12 22:26:23 2025 +0800\n\n    feat: implement quote service with state management and update actions (#2313)\n\ndiff --git a/common/changes/@yuants/app-virtual-exchange/2025-12-12-14-12.json b/common/changes/@yuants/app-virtual-exchange/2025-12-12-14-12.json\nnew file mode 100644\nindex 000000000..973448b7d\n--- /dev/null\n+++ b/common/changes/@yuants/app-virtual-exchange/2025-12-12-14-12.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/app-virtual-exchange\",\n+      \"comment\": \"support quote service\",\n+      \"type\": \"minor\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/app-virtual-exchange\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        }
      ]
    },
    {
      "hash": "3eab2932ebf784ad6ffdeebb72791764e85d24bb",
      "short": "3eab2932e",
      "author": "CZ",
      "email": "zheng.chen@no-trade-no.life",
      "authoredAt": "2025-12-13 06:41:38 +0800",
      "subject": "feat: add benchmark suite for quote state performance testing (#2314)",
      "conventionalCommit": {
        "type": "feat",
        "scope": null,
        "breaking": false
      },
      "files": [
        {
          "additions": 218,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/QUOTE_STATE_PERFORMANCE_REPORT.md",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/QUOTE_STATE_PERFORMANCE_REPORT.md b/apps/virtual-exchange/src/quote/QUOTE_STATE_PERFORMANCE_REPORT.md\nnew file mode 100644\nindex 000000000..b90b7b77a\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/QUOTE_STATE_PERFORMANCE_REPORT.md\n@@ -0,0 +1,218 @@\n+# 行情状态管理器性能基准测试报告\n+\n+## 测试概述\n+\n+本报告评估了 `@apps/virtual-exchange/src/quote/state.ts` 中实现的行情状态管理器的性能特性。该管理器使用扁平化数组存储数据，避免内存碎片化，提供高效的读写接口。\n+\n+测试覆盖了 10K、100K、1M 个 product_id 的大规模场景，评估了初始化、更新、查询、过滤和转储等核心操作的性能表现。\n+\n+**测试环境**：\n+\n+- Node.js (ts-node 执行)\n+- 测试时间：2025-12-13\n+- 测试数据：每个产品包含 10 个字段（last_price, ask_price, ask_volume, bid_volume, bid_price, interest_rate_short, open_interest, interest_rate_prev_settled_at, interest_rate_next_settled_at, interest_rate_long）\n+\n+**测试配置**：\n+\n+```bash\n+# 完整测试套件（需要16GB堆内存支持1M产品）\n+NODE_OPTIONS=\"--max-old-space-size=16384\" npx ts-node src/quote/state.benchmark.ts\n+\n+# 仅初始化测试\n+npx ts-node src/quote/state.benchmark.ts --init-only\n+\n+# 快速测试（1K/10K产品）\n+npx ts-node src/quote/state.benchmark.ts --quick\n+\n+# 对比测试：比较原始实现和基线Map实现\n+npx ts-node src/quote/state.benchmark.ts --compare\n+\n+# 子进程隔离内存对比测试（确保内存测试公平性）\n+npx ts-node src/quote/state.benchmark.ts --fork-compare\n+\n+# 快速子进程对比测试\n+npx ts-node src/quote/state.benchmark.ts --fork-compare --quick\n+```\n+\n+## 性能测试结果总结\n+\n+### 1. 初始化测试（批量插入所有字段）\n+\n+| 产品数量 | 测试时间 | 内存使用  | 每产品内存使用 |\n+| -------- | -------- | --------- | -------------- |\n+| 10K      | 10.32ms  | 15.37 MB  | 1.57 KB        |\n+| 100K     | 171.33ms | 140.87 MB | 1.44 KB        |\n+| 1M       | 1.39s    | 1.34 GB   | 1.41 KB        |\n+\n+### 2. 更新测试（随机更新单个字段）\n+\n+| 产品数量 | 更新次数 | 总时间  | 平均每次更新时间 |\n+| -------- | -------- | ------- | ---------------- |\n+| 10K      | 1,000    | 0.436ms | 0.00044ms        |\n+| 100K     | 100      | 0.098ms | 0.001ms          |\n+| 1M       | 10       | 0.068ms | 0.007ms          |\n+\n+### 3. 查询测试（随机查询单个字段值）\n+\n+| 产品数量 | 查询次数 | 总时间  | 平均每次查询时间 |\n+| -------- | -------- | ------- | ---------------- |\n+| 10K      | 10,000   | 3.96ms  | 0.0004ms         |\n+| 100K     | 1,000    | 0.663ms | 0.001ms          |\n+| 1M       | 100      | 0.284ms | 0.003ms          |\n+\n+### 4. 过滤测试（多条件筛选：随机产品 ID 列表 + 字段列表）\n+\n+| 产品数量 | 过滤次数 | 总时间  | 平均每次过滤时间 |\n+| -------- | -------- | ------- | ---------------- |\n+| 10K      | 1,000    | 42.23ms | 0.042ms          |\n+| 100K     | 100      | 6.52ms  | 0.065ms          |\n+| 1M       | 10       | 6.81ms  | 0.681ms          |\n+\n+### 5. 转储测试（导出整个状态为对象）\n+\n+| 产品数量 | 测试时间 |\n+| -------- | -------- |\n+| 10K      | 22.41ms  |\n+| 100K     | 178.10ms |\n+| 1M       | 4.58s    |\n+\n+### 6. 对比测试结果（Flat Array vs Nested Map）\n+\n+**测试方法**：使用子进程隔离内存测试（--fork-compare），确保每个实现都在独立的内存空间中运行，避免 GC 干扰。\n+\n+| 产品数量 | 实现                      | 初始化时间 | 内存使用 | 每产品内存  | 性能对比                  |\n+| -------- | ------------------------- | ---------- | -------- | ----------- | ------------------------- |\n+| 1K       | **Flat Array (Current)**  | 5.06ms     | 80.71 KB | 80.7 bytes  | **基准**                  |\n+| 1K       | **Nested Map (Baseline)** | 3.88ms     | 1.01 MB  | 1.01 KB     | 快 30.39%，但多用 92%内存 |\n+| 10K      | **Flat Array (Current)**  | 16.19ms    | 2.26 MB  | 231.4 bytes | **基准**                  |\n+| 10K      | **Nested Map (Baseline)** | 23.56ms    | 11.37 MB | 1.14 KB     | 慢 31.29%，多用 80%内存   |\n+\n+**关键发现**：\n+\n+1. **内存效率**：Flat Array 实现比 Nested Map 节省 80-92%内存\n+2. **性能表现**：小数据量时 Nested Map 稍快，但数据量增大后 Flat Array 更优\n+3. **可扩展性**：Flat Array 的内存增长更线性、更可预测\n+4. **GC 影响**：子进程测试消除了 GC 干扰，结果更公平可靠\n+\n+## 技术架构分析\n+\n+### 数据结构设计\n+\n+```typescript\n+// 扁平化数组存储：避免内存碎片化，提高缓存局部性\n+const data: (string | number)[] = [];\n+\n+// 字段布局：每个产品占用连续内存空间\n+// [value1, updated_at1, value2, updated_at2, ..., value10, updated_at10]\n+```\n+\n+### 核心性能优化\n+\n+1. **内存连续性**：使用扁平化数组而非 Map/对象，减少内存碎片\n+2. **O(1) 访问**：通过预计算的偏移量直接访问字段数据\n+3. **批量操作**：支持批量更新，减少函数调用开销\n+4. **时间戳比较**：更新时检查时间戳，避免不必要的数据写入\n+\n+## 关键发现\n+\n+### 1. 卓越的读写性能\n+\n+- **亚毫秒级响应**：即使在 1M 产品规模下，单次更新/查询仍保持亚毫秒级响应\n+- **线性扩展**：查询和更新操作的时间复杂度接近 O(1)，与数据量关系不大\n+- **内存效率**：每产品约 1.4-1.6KB，与预期数据结构（20 个元素/产品）相符\n+\n+### 2. 内存使用特征\n+\n+- **可预测的内存占用**：内存使用与产品数量呈线性关系（约 1.4KB/产品）\n+- **稳定的内存增长**：未观察到内存泄漏或异常增长\n+- **大规模可扩展**：1M 产品约需 1.4GB 内存，在合理范围内\n+\n+### 3. 操作性能对比\n+\n+- **更新/查询极快**：得益于 O(1) 访问和扁平化存储\n+- **过滤开销相对较高**：涉及多产品多字段遍历，复杂度为 O(n\\*m)\n+- **转储成本显著**：全量导出需要构建大型对象，1M 产品需 4.58 秒\n+\n+### 4. 设计优势验证\n+\n+- **扁平化数组有效**：避免了 JavaScript 对象和 Map 的内存碎片问题\n+- **字段偏移计算正确**：预计算的偏移量确保了高效访问\n+- **时间戳机制合理**：有效避免了重复更新\n+\n+## 性能瓶颈分析\n+\n+### 1. 过滤操作\n+\n+- **复杂度**：O(n\\*m)，其中 n 为产品数量，m 为字段数量\n+- **优化空间**：可考虑为常用过滤条件建立索引\n+\n+### 2. 转储操作\n+\n+- **内存复制开销**：需要复制整个状态到新对象\n+- **对象创建成本**：大量小对象的创建和垃圾回收\n+- **改进建议**：支持流式导出或增量导出\n+\n+### 3. 初始化开销\n+\n+- **批量插入效率**：10K 产品约 10ms，满足实时性要求\n+- **内存分配**：一次性分配大数组可能造成 GC 压力\n+\n+## 使用建议\n+\n+### 推荐使用场景\n+\n+1. **高频行情处理**：极快的更新速度适合实时行情更新\n+2. **大规模产品管理**：支持百万级产品，内存占用可控\n+3. **内存数据库**：可作为内存中的行情缓存\n+4. **实时查询服务**：亚毫秒级查询响应满足低延迟需求\n+\n+### 性能调优建议\n+\n+1. **批量更新优先**：使用 `IQuoteUpdateAction` 进行批量更新，减少函数调用\n+2. **避免频繁转储**：转储操作成本高，尽量避免全量导出\n+3. **合理设置过滤条件**：过滤操作相对较慢，限制产品数量和字段数量\n+4. **内存监控**：大规模部署时监控堆内存使用\n+\n+### 配置建议\n+\n+1. **Node.js 内存配置**：\n+\n+   ```bash\n+   # 处理 1M 产品需要约 2GB 堆内存\n+   NODE_OPTIONS=\"--max-old-space-size=2048\"\n+\n+   # 处理 10M 产品需要约 14GB 堆内存\n+   NODE_OPTIONS=\"--max-old-space-size=14336\"\n+   ```\n+\n+2. **产品数量规划**：\n+   - 10K 产品：~15MB 内存，适合大多数场景\n+   - 100K 产品：~140MB 内存，适合中型交易所\n+   - 1M 产品：~1.4GB 内存，适合大型交易平台\n+\n+## 结论\n+\n+`@apps/virtual-exchange/src/quote/state.ts` 实现的行情状态管理器在性能方面表现出色：\n+\n+### 主要优势\n+\n+1. **极快的读写性能**：更新和查询操作达到亚毫秒级\n+2. **高效的内存使用**：每产品约 1.4KB，内存占用可预测\n+3. **良好的可扩展性**：支持百万级产品规模\n+4. **简洁的接口设计**：提供清晰的更新、查询、过滤接口\n+\n+### 适用性评估\n+\n+- **完全满足**：高频行情更新、实时查询、内存缓存\n+- **基本满足**：大规模产品管理、批量处理\n+- **需要优化**：频繁全量转储、复杂过滤条件\n+\n+### 推荐评级：★★★★★\n+\n+该实现采用的高效数据结构设计（扁平化数组 + 预计算偏移量）在实践中证明了其价值，是大规模实时行情处理的优秀解决方案。建议在生产环境中部署时，根据实际产品数量和更新频率适当调整 Node.js 堆内存配置。\n+\n+---\n+\n+_测试文件位置：`src/quote/state.benchmark.ts`_\n+_测试命令：`npx ts-node src/quote/state.benchmark.ts [--quick|--init-only|--compare|--fork-compare]`_\n+_报告生成时间：2025-12-13_\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "data",
              "code": "const data: (string | number)[] = [];\n\n// 字段布局：每个产品占用连续内存空间\n// [value1, updated_at1, value2, updated_at2, ..., value10, updated_at10]\n```\n\n### 核心性能优化\n\n1. **内存连续性**：使用扁平化数组而非 Map/对象，减少内存碎片\n2. **O(1) 访问**：通过预计算的偏移量直接访问字段数据\n3. **批量操作**：支持批量更新，减少函数调用开销\n4. **时间戳比较**：更新时检查时间戳，避免不必要的数据写入\n\n## 关键发现\n",
              "lineStart": 103,
              "lineEnd": 219
            }
          ]
        },
        {
          "additions": 456,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/ForkedQuoteStateComparisonTest.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/ForkedQuoteStateComparisonTest.ts b/apps/virtual-exchange/src/quote/benchmark/ForkedQuoteStateComparisonTest.ts\nnew file mode 100644\nindex 000000000..de83e5265\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/ForkedQuoteStateComparisonTest.ts\n@@ -0,0 +1,456 @@\n+import { exec } from 'child_process';\n+import { promisify } from 'util';\n+import { QuoteStateComparisonTest } from './QuoteStateComparisonTest';\n+import { PerformanceTester } from './PerformanceTester';\n+\n+const execAsync = promisify(exec);\n+\n+/**\n+ * 使用子进程进行隔离内存测试的对比测试类\n+ * 每个实现都在独立的子进程中运行，确保内存测试的公平性\n+ */\n+export class ForkedQuoteStateComparisonTest {\n+  private nameA: string;\n+  private nameB: string;\n+  private workerScriptPath: string;\n+\n+  constructor(\n+    nameA: string = 'Current',\n+    nameB: string = 'Baseline',\n+    workerScriptPath: string = __dirname + '/worker.ts',\n+  ) {\n+    this.nameA = nameA;\n+    this.nameB = nameB;\n+    this.workerScriptPath = workerScriptPath;\n+  }\n+\n+  /**\n+   * 运行单个测试场景的子进程\n+   */\n+  private async runWorkerTest(\n+    implName: string,\n+    testType: string,\n+    productCount: number,\n+    extraArgs: Record<string, string> = {},\n+  ): Promise<any> {\n+    // 构建命令行参数\n+    const args = [`--impl=${implName}`, `--test=${testType}`, `--product-count=${productCount}`];\n+\n+    // 添加额外参数\n+    for (const [key, value] of Object.entries(extraArgs)) {\n+      args.push(`--${key}=${value}`);\n+    }\n+\n+    // 执行 worker 脚本，启用 GC 以进行公平的内存测试\n+    const command = `node --expose-gc $(which ts-node) ${this.workerScriptPath} ${args.join(' ')}`;\n+\n+    try {\n+      const { stdout, stderr } = await execAsync(command);\n+\n+      if (stderr && stderr.trim()) {\n+        console.error(`Worker stderr (${implName}, ${testType}, ${productCount}):`, stderr);\n+      }\n+\n+      const result = JSON.parse(stdout.trim());\n+\n+      if (!result.success) {\n+        // 子进程返回了失败结果\n+        return {\n+          success: false,\n+          error: result.error || 'Unknown error',\n+          impl: implName,\n+          test: testType,\n+          productCount,\n+          avgTime: null,\n+          time: null,\n+          heapUsedDiff: null,\n+        };\n+      }\n+\n+      return result;\n+    } catch (error) {\n+      // 子进程执行失败（如 OOM killed、命令不存在等）\n+      console.error(`Worker execution failed (${implName}, ${testType}, ${productCount}):`, error);\n+\n+      // 返回一个失败对象，而不是抛出错误\n+      return {\n+        success: false,\n+        error: error instanceof Error ? error.message : String(error),\n+        impl: implName,\n+        test: testType,\n+        productCount,\n+        avgTime: null,\n+        time: null,\n+        heapUsedDiff: null,\n+      };\n+    }\n+  }\n+\n+  /**\n+   * 运行初始化测试对比\n+   */\n+  async runInitializationTestComparison(\n+    productCount: number,\n+    iterations: number = 3,\n+  ): Promise<{\n+    resultA: any;\n+    resultB: any;\n+  }> {\n+    console.log(`运行初始化对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品)`);\n+\n+    const resultA = await this.runWorkerTest('current', 'init', productCount, {\n+      iterations: iterations.toString(),\n+    });\n+    const resultB = await this.runWorkerTest('baseline', 'init', productCount, {\n+      iterations: iterations.toString(),\n+    });\n+\n+    return { resultA, resultB };\n+  }\n+\n+  /**\n+   * 运行更新测试对比\n+   */\n+  async runUpdateTestComparison(\n+    productCount: number,\n+    updateCount: number,\n+  ): Promise<{\n+    resultA: any;\n+    resultB: any;\n+  }> {\n+    console.log(\n+      `运行更新对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品, ${updateCount} 更新)`,\n+    );\n+\n+    const resultA = await this.runWorkerTest('current', 'update', productCount, {\n+      'update-count': updateCount.toString(),\n+    });\n+    const resultB = await this.runWorkerTest('baseline', 'update', productCount, {\n+      'update-count': updateCount.toString(),\n+    });\n+\n+    return { resultA, resultB };\n+  }\n+\n+  /**\n+   * 运行查询测试对比\n+   */\n+  async runQueryTestComparison(\n+    productCount: number,\n+    queryCount: number,\n+  ): Promise<{\n+    resultA: any;\n+    resultB: any;\n+  }> {\n+    console.log(\n+      `运行查询对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品, ${queryCount} 查询)`,\n+    );\n+\n+    const resultA = await this.runWorkerTest('current', 'query', productCount, {\n+      'query-count': queryCount.toString(),\n+    });\n+    const resultB = await this.runWorkerTest('baseline', 'query', productCount, {\n+      'query-count': queryCount.toString(),\n+    });\n+\n+    return { resultA, resultB };\n+  }\n+\n+  /**\n+   * 运行过滤测试对比\n+   */\n+  async runFilterTestComparison(\n+    productCount: number,\n+    filterCount: number,\n+  ): Promise<{\n+    resultA: any;\n+    resultB: any;\n+  }> {\n+    console.log(\n+      `运行过滤对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品, ${filterCount} 过滤)`,\n+    );\n+\n+    const resultA = await this.runWorkerTest('current', 'filter', productCount, {\n+      'filter-count': filterCount.toString(),\n+    });\n+    const resultB = await this.runWorkerTest('baseline', 'filter', productCount, {\n+      'filter-count': filterCount.toString(),\n+    });\n+\n+    return { resultA, resultB };\n+  }\n+\n+  /**\n+   * 运行转储测试对比\n+   */\n+  async runDumpTestComparison(productCount: number): Promise<{\n+    resultA: any;\n+    resultB: any;\n+  }> {\n+    console.log(`运行转储对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品)`);\n+\n+    const resultA = await this.runWorkerTest('current', 'dump', productCount);\n+    const resultB = await this.runWorkerTest('baseline', 'dump', productCount);\n+\n+    return { resultA, resultB };\n+  }\n+\n+  /**\n+   * 打印对比结果（复用现有的对比结果打印逻辑）\n+   */\n+  private printComparisonResults(resultsA: any[], resultsB: any[], testType: string): void {\n+    // 创建一个临时的 QuoteStateComparisonTest 实例来复用其打印逻辑\n+    const tempComparison = new QuoteStateComparisonTest(\n+      () => {\n+        throw new Error('Not implemented');\n+      },\n+      () => {\n+        throw new Error('Not implemented');\n+      },\n+      this.nameA,\n+      this.nameB,\n+    );\n+\n+    // 使用私有方法，需要类型断言来访问\n+    const privateMethod = (tempComparison as any).printComparisonResults;\n+    if (typeof privateMethod === 'function') {\n+      privateMethod.call(tempComparison, resultsA, resultsB, testType);\n+    } else {\n+      // 如果无法访问私有方法，使用简化版本\n+      console.log(`\\n${this.nameA} vs ${this.nameB} - ${testType} 对比结果:`);\n+      for (let i = 0; i < Math.min(resultsA.length, resultsB.length); i++) {\n+        const a = resultsA[i];\n+        const b = resultsB[i];\n+\n+        // 检查是否有失败的测试\n+        const isAFailed = a.success === false;\n+        const isBFailed = b.success === false;\n+\n+        if (isAFailed || isBFailed) {\n+          console.log(`\\n产品数量: ${a.productCount || b.productCount}`);\n+\n+          if (isAFailed) {\n+            console.log(`❌ ${this.nameA} 测试失败: ${a.error || 'Unknown error'}`);\n+          } else {\n+            console.log(`${this.nameA}: ${a.avgTime || a.time}ms`);\n+          }\n+\n+          if (isBFailed) {\n+            console.log(`❌ ${this.nameB} 测试失败: ${b.error || 'Unknown error'}`);\n+          } else {\n+            console.log(`${this.nameB}: ${b.avgTime || b.time}ms`);\n+          }\n+\n+          // 打印内存使用（即使只有一个实现有数据）\n+          const memoryUsedA = a.heapUsedDiff;\n+          const memoryUsedB = b.heapUsedDiff;\n+          const hasMemoryA = memoryUsedA !== undefined && memoryUsedA !== null && !isNaN(memoryUsedA);\n+          const hasMemoryB = memoryUsedB !== undefined && memoryUsedB !== null && !isNaN(memoryUsedB);\n+\n+          if (hasMemoryA || hasMemoryB) {\n+            console.log(`\\n内存使用:`);\n+            if (hasMemoryA) {\n+              console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA)}`);\n+            }\n+            if (hasMemoryB) {\n+              console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB)}`);\n+            }\n+          }\n+\n+          console.log('-'.repeat(80));\n+          continue;\n+        }\n+\n+        console.log(`产品数量 ${a.productCount}: ${a.avgTime || a.time}ms vs ${b.avgTime || b.time}ms`);\n+\n+        // 打印内存使用（即使只有一个实现有数据）\n+        const memoryUsedA = a.heapUsedDiff;\n+        const memoryUsedB = b.heapUsedDiff;\n+        const hasMemoryA = memoryUsedA !== undefined && memoryUsedA !== null && !isNaN(memoryUsedA);\n+        const hasMemoryB = memoryUsedB !== undefined && memoryUsedB !== null && !isNaN(memoryUsedB);\n+\n+        if (hasMemoryA || hasMemoryB) {\n+          console.log(`\\n内存使用:`);\n+          if (hasMemoryA) {\n+            console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA)}`);\n+          }\n+          if (hasMemoryB) {\n+            console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB)}`);\n+          }\n+\n+          // 只有当两个实现都有有效内存数据时才进行对比\n+          if (hasMemoryA && hasMemoryB && memoryUsedA > 0 && memoryUsedB > 0) {\n+            const memoryRatio = memoryUsedA / memoryUsedB;\n+            const memoryPercentDiff = ((memoryRatio - 1) * 100).toFixed(2);\n+            if (memoryRatio > 1) {\n+              console.log(`${this.nameB} 节省 ${memoryPercentDiff}% 内存`);\n+            } else {\n+              console.log(`${this.nameA} 节省 ${(-parseFloat(memoryPercentDiff)).toFixed(2)}% 内存`);\n+            }\n+          }\n+        }\n+\n+        console.log('-'.repeat(80));\n+      }\n+    }\n+  }\n+\n+  /**\n+   * 运行完整的对比测试套件\n+   */\n+  async runComparisonTestSuite(): Promise<void> {\n+    console.log(`开始子进程隔离内存对比测试: ${this.nameA} vs ${this.nameB}`);\n+    console.log('注意：每个测试都在独立的子进程中运行，确保内存测试的公平性');\n+\n+    const testScenarios = [\n+      {\n+        productCount: 10000,\n+        label: '10K',\n+        updateIterations: 1000,\n+        queryIterations: 10000,\n+        filterIterations: 1000,\n+      },\n+      {\n+        productCount: 100000,\n+        label: '100K',\n+        updateIterations: 100,\n+        queryIterations: 1000,\n+        filterIterations: 100,\n+      },\n+      {\n+        productCount: 1000000,\n+        label: '1M',\n+        updateIterations: 10,\n+        queryIterations: 100,\n+        filterIterations: 10,\n+      },\n+    ];\n+\n+    // 初始化测试对比\n+    console.log('\\n运行初始化测试对比...');\n+    const initResultsA = [];\n+    const initResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runInitializationTestComparison(scenario.productCount, 3);\n+        initResultsA.push(resultA);\n+        initResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(initResultsA, initResultsB, '初始化测试');\n+\n+    // 更新测试对比\n+    console.log('\\n运行更新测试对比...');\n+    const updateResultsA = [];\n+    const updateResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runUpdateTestComparison(\n+          scenario.productCount,\n+          scenario.updateIterations,\n+        );\n+        updateResultsA.push(resultA);\n+        updateResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`更新对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(updateResultsA, updateResultsB, '更新测试');\n+\n+    // 查询测试对比\n+    console.log('\\n运行查询测试对比...');\n+    const queryResultsA = [];\n+    const queryResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runQueryTestComparison(\n+          scenario.productCount,\n+          scenario.queryIterations,\n+        );\n+        queryResultsA.push(resultA);\n+        queryResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`查询对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(queryResultsA, queryResultsB, '查询测试');\n+\n+    // 过滤测试对比\n+    console.log('\\n运行过滤测试对比...');\n+    const filterResultsA = [];\n+    const filterResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runFilterTestComparison(\n+          scenario.productCount,\n+          scenario.filterIterations,\n+        );\n+        filterResultsA.push(resultA);\n+        filterResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`过滤对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(filterResultsA, filterResultsB, '过滤测试');\n+\n+    // 转储测试对比\n+    console.log('\\n运行转储测试对比...');\n+    const dumpResultsA = [];\n+    const dumpResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runDumpTestComparison(scenario.productCount);\n+        dumpResultsA.push(resultA);\n+        dumpResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`转储对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(dumpResultsA, dumpResultsB, '转储测试');\n+\n+    console.log('\\n子进程隔离内存对比测试完成!');\n+  }\n+\n+  /**\n+   * 运行快速对比测试（仅测试小数据量）\n+   */\n+  async runQuickComparisonTest(): Promise<void> {\n+    console.log(`开始快速子进程对比测试: ${this.nameA} vs ${this.nameB}`);\n+\n+    const quickScenarios = [\n+      {\n+        productCount: 1000,\n+        label: '1K',\n+        updateIterations: 100,\n+        queryIterations: 1000,\n+        filterIterations: 100,\n+      },\n+      { productCount: 10000, label: '10K', updateIterations: 10, queryIterations: 100, filterIterations: 10 },\n+    ];\n+\n+    // 初始化测试对比\n+    console.log('\\n运行初始化测试对比...');\n+    const initResultsA = [];\n+    const initResultsB = [];\n+    for (const scenario of quickScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const { resultA, resultB } = await this.runInitializationTestComparison(scenario.productCount, 2);\n+        initResultsA.push(resultA);\n+        initResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(initResultsA, initResultsB, '快速初始化测试');\n+\n+    console.log('\\n快速子进程对比测试完成!');\n+  }\n+}\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "execAsync",
              "code": "const execAsync = promisify(exec);\n\n/**\n * 使用子进程进行隔离内存测试的对比测试类\n * 每个实现都在独立的子进程中运行，确保内存测试的公平性\n */",
              "lineStart": 6,
              "lineEnd": 11
            },
            {
              "type": "class",
              "name": "ForkedQuoteStateComparisonTest",
              "code": "export class ForkedQuoteStateComparisonTest {\n  private nameA: string;\n  private nameB: string;\n  private workerScriptPath: string;\n\n  constructor(\n    nameA: string = 'Current',\n    nameB: string = 'Baseline',\n    workerScriptPath: string = __dirname + '/worker.ts',\n  ) {\n    this.nameA = nameA;\n    this.nameB = nameB;\n    this.workerScriptPath = workerScriptPath;\n  }\n",
              "lineStart": 12,
              "lineEnd": 36
            },
            {
              "type": "function",
              "name": "args",
              "code": "const args = [`--impl=${implName}`, `--test=${testType}`, `--product-count=${productCount}`];\n\n// 添加额外参数\nfor (const [key, value] of Object.entries(extraArgs)) {\n  args.push(`--${key}=${value}`);\n}\n\n// 执行 worker 脚本，启用 GC 以进行公平的内存测试",
              "lineStart": 37,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "command",
              "code": "const command = `node --expose-gc $(which ts-node) ${this.workerScriptPath} ${args.join(' ')}`;\n\ntry {\n  const { stdout, stderr } = await execAsync(command);\n\n  if (stderr && stderr.trim()) {\n    console.error(`Worker stderr (${implName}, ${testType}, ${productCount}):`, stderr);\n  }\n",
              "lineStart": 45,
              "lineEnd": 53
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = JSON.parse(stdout.trim());\n\nif (!result.success) {\n  // 子进程返回了失败结果\n  return {\n    success: false,\n    error: result.error || 'Unknown error',\n    impl: implName,\n    test: testType,\n    productCount,\n    avgTime: null,\n    time: null,\n    heapUsedDiff: null,\n  };\n}",
              "lineStart": 54,
              "lineEnd": 100
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runWorkerTest('current', 'init', productCount, {\n  iterations: iterations.toString(),\n});",
              "lineStart": 101,
              "lineEnd": 103
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "  const resultB = await this.runWorkerTest('baseline', 'init', productCount, {\n    iterations: iterations.toString(),\n  });\n\n  return { resultA, resultB };\n}\n\n/**\n * 运行更新测试对比\n */\nasync runUpdateTestComparison(\n  productCount: number,\n  updateCount: number,\n): Promise<{\n  resultA: any;",
              "lineStart": 104,
              "lineEnd": 124
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runWorkerTest('current', 'update', productCount, {\n  'update-count': updateCount.toString(),\n});",
              "lineStart": 125,
              "lineEnd": 127
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "  const resultB = await this.runWorkerTest('baseline', 'update', productCount, {\n    'update-count': updateCount.toString(),\n  });\n\n  return { resultA, resultB };\n}\n\n/**\n * 运行查询测试对比\n */\nasync runQueryTestComparison(\n  productCount: number,\n  queryCount: number,\n): Promise<{\n  resultA: any;",
              "lineStart": 128,
              "lineEnd": 148
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runWorkerTest('current', 'query', productCount, {\n  'query-count': queryCount.toString(),\n});",
              "lineStart": 149,
              "lineEnd": 151
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "  const resultB = await this.runWorkerTest('baseline', 'query', productCount, {\n    'query-count': queryCount.toString(),\n  });\n\n  return { resultA, resultB };\n}\n\n/**\n * 运行过滤测试对比\n */\nasync runFilterTestComparison(\n  productCount: number,\n  filterCount: number,\n): Promise<{\n  resultA: any;",
              "lineStart": 152,
              "lineEnd": 172
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runWorkerTest('current', 'filter', productCount, {\n  'filter-count': filterCount.toString(),\n});",
              "lineStart": 173,
              "lineEnd": 175
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "  const resultB = await this.runWorkerTest('baseline', 'filter', productCount, {\n    'filter-count': filterCount.toString(),\n  });\n\n  return { resultA, resultB };\n}\n\n/**\n * 运行转储测试对比\n */\nasync runDumpTestComparison(productCount: number): Promise<{\n  resultA: any;\n  resultB: any;\n}> {\n  console.log(`运行转储对比测试: ${this.nameA} vs ${this.nameB} (${productCount} 产品)`);",
              "lineStart": 176,
              "lineEnd": 191
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runWorkerTest('current', 'dump', productCount);",
              "lineStart": 192,
              "lineEnd": 192
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "  const resultB = await this.runWorkerTest('baseline', 'dump', productCount);\n\n  return { resultA, resultB };\n}\n\n/**\n * 打印对比结果（复用现有的对比结果打印逻辑）\n */\nprivate printComparisonResults(resultsA: any[], resultsB: any[], testType: string): void {\n  // 创建一个临时的 QuoteStateComparisonTest 实例来复用其打印逻辑",
              "lineStart": 193,
              "lineEnd": 202
            },
            {
              "type": "function",
              "name": "tempComparison",
              "code": "const tempComparison = new QuoteStateComparisonTest(\n  () => {\n    throw new Error('Not implemented');\n  },\n  () => {\n    throw new Error('Not implemented');\n  },\n  this.nameA,\n  this.nameB,\n);\n\n// 使用私有方法，需要类型断言来访问",
              "lineStart": 203,
              "lineEnd": 214
            },
            {
              "type": "function",
              "name": "privateMethod",
              "code": "const privateMethod = (tempComparison as any).printComparisonResults;\nif (typeof privateMethod === 'function') {\n  privateMethod.call(tempComparison, resultsA, resultsB, testType);\n} else {\n  // 如果无法访问私有方法，使用简化版本\n  console.log(`\\n${this.nameA} vs ${this.nameB} - ${testType} 对比结果:`);",
              "lineStart": 215,
              "lineEnd": 220
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < Math.min(resultsA.length, resultsB.length); i++) {",
              "lineStart": 221,
              "lineEnd": 221
            },
            {
              "type": "function",
              "name": "a",
              "code": "const a = resultsA[i];",
              "lineStart": 222,
              "lineEnd": 222
            },
            {
              "type": "function",
              "name": "b",
              "code": "const b = resultsB[i];\n\n// 检查是否有失败的测试",
              "lineStart": 223,
              "lineEnd": 225
            },
            {
              "type": "function",
              "name": "isAFailed",
              "code": "const isAFailed = a.success === false;",
              "lineStart": 226,
              "lineEnd": 226
            },
            {
              "type": "function",
              "name": "isBFailed",
              "code": "const isBFailed = b.success === false;\n\nif (isAFailed || isBFailed) {\n  console.log(`\\n产品数量: ${a.productCount || b.productCount}`);\n\n  if (isAFailed) {\n    console.log(`❌ ${this.nameA} 测试失败: ${a.error || 'Unknown error'}`);\n  } else {\n    console.log(`${this.nameA}: ${a.avgTime || a.time}ms`);\n  }\n\n  if (isBFailed) {\n    console.log(`❌ ${this.nameB} 测试失败: ${b.error || 'Unknown error'}`);\n  } else {\n    console.log(`${this.nameB}: ${b.avgTime || b.time}ms`);",
              "lineStart": 227,
              "lineEnd": 244
            },
            {
              "type": "function",
              "name": "memoryUsedA",
              "code": "const memoryUsedA = a.heapUsedDiff;",
              "lineStart": 245,
              "lineEnd": 245
            },
            {
              "type": "function",
              "name": "memoryUsedB",
              "code": "const memoryUsedB = b.heapUsedDiff;",
              "lineStart": 246,
              "lineEnd": 246
            },
            {
              "type": "function",
              "name": "hasMemoryA",
              "code": "const hasMemoryA = memoryUsedA !== undefined && memoryUsedA !== null && !isNaN(memoryUsedA);",
              "lineStart": 247,
              "lineEnd": 247
            },
            {
              "type": "function",
              "name": "hasMemoryB",
              "code": "  const hasMemoryB = memoryUsedB !== undefined && memoryUsedB !== null && !isNaN(memoryUsedB);\n\n  if (hasMemoryA || hasMemoryB) {\n    console.log(`\\n内存使用:`);\n    if (hasMemoryA) {\n      console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA)}`);\n    }\n    if (hasMemoryB) {\n      console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB)}`);\n    }\n  }\n\n  console.log('-'.repeat(80));\n  continue;\n}",
              "lineStart": 248,
              "lineEnd": 266
            },
            {
              "type": "function",
              "name": "memoryUsedA",
              "code": "const memoryUsedA = a.heapUsedDiff;",
              "lineStart": 267,
              "lineEnd": 267
            },
            {
              "type": "function",
              "name": "memoryUsedB",
              "code": "const memoryUsedB = b.heapUsedDiff;",
              "lineStart": 268,
              "lineEnd": 268
            },
            {
              "type": "function",
              "name": "hasMemoryA",
              "code": "const hasMemoryA = memoryUsedA !== undefined && memoryUsedA !== null && !isNaN(memoryUsedA);",
              "lineStart": 269,
              "lineEnd": 269
            },
            {
              "type": "function",
              "name": "hasMemoryB",
              "code": "const hasMemoryB = memoryUsedB !== undefined && memoryUsedB !== null && !isNaN(memoryUsedB);\n\nif (hasMemoryA || hasMemoryB) {\n  console.log(`\\n内存使用:`);\n  if (hasMemoryA) {\n    console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA)}`);\n  }\n  if (hasMemoryB) {\n    console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB)}`);\n  }\n\n  // 只有当两个实现都有有效内存数据时才进行对比\n  if (hasMemoryA && hasMemoryB && memoryUsedA > 0 && memoryUsedB > 0) {",
              "lineStart": 270,
              "lineEnd": 282
            },
            {
              "type": "function",
              "name": "memoryRatio",
              "code": "const memoryRatio = memoryUsedA / memoryUsedB;",
              "lineStart": 283,
              "lineEnd": 283
            },
            {
              "type": "function",
              "name": "memoryPercentDiff",
              "code": "          const memoryPercentDiff = ((memoryRatio - 1) * 100).toFixed(2);\n          if (memoryRatio > 1) {\n            console.log(`${this.nameB} 节省 ${memoryPercentDiff}% 内存`);\n          } else {\n            console.log(`${this.nameA} 节省 ${(-parseFloat(memoryPercentDiff)).toFixed(2)}% 内存`);\n          }\n        }\n      }\n\n      console.log('-'.repeat(80));\n    }\n  }\n}\n\n/**",
              "lineStart": 284,
              "lineEnd": 304
            },
            {
              "type": "function",
              "name": "testScenarios",
              "code": "const testScenarios = [\n  {\n    productCount: 10000,\n    label: '10K',\n    updateIterations: 1000,\n    queryIterations: 10000,\n    filterIterations: 1000,\n  },\n  {\n    productCount: 100000,\n    label: '100K',\n    updateIterations: 100,\n    queryIterations: 1000,\n    filterIterations: 100,\n  },",
              "lineStart": 305,
              "lineEnd": 330
            },
            {
              "type": "function",
              "name": "initResultsA",
              "code": "const initResultsA = [];",
              "lineStart": 331,
              "lineEnd": 331
            },
            {
              "type": "function",
              "name": "initResultsB",
              "code": "const initResultsB = [];",
              "lineStart": 332,
              "lineEnd": 332
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    const { resultA, resultB } = await this.runInitializationTestComparison(scenario.productCount, 3);\n    initResultsA.push(resultA);\n    initResultsB.push(resultB);\n  } catch (error) {\n    console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(initResultsA, initResultsB, '初始化测试');\n\n// 更新测试对比\nconsole.log('\\n运行更新测试对比...');",
              "lineStart": 333,
              "lineEnd": 346
            },
            {
              "type": "function",
              "name": "updateResultsA",
              "code": "const updateResultsA = [];",
              "lineStart": 347,
              "lineEnd": 347
            },
            {
              "type": "function",
              "name": "updateResultsB",
              "code": "const updateResultsB = [];",
              "lineStart": 348,
              "lineEnd": 348
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    const { resultA, resultB } = await this.runUpdateTestComparison(\n      scenario.productCount,\n      scenario.updateIterations,\n    );\n    updateResultsA.push(resultA);\n    updateResultsB.push(resultB);\n  } catch (error) {\n    console.error(`更新对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(updateResultsA, updateResultsB, '更新测试');\n",
              "lineStart": 349,
              "lineEnd": 365
            },
            {
              "type": "function",
              "name": "queryResultsA",
              "code": "const queryResultsA = [];",
              "lineStart": 366,
              "lineEnd": 366
            },
            {
              "type": "function",
              "name": "queryResultsB",
              "code": "const queryResultsB = [];",
              "lineStart": 367,
              "lineEnd": 367
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    const { resultA, resultB } = await this.runQueryTestComparison(\n      scenario.productCount,\n      scenario.queryIterations,\n    );\n    queryResultsA.push(resultA);\n    queryResultsB.push(resultB);\n  } catch (error) {\n    console.error(`查询对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(queryResultsA, queryResultsB, '查询测试');\n",
              "lineStart": 368,
              "lineEnd": 384
            },
            {
              "type": "function",
              "name": "filterResultsA",
              "code": "const filterResultsA = [];",
              "lineStart": 385,
              "lineEnd": 385
            },
            {
              "type": "function",
              "name": "filterResultsB",
              "code": "const filterResultsB = [];",
              "lineStart": 386,
              "lineEnd": 386
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    const { resultA, resultB } = await this.runFilterTestComparison(\n      scenario.productCount,\n      scenario.filterIterations,\n    );\n    filterResultsA.push(resultA);\n    filterResultsB.push(resultB);\n  } catch (error) {\n    console.error(`过滤对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(filterResultsA, filterResultsB, '过滤测试');\n",
              "lineStart": 387,
              "lineEnd": 403
            },
            {
              "type": "function",
              "name": "dumpResultsA",
              "code": "const dumpResultsA = [];",
              "lineStart": 404,
              "lineEnd": 404
            },
            {
              "type": "function",
              "name": "dumpResultsB",
              "code": "const dumpResultsB = [];",
              "lineStart": 405,
              "lineEnd": 405
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "  for (const scenario of testScenarios) {\n    console.log(`测试 ${scenario.label} 产品...`);\n    try {\n      const { resultA, resultB } = await this.runDumpTestComparison(scenario.productCount);\n      dumpResultsA.push(resultA);\n      dumpResultsB.push(resultB);\n    } catch (error) {\n      console.error(`转储对比测试失败 (${scenario.label}):`, error);\n    }\n  }\n  this.printComparisonResults(dumpResultsA, dumpResultsB, '转储测试');\n\n  console.log('\\n子进程隔离内存对比测试完成!');\n}\n",
              "lineStart": 406,
              "lineEnd": 426
            },
            {
              "type": "function",
              "name": "quickScenarios",
              "code": "const quickScenarios = [\n  {\n    productCount: 1000,\n    label: '1K',\n    updateIterations: 100,\n    queryIterations: 1000,\n    filterIterations: 100,\n  },\n  { productCount: 10000, label: '10K', updateIterations: 10, queryIterations: 100, filterIterations: 10 },\n];\n\n// 初始化测试对比\nconsole.log('\\n运行初始化测试对比...');",
              "lineStart": 427,
              "lineEnd": 439
            },
            {
              "type": "function",
              "name": "initResultsA",
              "code": "const initResultsA = [];",
              "lineStart": 440,
              "lineEnd": 440
            },
            {
              "type": "function",
              "name": "initResultsB",
              "code": "const initResultsB = [];",
              "lineStart": 441,
              "lineEnd": 441
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "    for (const scenario of quickScenarios) {\n      console.log(`测试 ${scenario.label} 产品...`);\n      try {\n        const { resultA, resultB } = await this.runInitializationTestComparison(scenario.productCount, 2);\n        initResultsA.push(resultA);\n        initResultsB.push(resultB);\n      } catch (error) {\n        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n      }\n    }\n    this.printComparisonResults(initResultsA, initResultsB, '快速初始化测试');\n\n    console.log('\\n快速子进程对比测试完成!');\n  }\n}",
              "lineStart": 442,
              "lineEnd": 457
            }
          ]
        },
        {
          "additions": 154,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/PerformanceTester.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/PerformanceTester.ts b/apps/virtual-exchange/src/quote/benchmark/PerformanceTester.ts\nnew file mode 100644\nindex 000000000..5de2f97bf\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/PerformanceTester.ts\n@@ -0,0 +1,154 @@\n+import { performance } from 'perf_hooks';\n+\n+/**\n+ * 性能测试工具类\n+ */\n+export class PerformanceTester {\n+  /**\n+   * 测量函数执行时间\n+   */\n+  static async measureTime<T>(fn: () => Promise<T> | T): Promise<{ result: T; time: number }> {\n+    const start = performance.now();\n+    const result = await fn();\n+    const end = performance.now();\n+    return { result, time: end - start };\n+  }\n+\n+  /**\n+   * 多次测量函数执行时间，取平均值\n+   */\n+  static async measureTimeWithStats<T>(\n+    fn: () => Promise<T> | T,\n+    iterations: number = 5,\n+  ): Promise<{ result: T; avgTime: number; minTime: number; maxTime: number; times: number[] }> {\n+    const times: number[] = [];\n+    let finalResult: T | undefined;\n+\n+    for (let i = 0; i < iterations; i++) {\n+      const start = performance.now();\n+      const result = await fn();\n+      const end = performance.now();\n+\n+      if (i === 0) finalResult = result;\n+      times.push(end - start);\n+    }\n+\n+    const avgTime = times.reduce((a, b) => a + b, 0) / times.length;\n+    const minTime = Math.min(...times);\n+    const maxTime = Math.max(...times);\n+\n+    return {\n+      result: finalResult!,\n+      avgTime,\n+      minTime,\n+      maxTime,\n+      times,\n+    };\n+  }\n+\n+  /**\n+   * 尝试触发垃圾回收（如果可用）\n+   */\n+  static tryGarbageCollect(): void {\n+    if (typeof global !== 'undefined' && (global as any).gc) {\n+      try {\n+        (global as any).gc();\n+      } catch (error) {\n+        // 忽略GC错误\n+      }\n+    }\n+  }\n+\n+  /**\n+   * 确保在内存测量前清理环境\n+   */\n+  static prepareForMemoryMeasurement(): void {\n+    // 触发GC（如果可用）\n+    this.tryGarbageCollect();\n+\n+    // 给GC一些时间\n+    if (typeof setImmediate !== 'undefined') {\n+      // 使用setImmediate让事件循环有机会处理GC\n+      return;\n+    }\n+  }\n+\n+  /**\n+   * 获取内存使用情况（在清理后）\n+   */\n+  static getMemoryUsage(): NodeJS.MemoryUsage | null {\n+    this.prepareForMemoryMeasurement();\n+    if (typeof process !== 'undefined' && process.memoryUsage) {\n+      return process.memoryUsage();\n+    }\n+    return null;\n+  }\n+\n+  /**\n+   * 测量内存使用增长\n+   */\n+  static async measureMemoryUsage<T>(fn: () => Promise<T> | T): Promise<{\n+    result: T;\n+    memoryBefore: NodeJS.MemoryUsage | null;\n+    memoryAfter: NodeJS.MemoryUsage | null;\n+    heapUsedDiff: number | null;\n+  }> {\n+    // 清理环境并获取初始内存\n+    this.prepareForMemoryMeasurement();\n+    const memoryBefore = this.getMemoryUsage();\n+\n+    // 执行函数\n+    const result = await fn();\n+\n+    // 再次清理环境并获取最终内存\n+    this.prepareForMemoryMeasurement();\n+    const memoryAfter = this.getMemoryUsage();\n+\n+    // 计算内存差异\n+    let heapUsedDiff: number | null = null;\n+    if (\n+      memoryBefore &&\n+      memoryAfter &&\n+      memoryBefore.heapUsed !== undefined &&\n+      memoryAfter.heapUsed !== undefined\n+    ) {\n+      heapUsedDiff = memoryAfter.heapUsed - memoryBefore.heapUsed;\n+    }\n+\n+    return {\n+      result,\n+      memoryBefore,\n+      memoryAfter,\n+      heapUsedDiff,\n+    };\n+  }\n+\n+  /**\n+   * 格式化字节大小\n+   */\n+  static formatBytes(bytes: number): string {\n+    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n+    if (bytes === 0) return '0 Bytes';\n+    if (isNaN(bytes)) return 'NaN';\n+\n+    const sign = bytes < 0 ? '-' : '';\n+    const absBytes = Math.abs(bytes);\n+\n+    if (absBytes < 1024) {\n+      return `${sign}${absBytes} ${sizes[0]}`;\n+    }\n+\n+    const i = Math.floor(Math.log(absBytes) / Math.log(1024));\n+    const value = Math.round((absBytes / Math.pow(1024, i)) * 100) / 100;\n+    return `${sign}${value} ${sizes[i]}`;\n+  }\n+\n+  /**\n+   * 格式化时间\n+   */\n+  static formatTime(ms: number): string {\n+    if (ms < 1) return `${ms.toFixed(3)}ms`;\n+    if (ms < 1000) return `${ms.toFixed(2)}ms`;\n+    return `${(ms / 1000).toFixed(2)}s`;\n+  }\n+}\n",
          "codeSnippets": [
            {
              "type": "class",
              "name": "PerformanceTester",
              "code": "export class PerformanceTester {\n  /**\n   * 测量函数执行时间\n   */\n  static async measureTime<T>(fn: () => Promise<T> | T): Promise<{ result: T; time: number }> {",
              "lineStart": 6,
              "lineEnd": 10
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 11,
              "lineEnd": 11
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await fn();",
              "lineStart": 12,
              "lineEnd": 12
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n  return { result, time: end - start };\n}\n\n/**\n * 多次测量函数执行时间，取平均值\n */\nstatic async measureTimeWithStats<T>(\n  fn: () => Promise<T> | T,\n  iterations: number = 5,\n): Promise<{ result: T; avgTime: number; minTime: number; maxTime: number; times: number[] }> {",
              "lineStart": 13,
              "lineEnd": 23
            },
            {
              "type": "function",
              "name": "times",
              "code": "const times: number[] = [];",
              "lineStart": 24,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "finalResult",
              "code": "let finalResult: T | undefined;\n",
              "lineStart": 25,
              "lineEnd": 26
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {",
              "lineStart": 27,
              "lineEnd": 27
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 28,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await fn();",
              "lineStart": 29,
              "lineEnd": 29
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  if (i === 0) finalResult = result;\n  times.push(end - start);\n}\n",
              "lineStart": 30,
              "lineEnd": 35
            },
            {
              "type": "function",
              "name": "avgTime",
              "code": "const avgTime = times.reduce((a, b) => a + b, 0) / times.length;",
              "lineStart": 36,
              "lineEnd": 36
            },
            {
              "type": "function",
              "name": "minTime",
              "code": "const minTime = Math.min(...times);",
              "lineStart": 37,
              "lineEnd": 37
            },
            {
              "type": "function",
              "name": "maxTime",
              "code": "  const maxTime = Math.max(...times);\n\n  return {\n    result: finalResult!,\n    avgTime,\n    minTime,\n    maxTime,\n    times,\n  };\n}\n\n/**\n * 尝试触发垃圾回收（如果可用）\n */\nstatic tryGarbageCollect(): void {",
              "lineStart": 38,
              "lineEnd": 97
            },
            {
              "type": "function",
              "name": "memoryBefore",
              "code": "const memoryBefore = this.getMemoryUsage();\n\n// 执行函数",
              "lineStart": 98,
              "lineEnd": 100
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await fn();\n\n// 再次清理环境并获取最终内存\nthis.prepareForMemoryMeasurement();",
              "lineStart": 101,
              "lineEnd": 104
            },
            {
              "type": "function",
              "name": "memoryAfter",
              "code": "const memoryAfter = this.getMemoryUsage();\n\n// 计算内存差异",
              "lineStart": 105,
              "lineEnd": 107
            },
            {
              "type": "function",
              "name": "heapUsedDiff",
              "code": "let heapUsedDiff: number | null = null;\nif (\n  memoryBefore &&\n  memoryAfter &&\n  memoryBefore.heapUsed !== undefined &&\n  memoryAfter.heapUsed !== undefined\n) {\n  heapUsedDiff = memoryAfter.heapUsed - memoryBefore.heapUsed;\n}\n\nreturn {\n  result,\n  memoryBefore,\n  memoryAfter,\n  heapUsedDiff,",
              "lineStart": 108,
              "lineEnd": 129
            },
            {
              "type": "function",
              "name": "sizes",
              "code": "const sizes = ['Bytes', 'KB', 'MB', 'GB'];\nif (bytes === 0) return '0 Bytes';\nif (isNaN(bytes)) return 'NaN';\n",
              "lineStart": 130,
              "lineEnd": 133
            },
            {
              "type": "function",
              "name": "sign",
              "code": "const sign = bytes < 0 ? '-' : '';",
              "lineStart": 134,
              "lineEnd": 134
            },
            {
              "type": "function",
              "name": "absBytes",
              "code": "const absBytes = Math.abs(bytes);\n\nif (absBytes < 1024) {\n  return `${sign}${absBytes} ${sizes[0]}`;\n}\n",
              "lineStart": 135,
              "lineEnd": 140
            },
            {
              "type": "function",
              "name": "i",
              "code": "const i = Math.floor(Math.log(absBytes) / Math.log(1024));",
              "lineStart": 141,
              "lineEnd": 141
            },
            {
              "type": "function",
              "name": "value",
              "code": "    const value = Math.round((absBytes / Math.pow(1024, i)) * 100) / 100;\n    return `${sign}${value} ${sizes[i]}`;\n  }\n\n  /**\n   * 格式化时间\n   */\n  static formatTime(ms: number): string {\n    if (ms < 1) return `${ms.toFixed(3)}ms`;\n    if (ms < 1000) return `${ms.toFixed(2)}ms`;\n    return `${(ms / 1000).toFixed(2)}s`;\n  }\n}",
              "lineStart": 142,
              "lineEnd": 155
            }
          ]
        },
        {
          "additions": 299,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/QuoteStateComparisonTest.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/QuoteStateComparisonTest.ts b/apps/virtual-exchange/src/quote/benchmark/QuoteStateComparisonTest.ts\nnew file mode 100644\nindex 000000000..1d9c11444\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/QuoteStateComparisonTest.ts\n@@ -0,0 +1,299 @@\n+import { IQuoteState } from '../types';\n+import { PerformanceTester } from './PerformanceTester';\n+import { QuoteStateTestRunner } from './QuoteStateTestRunner';\n+\n+/**\n+ * 行情状态对比测试类\n+ * 用于比较两个不同的 IQuoteState 实现\n+ */\n+export class QuoteStateComparisonTest {\n+  private runnerA: QuoteStateTestRunner;\n+  private runnerB: QuoteStateTestRunner;\n+  private nameA: string;\n+  private nameB: string;\n+\n+  constructor(\n+    createStateA: () => IQuoteState,\n+    createStateB: () => IQuoteState,\n+    nameA: string = '实现A',\n+    nameB: string = '实现B',\n+  ) {\n+    this.runnerA = new QuoteStateTestRunner(createStateA);\n+    this.runnerB = new QuoteStateTestRunner(createStateB);\n+    this.nameA = nameA;\n+    this.nameB = nameB;\n+  }\n+\n+  /**\n+   * 打印对比结果\n+   */\n+  private printComparisonResults(\n+    resultsA: any[],\n+    resultsB: any[],\n+    testType: string,\n+    key: string = 'time',\n+  ): void {\n+    console.log('\\n' + '='.repeat(100));\n+    console.log(`行情状态性能对比测试 - ${testType}`);\n+    console.log('='.repeat(100));\n+\n+    console.log(`\\n${this.nameA} vs ${this.nameB} 性能对比:`);\n+    console.log('-'.repeat(80));\n+\n+    for (let i = 0; i < Math.min(resultsA.length, resultsB.length); i++) {\n+      const resultA = resultsA[i];\n+      const resultB = resultsB[i];\n+\n+      // 检查是否有失败的测试\n+      const isAFailed = resultA.success === false;\n+      const isBFailed = resultB.success === false;\n+\n+      if (isAFailed || isBFailed) {\n+        console.log(`\\n产品数量: ${resultA.productCount || resultB.productCount}`);\n+\n+        if (isAFailed) {\n+          console.log(`❌ ${this.nameA} 测试失败: ${resultA.error || 'Unknown error'}`);\n+        } else {\n+          console.log(`${this.nameA}: ${PerformanceTester.formatTime(resultA.avgTime || resultA.time)}`);\n+        }\n+\n+        if (isBFailed) {\n+          console.log(`❌ ${this.nameB} 测试失败: ${resultB.error || 'Unknown error'}`);\n+        } else {\n+          console.log(`${this.nameB}: ${PerformanceTester.formatTime(resultB.avgTime || resultB.time)}`);\n+        }\n+\n+        console.log('-'.repeat(80));\n+        continue;\n+      }\n+\n+      if (resultA.productCount !== resultB.productCount) {\n+        console.log(`\\n⚠️ 产品数量不匹配: ${resultA.productCount} vs ${resultB.productCount}`);\n+        continue;\n+      }\n+\n+      console.log(`\\n产品数量: ${resultA.productCount.toLocaleString()}`);\n+\n+      // 自动检测使用哪个时间字段\n+      const timeKey = resultA.avgTime !== undefined ? 'avgTime' : 'time';\n+      const valueA = resultA[timeKey];\n+      const valueB = resultB[timeKey];\n+\n+      const timeLabel = timeKey === 'avgTime' ? '平均时间' : '时间';\n+      console.log(`${this.nameA} (${timeLabel}): ${PerformanceTester.formatTime(valueA)}`);\n+      console.log(`${this.nameB} (${timeLabel}): ${PerformanceTester.formatTime(valueB)}`);\n+\n+      if (valueA > 0 && valueB > 0) {\n+        const ratio = valueA / valueB;\n+        const percentDiff = ((ratio - 1) * 100).toFixed(2);\n+        if (ratio > 1) {\n+          console.log(`${this.nameB} 快 ${percentDiff}% (${ratio.toFixed(2)}x)`);\n+        } else {\n+          console.log(\n+            `${this.nameA} 快 ${(-parseFloat(percentDiff)).toFixed(2)}% (${(1 / ratio).toFixed(2)}x)`,\n+          );\n+        }\n+      }\n+\n+      // 处理新的内存数据结构（heapUsedDiff）和旧的数据结构（memoryBefore/memoryAfter）\n+      let memoryUsedA: number | null = null;\n+      let memoryUsedB: number | null = null;\n+\n+      if (resultA.heapUsedDiff !== undefined && resultA.heapUsedDiff !== null) {\n+        memoryUsedA = resultA.heapUsedDiff;\n+      } else if (resultA.memoryBefore && resultA.memoryAfter) {\n+        memoryUsedA = resultA.memoryAfter.heapUsed - resultA.memoryBefore.heapUsed;\n+      }\n+\n+      if (resultB.heapUsedDiff !== undefined && resultB.heapUsedDiff !== null) {\n+        memoryUsedB = resultB.heapUsedDiff;\n+      } else if (resultB.memoryBefore && resultB.memoryAfter) {\n+        memoryUsedB = resultB.memoryAfter.heapUsed - resultB.memoryBefore.heapUsed;\n+      }\n+\n+      // 打印内存使用（即使只有一个实现有数据）\n+      const hasMemoryA = memoryUsedA !== null && !isNaN(memoryUsedA);\n+      const hasMemoryB = memoryUsedB !== null && !isNaN(memoryUsedB);\n+\n+      if (hasMemoryA || hasMemoryB) {\n+        console.log(`\\n内存使用:`);\n+        if (hasMemoryA) {\n+          console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA!)}`);\n+        }\n+        if (hasMemoryB) {\n+          console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB!)}`);\n+        }\n+\n+        // 只有当两个实现都有有效内存数据时才进行对比\n+        if (hasMemoryA && hasMemoryB && memoryUsedA! > 0 && memoryUsedB! > 0) {\n+          const memoryRatio = memoryUsedA! / memoryUsedB!;\n+          const memoryPercentDiff = ((memoryRatio - 1) * 100).toFixed(2);\n+          if (memoryRatio > 1) {\n+            console.log(`${this.nameB} 节省 ${memoryPercentDiff}% 内存`);\n+          } else {\n+            console.log(`${this.nameA} 节省 ${(-parseFloat(memoryPercentDiff)).toFixed(2)}% 内存`);\n+          }\n+        }\n+      }\n+\n+      console.log('-'.repeat(80));\n+    }\n+  }\n+\n+  /**\n+   * 运行完整的对比测试套件\n+   */\n+  async runComparisonTestSuite(): Promise<void> {\n+    console.log(`开始行情状态性能对比测试: ${this.nameA} vs ${this.nameB}`);\n+\n+    const testScenarios = [\n+      {\n+        productCount: 10000,\n+        label: '10K',\n+        updateIterations: 1000,\n+        queryIterations: 10000,\n+        filterIterations: 1000,\n+      },\n+      {\n+        productCount: 100000,\n+        label: '100K',\n+        updateIterations: 100,\n+        queryIterations: 1000,\n+        filterIterations: 100,\n+      },\n+      {\n+        productCount: 1000000,\n+        label: '1M',\n+        updateIterations: 10,\n+        queryIterations: 100,\n+        filterIterations: 10,\n+      },\n+    ];\n+\n+    // 初始化测试对比\n+    console.log('\\n运行初始化测试对比...');\n+    const initResultsA = [];\n+    const initResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        // 使用3次迭代取平均值，减少随机性\n+        const resultA = await this.runnerA.runInitializationTest(scenario.productCount, 3);\n+        const resultB = await this.runnerB.runInitializationTest(scenario.productCount, 3);\n+        initResultsA.push(resultA);\n+        initResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(initResultsA, initResultsB, '初始化测试');\n+\n+    // 更新测试对比\n+    console.log('\\n运行更新测试对比...');\n+    const updateResultsA = [];\n+    const updateResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const resultA = await this.runnerA.runUpdateTest(scenario.productCount, scenario.updateIterations);\n+        const resultB = await this.runnerB.runUpdateTest(scenario.productCount, scenario.updateIterations);\n+        updateResultsA.push(resultA);\n+        updateResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`更新对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(updateResultsA, updateResultsB, '更新测试');\n+\n+    // 查询测试对比\n+    console.log('\\n运行查询测试对比...');\n+    const queryResultsA = [];\n+    const queryResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const resultA = await this.runnerA.runQueryTest(scenario.productCount, scenario.queryIterations);\n+        const resultB = await this.runnerB.runQueryTest(scenario.productCount, scenario.queryIterations);\n+        queryResultsA.push(resultA);\n+        queryResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`查询对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(queryResultsA, queryResultsB, '查询测试');\n+\n+    // 过滤测试对比\n+    console.log('\\n运行过滤测试对比...');\n+    const filterResultsA = [];\n+    const filterResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const resultA = await this.runnerA.runFilterTest(scenario.productCount, scenario.filterIterations);\n+        const resultB = await this.runnerB.runFilterTest(scenario.productCount, scenario.filterIterations);\n+        filterResultsA.push(resultA);\n+        filterResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`过滤对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(filterResultsA, filterResultsB, '过滤测试');\n+\n+    // 转储测试对比\n+    console.log('\\n运行转储测试对比...');\n+    const dumpResultsA = [];\n+    const dumpResultsB = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const resultA = await this.runnerA.runDumpTest(scenario.productCount);\n+        const resultB = await this.runnerB.runDumpTest(scenario.productCount);\n+        dumpResultsA.push(resultA);\n+        dumpResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`转储对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(dumpResultsA, dumpResultsB, '转储测试');\n+\n+    console.log('\\n对比测试完成!');\n+  }\n+\n+  /**\n+   * 运行快速对比测试（仅测试小数据量）\n+   */\n+  async runQuickComparisonTest(): Promise<void> {\n+    console.log(`开始快速对比测试: ${this.nameA} vs ${this.nameB}`);\n+\n+    const quickScenarios = [\n+      {\n+        productCount: 1000,\n+        label: '1K',\n+        updateIterations: 100,\n+        queryIterations: 1000,\n+        filterIterations: 100,\n+      },\n+      { productCount: 10000, label: '10K', updateIterations: 10, queryIterations: 100, filterIterations: 10 },\n+    ];\n+\n+    // 初始化测试对比\n+    console.log('\\n运行初始化测试对比...');\n+    const initResultsA = [];\n+    const initResultsB = [];\n+    for (const scenario of quickScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        // 使用2次迭代取平均值（快速测试）\n+        const resultA = await this.runnerA.runInitializationTest(scenario.productCount, 2);\n+        const resultB = await this.runnerB.runInitializationTest(scenario.productCount, 2);\n+        initResultsA.push(resultA);\n+        initResultsB.push(resultB);\n+      } catch (error) {\n+        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printComparisonResults(initResultsA, initResultsB, '快速初始化测试');\n+\n+    console.log('\\n快速对比测试完成!');\n+  }\n+}\n",
          "codeSnippets": [
            {
              "type": "class",
              "name": "QuoteStateComparisonTest",
              "code": "export class QuoteStateComparisonTest {\n  private runnerA: QuoteStateTestRunner;\n  private runnerB: QuoteStateTestRunner;\n  private nameA: string;\n  private nameB: string;\n\n  constructor(\n    createStateA: () => IQuoteState,\n    createStateB: () => IQuoteState,\n    nameA: string = '实现A',\n    nameB: string = '实现B',\n  ) {\n    this.runnerA = new QuoteStateTestRunner(createStateA);\n    this.runnerB = new QuoteStateTestRunner(createStateB);\n    this.nameA = nameA;",
              "lineStart": 9,
              "lineEnd": 42
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < Math.min(resultsA.length, resultsB.length); i++) {",
              "lineStart": 43,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = resultsA[i];",
              "lineStart": 44,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "const resultB = resultsB[i];\n\n// 检查是否有失败的测试",
              "lineStart": 45,
              "lineEnd": 47
            },
            {
              "type": "function",
              "name": "isAFailed",
              "code": "const isAFailed = resultA.success === false;",
              "lineStart": 48,
              "lineEnd": 48
            },
            {
              "type": "function",
              "name": "isBFailed",
              "code": "const isBFailed = resultB.success === false;\n\nif (isAFailed || isBFailed) {\n  console.log(`\\n产品数量: ${resultA.productCount || resultB.productCount}`);\n\n  if (isAFailed) {\n    console.log(`❌ ${this.nameA} 测试失败: ${resultA.error || 'Unknown error'}`);\n  } else {\n    console.log(`${this.nameA}: ${PerformanceTester.formatTime(resultA.avgTime || resultA.time)}`);\n  }\n\n  if (isBFailed) {\n    console.log(`❌ ${this.nameB} 测试失败: ${resultB.error || 'Unknown error'}`);\n  } else {\n    console.log(`${this.nameB}: ${PerformanceTester.formatTime(resultB.avgTime || resultB.time)}`);",
              "lineStart": 49,
              "lineEnd": 77
            },
            {
              "type": "function",
              "name": "timeKey",
              "code": "const timeKey = resultA.avgTime !== undefined ? 'avgTime' : 'time';",
              "lineStart": 78,
              "lineEnd": 78
            },
            {
              "type": "function",
              "name": "valueA",
              "code": "const valueA = resultA[timeKey];",
              "lineStart": 79,
              "lineEnd": 79
            },
            {
              "type": "function",
              "name": "valueB",
              "code": "const valueB = resultB[timeKey];\n",
              "lineStart": 80,
              "lineEnd": 81
            },
            {
              "type": "function",
              "name": "timeLabel",
              "code": "const timeLabel = timeKey === 'avgTime' ? '平均时间' : '时间';\nconsole.log(`${this.nameA} (${timeLabel}): ${PerformanceTester.formatTime(valueA)}`);\nconsole.log(`${this.nameB} (${timeLabel}): ${PerformanceTester.formatTime(valueB)}`);\n\nif (valueA > 0 && valueB > 0) {",
              "lineStart": 82,
              "lineEnd": 86
            },
            {
              "type": "function",
              "name": "ratio",
              "code": "const ratio = valueA / valueB;",
              "lineStart": 87,
              "lineEnd": 87
            },
            {
              "type": "function",
              "name": "percentDiff",
              "code": "  const percentDiff = ((ratio - 1) * 100).toFixed(2);\n  if (ratio > 1) {\n    console.log(`${this.nameB} 快 ${percentDiff}% (${ratio.toFixed(2)}x)`);\n  } else {\n    console.log(\n      `${this.nameA} 快 ${(-parseFloat(percentDiff)).toFixed(2)}% (${(1 / ratio).toFixed(2)}x)`,\n    );\n  }\n}\n\n// 处理新的内存数据结构（heapUsedDiff）和旧的数据结构（memoryBefore/memoryAfter）",
              "lineStart": 88,
              "lineEnd": 98
            },
            {
              "type": "function",
              "name": "memoryUsedA",
              "code": "let memoryUsedA: number | null = null;",
              "lineStart": 99,
              "lineEnd": 99
            },
            {
              "type": "function",
              "name": "memoryUsedB",
              "code": "let memoryUsedB: number | null = null;\n\nif (resultA.heapUsedDiff !== undefined && resultA.heapUsedDiff !== null) {\n  memoryUsedA = resultA.heapUsedDiff;\n} else if (resultA.memoryBefore && resultA.memoryAfter) {\n  memoryUsedA = resultA.memoryAfter.heapUsed - resultA.memoryBefore.heapUsed;\n}\n\nif (resultB.heapUsedDiff !== undefined && resultB.heapUsedDiff !== null) {\n  memoryUsedB = resultB.heapUsedDiff;\n} else if (resultB.memoryBefore && resultB.memoryAfter) {\n  memoryUsedB = resultB.memoryAfter.heapUsed - resultB.memoryBefore.heapUsed;\n}\n\n// 打印内存使用（即使只有一个实现有数据）",
              "lineStart": 100,
              "lineEnd": 114
            },
            {
              "type": "function",
              "name": "hasMemoryA",
              "code": "const hasMemoryA = memoryUsedA !== null && !isNaN(memoryUsedA);",
              "lineStart": 115,
              "lineEnd": 115
            },
            {
              "type": "function",
              "name": "hasMemoryB",
              "code": "const hasMemoryB = memoryUsedB !== null && !isNaN(memoryUsedB);\n\nif (hasMemoryA || hasMemoryB) {\n  console.log(`\\n内存使用:`);\n  if (hasMemoryA) {\n    console.log(`${this.nameA}: ${PerformanceTester.formatBytes(memoryUsedA!)}`);\n  }\n  if (hasMemoryB) {\n    console.log(`${this.nameB}: ${PerformanceTester.formatBytes(memoryUsedB!)}`);\n  }\n\n  // 只有当两个实现都有有效内存数据时才进行对比\n  if (hasMemoryA && hasMemoryB && memoryUsedA! > 0 && memoryUsedB! > 0) {",
              "lineStart": 116,
              "lineEnd": 128
            },
            {
              "type": "function",
              "name": "memoryRatio",
              "code": "const memoryRatio = memoryUsedA! / memoryUsedB!;",
              "lineStart": 129,
              "lineEnd": 129
            },
            {
              "type": "function",
              "name": "memoryPercentDiff",
              "code": "        const memoryPercentDiff = ((memoryRatio - 1) * 100).toFixed(2);\n        if (memoryRatio > 1) {\n          console.log(`${this.nameB} 节省 ${memoryPercentDiff}% 内存`);\n        } else {\n          console.log(`${this.nameA} 节省 ${(-parseFloat(memoryPercentDiff)).toFixed(2)}% 内存`);\n        }\n      }\n    }\n\n    console.log('-'.repeat(80));\n  }\n}\n\n/**\n * 运行完整的对比测试套件",
              "lineStart": 130,
              "lineEnd": 148
            },
            {
              "type": "function",
              "name": "testScenarios",
              "code": "const testScenarios = [\n  {\n    productCount: 10000,\n    label: '10K',\n    updateIterations: 1000,\n    queryIterations: 10000,\n    filterIterations: 1000,\n  },\n  {\n    productCount: 100000,\n    label: '100K',\n    updateIterations: 100,\n    queryIterations: 1000,\n    filterIterations: 100,\n  },",
              "lineStart": 149,
              "lineEnd": 174
            },
            {
              "type": "function",
              "name": "initResultsA",
              "code": "const initResultsA = [];",
              "lineStart": 175,
              "lineEnd": 175
            },
            {
              "type": "function",
              "name": "initResultsB",
              "code": "const initResultsB = [];",
              "lineStart": 176,
              "lineEnd": 176
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    // 使用3次迭代取平均值，减少随机性",
              "lineStart": 177,
              "lineEnd": 180
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runInitializationTest(scenario.productCount, 3);",
              "lineStart": 181,
              "lineEnd": 181
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "    const resultB = await this.runnerB.runInitializationTest(scenario.productCount, 3);\n    initResultsA.push(resultA);\n    initResultsB.push(resultB);\n  } catch (error) {\n    console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(initResultsA, initResultsB, '初始化测试');\n\n// 更新测试对比\nconsole.log('\\n运行更新测试对比...');",
              "lineStart": 182,
              "lineEnd": 192
            },
            {
              "type": "function",
              "name": "updateResultsA",
              "code": "const updateResultsA = [];",
              "lineStart": 193,
              "lineEnd": 193
            },
            {
              "type": "function",
              "name": "updateResultsB",
              "code": "const updateResultsB = [];",
              "lineStart": 194,
              "lineEnd": 194
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 195,
              "lineEnd": 197
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runUpdateTest(scenario.productCount, scenario.updateIterations);",
              "lineStart": 198,
              "lineEnd": 198
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "    const resultB = await this.runnerB.runUpdateTest(scenario.productCount, scenario.updateIterations);\n    updateResultsA.push(resultA);\n    updateResultsB.push(resultB);\n  } catch (error) {\n    console.error(`更新对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(updateResultsA, updateResultsB, '更新测试');\n\n// 查询测试对比\nconsole.log('\\n运行查询测试对比...');",
              "lineStart": 199,
              "lineEnd": 209
            },
            {
              "type": "function",
              "name": "queryResultsA",
              "code": "const queryResultsA = [];",
              "lineStart": 210,
              "lineEnd": 210
            },
            {
              "type": "function",
              "name": "queryResultsB",
              "code": "const queryResultsB = [];",
              "lineStart": 211,
              "lineEnd": 211
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 212,
              "lineEnd": 214
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runQueryTest(scenario.productCount, scenario.queryIterations);",
              "lineStart": 215,
              "lineEnd": 215
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "    const resultB = await this.runnerB.runQueryTest(scenario.productCount, scenario.queryIterations);\n    queryResultsA.push(resultA);\n    queryResultsB.push(resultB);\n  } catch (error) {\n    console.error(`查询对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(queryResultsA, queryResultsB, '查询测试');\n\n// 过滤测试对比\nconsole.log('\\n运行过滤测试对比...');",
              "lineStart": 216,
              "lineEnd": 226
            },
            {
              "type": "function",
              "name": "filterResultsA",
              "code": "const filterResultsA = [];",
              "lineStart": 227,
              "lineEnd": 227
            },
            {
              "type": "function",
              "name": "filterResultsB",
              "code": "const filterResultsB = [];",
              "lineStart": 228,
              "lineEnd": 228
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 229,
              "lineEnd": 231
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runFilterTest(scenario.productCount, scenario.filterIterations);",
              "lineStart": 232,
              "lineEnd": 232
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "    const resultB = await this.runnerB.runFilterTest(scenario.productCount, scenario.filterIterations);\n    filterResultsA.push(resultA);\n    filterResultsB.push(resultB);\n  } catch (error) {\n    console.error(`过滤对比测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printComparisonResults(filterResultsA, filterResultsB, '过滤测试');\n\n// 转储测试对比\nconsole.log('\\n运行转储测试对比...');",
              "lineStart": 233,
              "lineEnd": 243
            },
            {
              "type": "function",
              "name": "dumpResultsA",
              "code": "const dumpResultsA = [];",
              "lineStart": 244,
              "lineEnd": 244
            },
            {
              "type": "function",
              "name": "dumpResultsB",
              "code": "const dumpResultsB = [];",
              "lineStart": 245,
              "lineEnd": 245
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 246,
              "lineEnd": 248
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runDumpTest(scenario.productCount);",
              "lineStart": 249,
              "lineEnd": 249
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "      const resultB = await this.runnerB.runDumpTest(scenario.productCount);\n      dumpResultsA.push(resultA);\n      dumpResultsB.push(resultB);\n    } catch (error) {\n      console.error(`转储对比测试失败 (${scenario.label}):`, error);\n    }\n  }\n  this.printComparisonResults(dumpResultsA, dumpResultsB, '转储测试');\n\n  console.log('\\n对比测试完成!');\n}\n\n/**\n * 运行快速对比测试（仅测试小数据量）\n */",
              "lineStart": 250,
              "lineEnd": 267
            },
            {
              "type": "function",
              "name": "quickScenarios",
              "code": "const quickScenarios = [\n  {\n    productCount: 1000,\n    label: '1K',\n    updateIterations: 100,\n    queryIterations: 1000,\n    filterIterations: 100,\n  },\n  { productCount: 10000, label: '10K', updateIterations: 10, queryIterations: 100, filterIterations: 10 },\n];\n\n// 初始化测试对比\nconsole.log('\\n运行初始化测试对比...');",
              "lineStart": 268,
              "lineEnd": 280
            },
            {
              "type": "function",
              "name": "initResultsA",
              "code": "const initResultsA = [];",
              "lineStart": 281,
              "lineEnd": 281
            },
            {
              "type": "function",
              "name": "initResultsB",
              "code": "const initResultsB = [];",
              "lineStart": 282,
              "lineEnd": 282
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of quickScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {\n    // 使用2次迭代取平均值（快速测试）",
              "lineStart": 283,
              "lineEnd": 286
            },
            {
              "type": "function",
              "name": "resultA",
              "code": "const resultA = await this.runnerA.runInitializationTest(scenario.productCount, 2);",
              "lineStart": 287,
              "lineEnd": 287
            },
            {
              "type": "function",
              "name": "resultB",
              "code": "        const resultB = await this.runnerB.runInitializationTest(scenario.productCount, 2);\n        initResultsA.push(resultA);\n        initResultsB.push(resultB);\n      } catch (error) {\n        console.error(`初始化对比测试失败 (${scenario.label}):`, error);\n      }\n    }\n    this.printComparisonResults(initResultsA, initResultsB, '快速初始化测试');\n\n    console.log('\\n快速对比测试完成!');\n  }\n}",
              "lineStart": 288,
              "lineEnd": 300
            }
          ]
        },
        {
          "additions": 392,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/QuoteStateTestRunner.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/QuoteStateTestRunner.ts b/apps/virtual-exchange/src/quote/benchmark/QuoteStateTestRunner.ts\nnew file mode 100644\nindex 000000000..f7ef7815f\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/QuoteStateTestRunner.ts\n@@ -0,0 +1,392 @@\n+import { IQuoteKey, IQuoteState, IQuoteUpdateAction } from '../types';\n+import { PerformanceTester } from './PerformanceTester';\n+import { generateTestData, generateProductId, getAllFields } from './test-helpers';\n+\n+/**\n+ * 通用的行情状态测试运行器\n+ * 接受一个工厂函数，用于创建 IQuoteState 实例\n+ */\n+export class QuoteStateTestRunner {\n+  private fields: IQuoteKey[];\n+  private createState: () => IQuoteState;\n+\n+  constructor(createState: () => IQuoteState) {\n+    this.createState = createState;\n+    this.fields = getAllFields();\n+  }\n+\n+  /**\n+   * 运行初始化性能测试\n+   */\n+  async runInitializationTest(\n+    productCount: number,\n+    iterations: number = 1,\n+  ): Promise<{\n+    productCount: number;\n+    avgTime: number;\n+    minTime: number;\n+    maxTime: number;\n+    times: number[];\n+    heapUsedDiff: number | null;\n+  }> {\n+    const testData = generateTestData(productCount, this.fields);\n+\n+    // 使用多次测量取平均值，减少随机性\n+    const stats = await PerformanceTester.measureTimeWithStats(() => {\n+      const state = this.createState();\n+      state.update(testData);\n+      return state;\n+    }, iterations);\n+\n+    // 单独测量内存使用（使用更精确的方法）\n+    const memoryResult = await PerformanceTester.measureMemoryUsage(() => {\n+      const state = this.createState();\n+      state.update(testData);\n+      return state;\n+    });\n+\n+    return {\n+      productCount,\n+      avgTime: stats.avgTime,\n+      minTime: stats.minTime,\n+      maxTime: stats.maxTime,\n+      times: stats.times,\n+      heapUsedDiff: memoryResult.heapUsedDiff,\n+    };\n+  }\n+\n+  /**\n+   * 运行更新性能测试\n+   */\n+  async runUpdateTest(\n+    productCount: number,\n+    updateCount: number,\n+  ): Promise<{\n+    productCount: number;\n+    updateCount: number;\n+    time: number;\n+  }> {\n+    // 创建初始状态\n+    const state = this.createState();\n+    const initialData = generateTestData(productCount, this.fields);\n+    state.update(initialData);\n+\n+    // 生成随机更新\n+    const updates: IQuoteUpdateAction[] = [];\n+    for (let i = 0; i < updateCount; i++) {\n+      const update: IQuoteUpdateAction = {};\n+      // 随机选择一些产品和字段进行更新\n+      const productIndex = Math.floor(Math.random() * productCount);\n+      const productId = generateProductId(productIndex);\n+      const fieldIndex = Math.floor(Math.random() * this.fields.length);\n+      const field = this.fields[fieldIndex];\n+\n+      update[productId] = {\n+        [field]: [(Math.random() * 1000).toFixed(4), Date.now()],\n+      };\n+      updates.push(update);\n+    }\n+\n+    const result = await PerformanceTester.measureTime(() => {\n+      for (const update of updates) {\n+        state.update(update);\n+      }\n+    });\n+\n+    return {\n+      productCount,\n+      updateCount,\n+      time: result.time,\n+    };\n+  }\n+\n+  /**\n+   * 运行查询性能测试\n+   */\n+  async runQueryTest(\n+    productCount: number,\n+    queryCount: number,\n+  ): Promise<{\n+    productCount: number;\n+    queryCount: number;\n+    time: number;\n+  }> {\n+    // 创建初始状态\n+    const state = this.createState();\n+    const initialData = generateTestData(productCount, this.fields);\n+    state.update(initialData);\n+\n+    const result = await PerformanceTester.measureTime(() => {\n+      for (let i = 0; i < queryCount; i++) {\n+        const productIndex = Math.floor(Math.random() * productCount);\n+        const productId = generateProductId(productIndex);\n+        const fieldIndex = Math.floor(Math.random() * this.fields.length);\n+        const field = this.fields[fieldIndex];\n+\n+        state.getValueTuple(productId, field);\n+      }\n+    });\n+\n+    return {\n+      productCount,\n+      queryCount,\n+      time: result.time,\n+    };\n+  }\n+\n+  /**\n+   * 运行过滤性能测试\n+   */\n+  async runFilterTest(\n+    productCount: number,\n+    filterCount: number,\n+  ): Promise<{\n+    productCount: number;\n+    filterCount: number;\n+    time: number;\n+  }> {\n+    // 创建初始状态\n+    const state = this.createState();\n+    const initialData = generateTestData(productCount, this.fields);\n+    state.update(initialData);\n+\n+    // 生成随机过滤条件\n+    const filters: { productIds: string[]; fields: IQuoteKey[]; updatedAt: number }[] = [];\n+    for (let i = 0; i < filterCount; i++) {\n+      // 随机选择1-10个产品\n+      const productIdsCount = Math.min(10, Math.max(1, Math.floor(Math.random() * productCount)));\n+      const productIds: string[] = [];\n+      for (let j = 0; j < productIdsCount; j++) {\n+        const productIndex = Math.floor(Math.random() * productCount);\n+        productIds.push(generateProductId(productIndex));\n+      }\n+\n+      // 随机选择1-5个字段\n+      const fieldsCount = Math.min(5, Math.max(1, Math.floor(Math.random() * this.fields.length)));\n+      const fields: IQuoteKey[] = [];\n+      for (let j = 0; j < fieldsCount; j++) {\n+        const fieldIndex = Math.floor(Math.random() * this.fields.length);\n+        fields.push(this.fields[fieldIndex]);\n+      }\n+\n+      filters.push({\n+        productIds,\n+        fields,\n+        updatedAt: Date.now() - Math.random() * 1000000,\n+      });\n+    }\n+\n+    const result = await PerformanceTester.measureTime(() => {\n+      for (const filter of filters) {\n+        state.filter(filter.productIds, filter.fields, filter.updatedAt);\n+      }\n+    });\n+\n+    return {\n+      productCount,\n+      filterCount,\n+      time: result.time,\n+    };\n+  }\n+\n+  /**\n+   * 运行转储性能测试\n+   */\n+  async runDumpTest(productCount: number): Promise<{\n+    productCount: number;\n+    time: number;\n+  }> {\n+    // 创建初始状态\n+    const state = this.createState();\n+    const initialData = generateTestData(productCount, this.fields);\n+    state.update(initialData);\n+\n+    const result = await PerformanceTester.measureTime(() => {\n+      state.dumpAsObject();\n+    });\n+\n+    return {\n+      productCount,\n+      time: result.time,\n+    };\n+  }\n+\n+  /**\n+   * 打印测试结果\n+   */\n+  printResults(results: any[], testType: string, implName?: string): void {\n+    const nameSuffix = implName ? ` - ${implName}` : '';\n+    console.log('\\n' + '='.repeat(100));\n+    console.log(`行情状态性能测试 - ${testType}${nameSuffix}`);\n+    console.log('='.repeat(100));\n+\n+    for (const result of results) {\n+      console.log(`\\n产品数量: ${result.productCount.toLocaleString()}`);\n+\n+      // 处理新的数据结构（avgTime）和旧的数据结构（time）\n+      const displayTime = result.avgTime !== undefined ? result.avgTime : result.time;\n+      const timeLabel = result.avgTime !== undefined ? '平均测试时间' : '测试时间';\n+\n+      console.log(`${timeLabel}: ${PerformanceTester.formatTime(displayTime)}`);\n+\n+      // 如果有多重测量结果，显示范围\n+      if (result.minTime !== undefined && result.maxTime !== undefined) {\n+        console.log(\n+          `时间范围: ${PerformanceTester.formatTime(result.minTime)} - ${PerformanceTester.formatTime(\n+            result.maxTime,\n+          )}`,\n+        );\n+      }\n+\n+      if (result.updateCount) {\n+        console.log(`更新次数: ${result.updateCount.toLocaleString()}`);\n+        console.log(`每次更新平均时间: ${PerformanceTester.formatTime(displayTime / result.updateCount)}`);\n+      }\n+\n+      if (result.queryCount) {\n+        console.log(`查询次数: ${result.queryCount.toLocaleString()}`);\n+        console.log(`每次查询平均时间: ${PerformanceTester.formatTime(displayTime / result.queryCount)}`);\n+      }\n+\n+      if (result.filterCount) {\n+        console.log(`过滤次数: ${result.filterCount.toLocaleString()}`);\n+        console.log(`每次过滤平均时间: ${PerformanceTester.formatTime(displayTime / result.filterCount)}`);\n+      }\n+\n+      // 处理新的内存数据结构（heapUsedDiff）和旧的数据结构（memoryBefore/memoryAfter）\n+      if (result.heapUsedDiff !== undefined && result.heapUsedDiff !== null) {\n+        const memoryUsed = result.heapUsedDiff;\n+        if (isNaN(memoryUsed)) {\n+          console.log(`内存计算错误: heapUsedDiff=${result.heapUsedDiff}`);\n+        } else {\n+          console.log(`内存使用: ${PerformanceTester.formatBytes(memoryUsed)}`);\n+          console.log(`每个产品内存使用: ${PerformanceTester.formatBytes(memoryUsed / result.productCount)}`);\n+        }\n+      } else if (\n+        result.memoryBefore &&\n+        result.memoryAfter &&\n+        result.memoryBefore.heapUsed !== undefined &&\n+        result.memoryAfter.heapUsed !== undefined\n+      ) {\n+        const memoryUsed = result.memoryAfter.heapUsed - result.memoryBefore.heapUsed;\n+        if (isNaN(memoryUsed)) {\n+          console.log(\n+            `内存计算错误: memoryBefore.heapUsed=${result.memoryBefore.heapUsed}, memoryAfter.heapUsed=${result.memoryAfter.heapUsed}`,\n+          );\n+        } else {\n+          console.log(`内存使用: ${PerformanceTester.formatBytes(memoryUsed)}`);\n+          console.log(`每个产品内存使用: ${PerformanceTester.formatBytes(memoryUsed / result.productCount)}`);\n+        }\n+      } else if (result.memoryBefore || result.memoryAfter) {\n+        console.log(\n+          `内存数据不完整: memoryBefore=${!!result.memoryBefore}, memoryAfter=${!!result.memoryAfter}`,\n+        );\n+      }\n+\n+      console.log('-'.repeat(80));\n+    }\n+  }\n+\n+  /**\n+   * 运行完整性能测试套件\n+   */\n+  async runFullTestSuite(implName?: string): Promise<void> {\n+    console.log(`开始行情状态性能测试${implName ? ' - ' + implName : ''}...`);\n+\n+    const testScenarios = [\n+      {\n+        productCount: 10000,\n+        label: '10K',\n+        updateIterations: 1000,\n+        queryIterations: 10000,\n+        filterIterations: 1000,\n+      },\n+      {\n+        productCount: 100000,\n+        label: '100K',\n+        updateIterations: 100,\n+        queryIterations: 1000,\n+        filterIterations: 100,\n+      },\n+      {\n+        productCount: 1000000,\n+        label: '1M',\n+        updateIterations: 10,\n+        queryIterations: 100,\n+        filterIterations: 10,\n+      },\n+    ];\n+\n+    // 初始化测试\n+    console.log('\\n运行初始化测试...');\n+    const initResults = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const result = await this.runInitializationTest(scenario.productCount, 3);\n+        initResults.push(result);\n+      } catch (error) {\n+        console.error(`初始化测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printResults(initResults, '初始化测试', implName);\n+\n+    // 更新测试\n+    console.log('\\n运行更新测试...');\n+    const updateResults = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const result = await this.runUpdateTest(scenario.productCount, scenario.updateIterations);\n+        updateResults.push(result);\n+      } catch (error) {\n+        console.error(`更新测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printResults(updateResults, '更新测试', implName);\n+\n+    // 查询测试\n+    console.log('\\n运行查询测试...');\n+    const queryResults = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const result = await this.runQueryTest(scenario.productCount, scenario.queryIterations);\n+        queryResults.push(result);\n+      } catch (error) {\n+        console.error(`查询测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printResults(queryResults, '查询测试', implName);\n+\n+    // 过滤测试\n+    console.log('\\n运行过滤测试...');\n+    const filterResults = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const result = await this.runFilterTest(scenario.productCount, scenario.filterIterations);\n+        filterResults.push(result);\n+      } catch (error) {\n+        console.error(`过滤测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printResults(filterResults, '过滤测试', implName);\n+\n+    // 转储测试\n+    console.log('\\n运行转储测试...');\n+    const dumpResults = [];\n+    for (const scenario of testScenarios) {\n+      console.log(`测试 ${scenario.label} 产品...`);\n+      try {\n+        const result = await this.runDumpTest(scenario.productCount);\n+        dumpResults.push(result);\n+      } catch (error) {\n+        console.error(`转储测试失败 (${scenario.label}):`, error);\n+      }\n+    }\n+    this.printResults(dumpResults, '转储测试', implName);\n+\n+    console.log('\\n性能测试完成!');\n+  }\n+}\n",
          "codeSnippets": [
            {
              "type": "class",
              "name": "QuoteStateTestRunner",
              "code": "export class QuoteStateTestRunner {\n  private fields: IQuoteKey[];\n  private createState: () => IQuoteState;\n\n  constructor(createState: () => IQuoteState) {\n    this.createState = createState;\n    this.fields = getAllFields();\n  }\n\n  /**\n   * 运行初始化性能测试\n   */\n  async runInitializationTest(\n    productCount: number,\n    iterations: number = 1,",
              "lineStart": 9,
              "lineEnd": 31
            },
            {
              "type": "function",
              "name": "testData",
              "code": "const testData = generateTestData(productCount, this.fields);\n\n// 使用多次测量取平均值，减少随机性",
              "lineStart": 32,
              "lineEnd": 34
            },
            {
              "type": "function",
              "name": "stats",
              "code": "const stats = await PerformanceTester.measureTimeWithStats(() => {",
              "lineStart": 35,
              "lineEnd": 35
            },
            {
              "type": "function",
              "name": "state",
              "code": "  const state = this.createState();\n  state.update(testData);\n  return state;\n}, iterations);\n\n// 单独测量内存使用（使用更精确的方法）",
              "lineStart": 36,
              "lineEnd": 41
            },
            {
              "type": "function",
              "name": "memoryResult",
              "code": "const memoryResult = await PerformanceTester.measureMemoryUsage(() => {",
              "lineStart": 42,
              "lineEnd": 42
            },
            {
              "type": "function",
              "name": "state",
              "code": "    const state = this.createState();\n    state.update(testData);\n    return state;\n  });\n\n  return {\n    productCount,\n    avgTime: stats.avgTime,\n    minTime: stats.minTime,\n    maxTime: stats.maxTime,\n    times: stats.times,\n    heapUsedDiff: memoryResult.heapUsedDiff,\n  };\n}\n",
              "lineStart": 43,
              "lineEnd": 69
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = this.createState();",
              "lineStart": 70,
              "lineEnd": 70
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, this.fields);\nstate.update(initialData);\n\n// 生成随机更新",
              "lineStart": 71,
              "lineEnd": 74
            },
            {
              "type": "function",
              "name": "updates",
              "code": "const updates: IQuoteUpdateAction[] = [];",
              "lineStart": 75,
              "lineEnd": 75
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < updateCount; i++) {",
              "lineStart": 76,
              "lineEnd": 76
            },
            {
              "type": "function",
              "name": "update",
              "code": "const update: IQuoteUpdateAction = {};\n// 随机选择一些产品和字段进行更新",
              "lineStart": 77,
              "lineEnd": 78
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(Math.random() * productCount);",
              "lineStart": 79,
              "lineEnd": 79
            },
            {
              "type": "function",
              "name": "productId",
              "code": "const productId = generateProductId(productIndex);",
              "lineStart": 80,
              "lineEnd": 80
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = Math.floor(Math.random() * this.fields.length);",
              "lineStart": 81,
              "lineEnd": 81
            },
            {
              "type": "function",
              "name": "field",
              "code": "  const field = this.fields[fieldIndex];\n\n  update[productId] = {\n    [field]: [(Math.random() * 1000).toFixed(4), Date.now()],\n  };\n  updates.push(update);\n}\n",
              "lineStart": 82,
              "lineEnd": 89
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await PerformanceTester.measureTime(() => {",
              "lineStart": 90,
              "lineEnd": 90
            },
            {
              "type": "function",
              "name": "update",
              "code": "    for (const update of updates) {\n      state.update(update);\n    }\n  });\n\n  return {\n    productCount,\n    updateCount,\n    time: result.time,\n  };\n}\n\n/**\n * 运行查询性能测试\n */",
              "lineStart": 91,
              "lineEnd": 114
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = this.createState();",
              "lineStart": 115,
              "lineEnd": 115
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, this.fields);\nstate.update(initialData);\n",
              "lineStart": 116,
              "lineEnd": 118
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await PerformanceTester.measureTime(() => {",
              "lineStart": 119,
              "lineEnd": 119
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < queryCount; i++) {",
              "lineStart": 120,
              "lineEnd": 120
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(Math.random() * productCount);",
              "lineStart": 121,
              "lineEnd": 121
            },
            {
              "type": "function",
              "name": "productId",
              "code": "const productId = generateProductId(productIndex);",
              "lineStart": 122,
              "lineEnd": 122
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = Math.floor(Math.random() * this.fields.length);",
              "lineStart": 123,
              "lineEnd": 123
            },
            {
              "type": "function",
              "name": "field",
              "code": "      const field = this.fields[fieldIndex];\n\n      state.getValueTuple(productId, field);\n    }\n  });\n\n  return {\n    productCount,\n    queryCount,\n    time: result.time,\n  };\n}\n\n/**\n * 运行过滤性能测试",
              "lineStart": 124,
              "lineEnd": 148
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = this.createState();",
              "lineStart": 149,
              "lineEnd": 149
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, this.fields);\nstate.update(initialData);\n\n// 生成随机过滤条件",
              "lineStart": 150,
              "lineEnd": 153
            },
            {
              "type": "function",
              "name": "filters",
              "code": "const filters: { productIds: string[]; fields: IQuoteKey[]; updatedAt: number }[] = [];",
              "lineStart": 154,
              "lineEnd": 154
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < filterCount; i++) {\n  // 随机选择1-10个产品",
              "lineStart": 155,
              "lineEnd": 156
            },
            {
              "type": "function",
              "name": "productIdsCount",
              "code": "const productIdsCount = Math.min(10, Math.max(1, Math.floor(Math.random() * productCount)));",
              "lineStart": 157,
              "lineEnd": 157
            },
            {
              "type": "function",
              "name": "productIds",
              "code": "const productIds: string[] = [];",
              "lineStart": 158,
              "lineEnd": 158
            },
            {
              "type": "function",
              "name": "j",
              "code": "for (let j = 0; j < productIdsCount; j++) {",
              "lineStart": 159,
              "lineEnd": 159
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "  const productIndex = Math.floor(Math.random() * productCount);\n  productIds.push(generateProductId(productIndex));\n}\n\n// 随机选择1-5个字段",
              "lineStart": 160,
              "lineEnd": 164
            },
            {
              "type": "function",
              "name": "fieldsCount",
              "code": "const fieldsCount = Math.min(5, Math.max(1, Math.floor(Math.random() * this.fields.length)));",
              "lineStart": 165,
              "lineEnd": 165
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields: IQuoteKey[] = [];",
              "lineStart": 166,
              "lineEnd": 166
            },
            {
              "type": "function",
              "name": "j",
              "code": "for (let j = 0; j < fieldsCount; j++) {",
              "lineStart": 167,
              "lineEnd": 167
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "    const fieldIndex = Math.floor(Math.random() * this.fields.length);\n    fields.push(this.fields[fieldIndex]);\n  }\n\n  filters.push({\n    productIds,\n    fields,\n    updatedAt: Date.now() - Math.random() * 1000000,\n  });\n}\n",
              "lineStart": 168,
              "lineEnd": 178
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result = await PerformanceTester.measureTime(() => {",
              "lineStart": 179,
              "lineEnd": 179
            },
            {
              "type": "function",
              "name": "filter",
              "code": "    for (const filter of filters) {\n      state.filter(filter.productIds, filter.fields, filter.updatedAt);\n    }\n  });\n\n  return {\n    productCount,\n    filterCount,\n    time: result.time,\n  };\n}\n\n/**\n * 运行转储性能测试\n */",
              "lineStart": 180,
              "lineEnd": 199
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = this.createState();",
              "lineStart": 200,
              "lineEnd": 200
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, this.fields);\nstate.update(initialData);\n",
              "lineStart": 201,
              "lineEnd": 203
            },
            {
              "type": "function",
              "name": "result",
              "code": "  const result = await PerformanceTester.measureTime(() => {\n    state.dumpAsObject();\n  });\n\n  return {\n    productCount,\n    time: result.time,\n  };\n}\n\n/**\n * 打印测试结果\n */\nprintResults(results: any[], testType: string, implName?: string): void {",
              "lineStart": 204,
              "lineEnd": 217
            },
            {
              "type": "function",
              "name": "nameSuffix",
              "code": "const nameSuffix = implName ? ` - ${implName}` : '';\nconsole.log('\\n' + '='.repeat(100));\nconsole.log(`行情状态性能测试 - ${testType}${nameSuffix}`);\nconsole.log('='.repeat(100));\n",
              "lineStart": 218,
              "lineEnd": 222
            },
            {
              "type": "function",
              "name": "result",
              "code": "for (const result of results) {\n  console.log(`\\n产品数量: ${result.productCount.toLocaleString()}`);\n\n  // 处理新的数据结构（avgTime）和旧的数据结构（time）",
              "lineStart": 223,
              "lineEnd": 226
            },
            {
              "type": "function",
              "name": "displayTime",
              "code": "const displayTime = result.avgTime !== undefined ? result.avgTime : result.time;",
              "lineStart": 227,
              "lineEnd": 227
            },
            {
              "type": "function",
              "name": "timeLabel",
              "code": "const timeLabel = result.avgTime !== undefined ? '平均测试时间' : '测试时间';\n\nconsole.log(`${timeLabel}: ${PerformanceTester.formatTime(displayTime)}`);\n\n// 如果有多重测量结果，显示范围\nif (result.minTime !== undefined && result.maxTime !== undefined) {\n  console.log(\n    `时间范围: ${PerformanceTester.formatTime(result.minTime)} - ${PerformanceTester.formatTime(\n      result.maxTime,\n    )}`,\n  );\n}\n\nif (result.updateCount) {\n  console.log(`更新次数: ${result.updateCount.toLocaleString()}`);",
              "lineStart": 228,
              "lineEnd": 257
            },
            {
              "type": "function",
              "name": "memoryUsed",
              "code": "  const memoryUsed = result.heapUsedDiff;\n  if (isNaN(memoryUsed)) {\n    console.log(`内存计算错误: heapUsedDiff=${result.heapUsedDiff}`);\n  } else {\n    console.log(`内存使用: ${PerformanceTester.formatBytes(memoryUsed)}`);\n    console.log(`每个产品内存使用: ${PerformanceTester.formatBytes(memoryUsed / result.productCount)}`);\n  }\n} else if (\n  result.memoryBefore &&\n  result.memoryAfter &&\n  result.memoryBefore.heapUsed !== undefined &&\n  result.memoryAfter.heapUsed !== undefined\n) {",
              "lineStart": 258,
              "lineEnd": 270
            },
            {
              "type": "function",
              "name": "memoryUsed",
              "code": "  const memoryUsed = result.memoryAfter.heapUsed - result.memoryBefore.heapUsed;\n  if (isNaN(memoryUsed)) {\n    console.log(\n      `内存计算错误: memoryBefore.heapUsed=${result.memoryBefore.heapUsed}, memoryAfter.heapUsed=${result.memoryAfter.heapUsed}`,\n    );\n  } else {\n    console.log(`内存使用: ${PerformanceTester.formatBytes(memoryUsed)}`);\n    console.log(`每个产品内存使用: ${PerformanceTester.formatBytes(memoryUsed / result.productCount)}`);\n  }\n} else if (result.memoryBefore || result.memoryAfter) {\n  console.log(\n    `内存数据不完整: memoryBefore=${!!result.memoryBefore}, memoryAfter=${!!result.memoryAfter}`,\n  );\n}\n",
              "lineStart": 271,
              "lineEnd": 295
            },
            {
              "type": "function",
              "name": "testScenarios",
              "code": "const testScenarios = [\n  {\n    productCount: 10000,\n    label: '10K',\n    updateIterations: 1000,\n    queryIterations: 10000,\n    filterIterations: 1000,\n  },\n  {\n    productCount: 100000,\n    label: '100K',\n    updateIterations: 100,\n    queryIterations: 1000,\n    filterIterations: 100,\n  },",
              "lineStart": 296,
              "lineEnd": 321
            },
            {
              "type": "function",
              "name": "initResults",
              "code": "const initResults = [];",
              "lineStart": 322,
              "lineEnd": 322
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 323,
              "lineEnd": 325
            },
            {
              "type": "function",
              "name": "result",
              "code": "    const result = await this.runInitializationTest(scenario.productCount, 3);\n    initResults.push(result);\n  } catch (error) {\n    console.error(`初始化测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printResults(initResults, '初始化测试', implName);\n\n// 更新测试\nconsole.log('\\n运行更新测试...');",
              "lineStart": 326,
              "lineEnd": 335
            },
            {
              "type": "function",
              "name": "updateResults",
              "code": "const updateResults = [];",
              "lineStart": 336,
              "lineEnd": 336
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 337,
              "lineEnd": 339
            },
            {
              "type": "function",
              "name": "result",
              "code": "    const result = await this.runUpdateTest(scenario.productCount, scenario.updateIterations);\n    updateResults.push(result);\n  } catch (error) {\n    console.error(`更新测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printResults(updateResults, '更新测试', implName);\n\n// 查询测试\nconsole.log('\\n运行查询测试...');",
              "lineStart": 340,
              "lineEnd": 349
            },
            {
              "type": "function",
              "name": "queryResults",
              "code": "const queryResults = [];",
              "lineStart": 350,
              "lineEnd": 350
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 351,
              "lineEnd": 353
            },
            {
              "type": "function",
              "name": "result",
              "code": "    const result = await this.runQueryTest(scenario.productCount, scenario.queryIterations);\n    queryResults.push(result);\n  } catch (error) {\n    console.error(`查询测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printResults(queryResults, '查询测试', implName);\n\n// 过滤测试\nconsole.log('\\n运行过滤测试...');",
              "lineStart": 354,
              "lineEnd": 363
            },
            {
              "type": "function",
              "name": "filterResults",
              "code": "const filterResults = [];",
              "lineStart": 364,
              "lineEnd": 364
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 365,
              "lineEnd": 367
            },
            {
              "type": "function",
              "name": "result",
              "code": "    const result = await this.runFilterTest(scenario.productCount, scenario.filterIterations);\n    filterResults.push(result);\n  } catch (error) {\n    console.error(`过滤测试失败 (${scenario.label}):`, error);\n  }\n}\nthis.printResults(filterResults, '过滤测试', implName);\n\n// 转储测试\nconsole.log('\\n运行转储测试...');",
              "lineStart": 368,
              "lineEnd": 377
            },
            {
              "type": "function",
              "name": "dumpResults",
              "code": "const dumpResults = [];",
              "lineStart": 378,
              "lineEnd": 378
            },
            {
              "type": "function",
              "name": "scenario",
              "code": "for (const scenario of testScenarios) {\n  console.log(`测试 ${scenario.label} 产品...`);\n  try {",
              "lineStart": 379,
              "lineEnd": 381
            },
            {
              "type": "function",
              "name": "result",
              "code": "        const result = await this.runDumpTest(scenario.productCount);\n        dumpResults.push(result);\n      } catch (error) {\n        console.error(`转储测试失败 (${scenario.label}):`, error);\n      }\n    }\n    this.printResults(dumpResults, '转储测试', implName);\n\n    console.log('\\n性能测试完成!');\n  }\n}",
              "lineStart": 382,
              "lineEnd": 393
            }
          ]
        },
        {
          "additions": 52,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/index.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/index.ts b/apps/virtual-exchange/src/quote/benchmark/index.ts\nnew file mode 100644\nindex 000000000..a3049b3d2\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/index.ts\n@@ -0,0 +1,52 @@\n+#!/usr/bin/env node\n+\n+import { ForkedQuoteStateComparisonTest } from './ForkedQuoteStateComparisonTest';\n+\n+// 导出性能测试工具类\n+export { PerformanceTester } from './PerformanceTester';\n+\n+// 导出测试辅助函数\n+export { generateProductId, generateTestData, getAllFields, randomString } from './test-helpers';\n+\n+// 导出测试运行器类\n+export { ForkedQuoteStateComparisonTest } from './ForkedQuoteStateComparisonTest';\n+export { QuoteStateComparisonTest } from './QuoteStateComparisonTest';\n+export { QuoteStateTestRunner } from './QuoteStateTestRunner';\n+\n+/**\n+ * 主函数 - 命令行入口点\n+ * 仅支持 --fork-compare 和 --fork-compare --quick 模式\n+ */\n+async function main() {\n+  const args = process.argv.slice(2);\n+\n+  // 检查是否使用正确的模式\n+  if (!args.includes('--fork-compare')) {\n+    console.log('使用方法:');\n+    console.log('  --fork-compare         运行完整的子进程隔离内存对比测试');\n+    console.log('  --fork-compare --quick 运行快速的子进程隔离内存对比测试');\n+    console.log('');\n+    console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n+    return;\n+  }\n+\n+  // 子进程隔离内存对比测试模式\n+  console.log('运行子进程隔离内存对比测试模式...');\n+  console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n+\n+  const forkedComparisonTest = new ForkedQuoteStateComparisonTest('Current', 'Baseline');\n+\n+  if (args.includes('--quick')) {\n+    await forkedComparisonTest.runQuickComparisonTest();\n+  } else {\n+    await forkedComparisonTest.runComparisonTestSuite();\n+  }\n+}\n+\n+// 如果直接运行此文件，则执行测试\n+if (require.main === module) {\n+  main().catch(console.error);\n+}\n+\n+// 导出主函数以供程序化使用\n+export { main as runBenchmark };\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "main",
              "code": "async function main() {",
              "lineStart": 20,
              "lineEnd": 20
            },
            {
              "type": "function",
              "name": "args",
              "code": "const args = process.argv.slice(2);\n\n// 检查是否使用正确的模式\nif (!args.includes('--fork-compare')) {\n  console.log('使用方法:');\n  console.log('  --fork-compare         运行完整的子进程隔离内存对比测试');\n  console.log('  --fork-compare --quick 运行快速的子进程隔离内存对比测试');\n  console.log('');\n  console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n  return;\n}\n\n// 子进程隔离内存对比测试模式\nconsole.log('运行子进程隔离内存对比测试模式...');\nconsole.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');",
              "lineStart": 21,
              "lineEnd": 36
            },
            {
              "type": "function",
              "name": "forkedComparisonTest",
              "code": "  const forkedComparisonTest = new ForkedQuoteStateComparisonTest('Current', 'Baseline');\n\n  if (args.includes('--quick')) {\n    await forkedComparisonTest.runQuickComparisonTest();\n  } else {\n    await forkedComparisonTest.runComparisonTestSuite();\n  }\n}\n\n// 如果直接运行此文件，则执行测试\nif (require.main === module) {\n  main().catch(console.error);\n}\n\n// 导出主函数以供程序化使用",
              "lineStart": 37,
              "lineEnd": 53
            }
          ]
        },
        {
          "additions": 71,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/test-helpers.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/test-helpers.ts b/apps/virtual-exchange/src/quote/benchmark/test-helpers.ts\nnew file mode 100644\nindex 000000000..2f24c0bb8\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/test-helpers.ts\n@@ -0,0 +1,71 @@\n+import { IQuoteKey, IQuoteUpdateAction } from '../types';\n+\n+/**\n+ * 生成随机字符串\n+ */\n+export function randomString(length: number): string {\n+  const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';\n+  let result = '';\n+  for (let i = 0; i < length; i++) {\n+    result += chars.charAt(Math.floor(Math.random() * chars.length));\n+  }\n+  return result;\n+}\n+\n+/**\n+ * 生成随机产品ID\n+ */\n+export function generateProductId(index: number): string {\n+  return `product_${index.toString().padStart(10, '0')}`;\n+}\n+\n+/**\n+ * 获取所有字段列表\n+ */\n+export function getAllFields(): IQuoteKey[] {\n+  // 从 state.ts 中的 FIELDS 数组获取\n+  return [\n+    'last_price',\n+    'ask_price',\n+    'ask_volume',\n+    'bid_volume',\n+    'bid_price',\n+    'interest_rate_short',\n+    'open_interest',\n+    'interest_rate_prev_settled_at',\n+    'interest_rate_next_settled_at',\n+    'interest_rate_long',\n+  ];\n+}\n+\n+/**\n+ * 生成测试数据\n+ */\n+export function generateTestData(productCount: number, fields: IQuoteKey[]): IQuoteUpdateAction {\n+  const data: IQuoteUpdateAction = {};\n+  const now = Date.now();\n+\n+  for (let i = 0; i < productCount; i++) {\n+    const productId = generateProductId(i);\n+    data[productId] = {};\n+\n+    // 为每个字段生成随机值\n+    for (const field of fields) {\n+      // 生成合适的随机值\n+      let value: string;\n+      if (field.includes('price') || field.includes('rate')) {\n+        value = (Math.random() * 1000).toFixed(4);\n+      } else if (field.includes('volume') || field.includes('interest')) {\n+        value = Math.floor(Math.random() * 10000).toString();\n+      } else if (field.includes('settled_at')) {\n+        value = (now + Math.random() * 1000000).toFixed(0);\n+      } else {\n+        value = randomString(10);\n+      }\n+\n+      data[productId]![field] = [value, now];\n+    }\n+  }\n+\n+  return data;\n+}\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "randomString",
              "code": "export function randomString(length: number): string {",
              "lineStart": 6,
              "lineEnd": 6
            },
            {
              "type": "function",
              "name": "chars",
              "code": "const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';",
              "lineStart": 7,
              "lineEnd": 7
            },
            {
              "type": "function",
              "name": "result",
              "code": "let result = '';",
              "lineStart": 8,
              "lineEnd": 8
            },
            {
              "type": "function",
              "name": "i",
              "code": "  for (let i = 0; i < length; i++) {\n    result += chars.charAt(Math.floor(Math.random() * chars.length));\n  }\n  return result;\n}\n\n/**\n * 生成随机产品ID\n */",
              "lineStart": 9,
              "lineEnd": 17
            },
            {
              "type": "function",
              "name": "generateProductId",
              "code": "export function generateProductId(index: number): string {\n  return `product_${index.toString().padStart(10, '0')}`;\n}\n\n/**\n * 获取所有字段列表\n */",
              "lineStart": 18,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "getAllFields",
              "code": "export function getAllFields(): IQuoteKey[] {\n  // 从 state.ts 中的 FIELDS 数组获取\n  return [\n    'last_price',\n    'ask_price',\n    'ask_volume',\n    'bid_volume',\n    'bid_price',\n    'interest_rate_short',\n    'open_interest',\n    'interest_rate_prev_settled_at',\n    'interest_rate_next_settled_at',\n    'interest_rate_long',\n  ];\n}",
              "lineStart": 25,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "generateTestData",
              "code": "export function generateTestData(productCount: number, fields: IQuoteKey[]): IQuoteUpdateAction {",
              "lineStart": 44,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data: IQuoteUpdateAction = {};",
              "lineStart": 45,
              "lineEnd": 45
            },
            {
              "type": "function",
              "name": "now",
              "code": "const now = Date.now();\n",
              "lineStart": 46,
              "lineEnd": 47
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < productCount; i++) {",
              "lineStart": 48,
              "lineEnd": 48
            },
            {
              "type": "function",
              "name": "productId",
              "code": "const productId = generateProductId(i);\ndata[productId] = {};\n\n// 为每个字段生成随机值",
              "lineStart": 49,
              "lineEnd": 52
            },
            {
              "type": "function",
              "name": "field",
              "code": "for (const field of fields) {\n  // 生成合适的随机值",
              "lineStart": 53,
              "lineEnd": 54
            },
            {
              "type": "function",
              "name": "value",
              "code": "    let value: string;\n    if (field.includes('price') || field.includes('rate')) {\n      value = (Math.random() * 1000).toFixed(4);\n    } else if (field.includes('volume') || field.includes('interest')) {\n      value = Math.floor(Math.random() * 10000).toString();\n    } else if (field.includes('settled_at')) {\n      value = (now + Math.random() * 1000000).toFixed(0);\n    } else {\n      value = randomString(10);\n    }\n\n    data[productId]![field] = [value, now];\n  }\n}\n",
              "lineStart": 55,
              "lineEnd": 72
            }
          ]
        },
        {
          "additions": 328,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/benchmark/worker.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/benchmark/worker.ts b/apps/virtual-exchange/src/quote/benchmark/worker.ts\nnew file mode 100644\nindex 000000000..936e43321\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/benchmark/worker.ts\n@@ -0,0 +1,328 @@\n+#!/usr/bin/env node\n+\n+import { performance } from 'perf_hooks';\n+import { implementations } from '../implementations';\n+import { IQuoteKey, IQuoteState } from '../types';\n+import { PerformanceTester } from './PerformanceTester';\n+import { generateProductId, generateTestData, getAllFields } from './test-helpers';\n+\n+/**\n+ * 子进程测试 Worker\n+ * 接收命令行参数，运行指定的测试，输出 JSON 结果到 stdout\n+ *\n+ * 命令行参数格式：\n+ * --impl=<implName>    // 实现名称：current 或 baseline\n+ * --test=<testType>    // 测试类型：init, update, query, filter, dump\n+ * --product-count=<N>  // 产品数量\n+ * --iterations=<N>     // 迭代次数（可选，某些测试需要）\n+ * --update-count=<N>   // 更新次数（update测试需要）\n+ * --query-count=<N>    // 查询次数（query测试需要）\n+ * --filter-count=<N>   // 过滤次数（filter测试需要）\n+ */\n+\n+// 解析命令行参数\n+function parseArgs(): Record<string, string> {\n+  const args = process.argv.slice(2);\n+  const result: Record<string, string> = {};\n+\n+  for (const arg of args) {\n+    if (arg.startsWith('--')) {\n+      const [key, value] = arg.slice(2).split('=');\n+      result[key] = value || 'true';\n+    }\n+  }\n+\n+  return result;\n+}\n+\n+// 运行初始化测试\n+async function runInitializationTest(\n+  createState: () => IQuoteState,\n+  productCount: number,\n+  iterations: number = 1,\n+) {\n+  const fields = getAllFields();\n+  const testData = generateTestData(productCount, fields);\n+\n+  const times: number[] = [];\n+  let finalResult: IQuoteState | undefined;\n+\n+  for (let i = 0; i < iterations; i++) {\n+    const start = performance.now();\n+    const state = createState();\n+    state.update(testData);\n+    const end = performance.now();\n+\n+    if (i === 0) finalResult = state;\n+    times.push(end - start);\n+  }\n+\n+  const avgTime = times.reduce((a, b) => a + b, 0) / times.length;\n+  const minTime = Math.min(...times);\n+  const maxTime = Math.max(...times);\n+\n+  // 单独测量内存使用\n+  const memoryResult = await PerformanceTester.measureMemoryUsage(() => {\n+    const state = createState();\n+    state.update(testData);\n+    return state;\n+  });\n+\n+  return {\n+    productCount,\n+    avgTime,\n+    minTime,\n+    maxTime,\n+    times,\n+    heapUsedDiff: memoryResult.heapUsedDiff,\n+  };\n+}\n+\n+// 运行更新测试\n+async function runUpdateTest(createState: () => IQuoteState, productCount: number, updateCount: number) {\n+  const fields = getAllFields();\n+  const state = createState();\n+  const initialData = generateTestData(productCount, fields);\n+  state.update(initialData);\n+\n+  // 生成随机更新\n+  const updates: Record<string, Partial<Record<IQuoteKey, [string, number]>>>[] = [];\n+  for (let i = 0; i < updateCount; i++) {\n+    const update: Record<string, Partial<Record<IQuoteKey, [string, number]>>> = {};\n+    const productIndex = Math.floor(Math.random() * productCount);\n+    const productId = generateProductId(productIndex);\n+    const fieldIndex = Math.floor(Math.random() * fields.length);\n+    const field = fields[fieldIndex];\n+\n+    update[productId] = {\n+      [field]: [(Math.random() * 1000).toFixed(4), Date.now()],\n+    };\n+    updates.push(update);\n+  }\n+\n+  const start = performance.now();\n+  for (const update of updates) {\n+    state.update(update);\n+  }\n+  const end = performance.now();\n+\n+  return {\n+    productCount,\n+    updateCount,\n+    time: end - start,\n+  };\n+}\n+\n+// 运行查询测试\n+async function runQueryTest(createState: () => IQuoteState, productCount: number, queryCount: number) {\n+  const fields = getAllFields();\n+  const state = createState();\n+  const initialData = generateTestData(productCount, fields);\n+  state.update(initialData);\n+\n+  const start = performance.now();\n+  for (let i = 0; i < queryCount; i++) {\n+    const productIndex = Math.floor(Math.random() * productCount);\n+    const productId = generateProductId(productIndex);\n+    const fieldIndex = Math.floor(Math.random() * fields.length);\n+    const field = fields[fieldIndex];\n+\n+    state.getValueTuple(productId, field);\n+  }\n+  const end = performance.now();\n+\n+  return {\n+    productCount,\n+    queryCount,\n+    time: end - start,\n+  };\n+}\n+\n+// 运行过滤测试\n+async function runFilterTest(createState: () => IQuoteState, productCount: number, filterCount: number) {\n+  const fields = getAllFields();\n+  const state = createState();\n+  const initialData = generateTestData(productCount, fields);\n+  state.update(initialData);\n+\n+  // 生成随机过滤条件\n+  const filters: { productIds: string[]; fields: IQuoteKey[]; updatedAt: number }[] = [];\n+  for (let i = 0; i < filterCount; i++) {\n+    const productIdsCount = Math.min(10, Math.max(1, Math.floor(Math.random() * productCount)));\n+    const productIds: string[] = [];\n+    for (let j = 0; j < productIdsCount; j++) {\n+      const productIndex = Math.floor(Math.random() * productCount);\n+      productIds.push(generateProductId(productIndex));\n+    }\n+\n+    const fieldsCount = Math.min(5, Math.max(1, Math.floor(Math.random() * fields.length)));\n+    const selectedFields: IQuoteKey[] = [];\n+    for (let j = 0; j < fieldsCount; j++) {\n+      const fieldIndex = Math.floor(Math.random() * fields.length);\n+      selectedFields.push(fields[fieldIndex]);\n+    }\n+\n+    filters.push({\n+      productIds,\n+      fields: selectedFields,\n+      updatedAt: Date.now() - Math.random() * 1000000,\n+    });\n+  }\n+\n+  const start = performance.now();\n+  for (const filter of filters) {\n+    state.filter(filter.productIds, filter.fields, filter.updatedAt);\n+  }\n+  const end = performance.now();\n+\n+  return {\n+    productCount,\n+    filterCount,\n+    time: end - start,\n+  };\n+}\n+\n+// 运行转储测试\n+async function runDumpTest(createState: () => IQuoteState, productCount: number) {\n+  const fields = getAllFields();\n+  const state = createState();\n+  const initialData = generateTestData(productCount, fields);\n+  state.update(initialData);\n+\n+  const start = performance.now();\n+  state.dumpAsObject();\n+  const end = performance.now();\n+\n+  return {\n+    productCount,\n+    time: end - start,\n+  };\n+}\n+\n+// 主函数\n+async function main() {\n+  const args = parseArgs();\n+\n+  // 验证必要参数\n+  if (!args.impl) {\n+    console.error(JSON.stringify({ error: 'Missing required parameter: --impl' }));\n+    process.exit(1);\n+  }\n+\n+  if (!args.test) {\n+    console.error(JSON.stringify({ error: 'Missing required parameter: --test' }));\n+    process.exit(1);\n+  }\n+\n+  if (!args['product-count']) {\n+    console.error(JSON.stringify({ error: 'Missing required parameter: --product-count' }));\n+    process.exit(1);\n+  }\n+\n+  const implName = args.impl;\n+  const testType = args.test;\n+  const productCount = parseInt(args['product-count'], 10);\n+\n+  // 选择实现\n+  let createState: () => IQuoteState;\n+  if (implName === 'current') {\n+    createState = implementations.current;\n+  } else if (implName === 'baseline') {\n+    createState = implementations.baseline;\n+  } else {\n+    console.error(JSON.stringify({ error: `Unknown implementation: ${implName}` }));\n+    process.exit(1);\n+  }\n+\n+  try {\n+    let result: any;\n+\n+    switch (testType) {\n+      case 'init':\n+        const iterations = args.iterations ? parseInt(args.iterations, 10) : 1;\n+        result = await runInitializationTest(createState, productCount, iterations);\n+        break;\n+\n+      case 'update':\n+        if (!args['update-count']) {\n+          console.error(\n+            JSON.stringify({ error: 'Missing required parameter: --update-count for update test' }),\n+          );\n+          process.exit(1);\n+        }\n+        const updateCount = parseInt(args['update-count'], 10);\n+        result = await runUpdateTest(createState, productCount, updateCount);\n+        break;\n+\n+      case 'query':\n+        if (!args['query-count']) {\n+          console.error(\n+            JSON.stringify({ error: 'Missing required parameter: --query-count for query test' }),\n+          );\n+          process.exit(1);\n+        }\n+        const queryCount = parseInt(args['query-count'], 10);\n+        result = await runQueryTest(createState, productCount, queryCount);\n+        break;\n+\n+      case 'filter':\n+        if (!args['filter-count']) {\n+          console.error(\n+            JSON.stringify({ error: 'Missing required parameter: --filter-count for filter test' }),\n+          );\n+          process.exit(1);\n+        }\n+        const filterCount = parseInt(args['filter-count'], 10);\n+        result = await runFilterTest(createState, productCount, filterCount);\n+        break;\n+\n+      case 'dump':\n+        result = await runDumpTest(createState, productCount);\n+        break;\n+\n+      default:\n+        console.error(JSON.stringify({ error: `Unknown test type: ${testType}` }));\n+        process.exit(1);\n+    }\n+\n+    // 输出 JSON 结果\n+    const output = {\n+      success: true,\n+      impl: implName,\n+      test: testType,\n+      productCount,\n+      ...result,\n+      timestamp: Date.now(),\n+    };\n+\n+    console.log(JSON.stringify(output, null, 2));\n+  } catch (error) {\n+    console.error(\n+      JSON.stringify({\n+        success: false,\n+        error: error instanceof Error ? error.message : String(error),\n+        impl: implName,\n+        test: testType,\n+        productCount,\n+        timestamp: Date.now(),\n+      }),\n+    );\n+    process.exit(1);\n+  }\n+}\n+\n+// 如果直接运行此文件，则执行测试\n+if (require.main === module) {\n+  main().catch((error) => {\n+    console.error(\n+      JSON.stringify({\n+        success: false,\n+        error: error instanceof Error ? error.message : String(error),\n+        timestamp: Date.now(),\n+      }),\n+    );\n+    process.exit(1);\n+  });\n+}\n+\n+export {};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "parseArgs",
              "code": "function parseArgs(): Record<string, string> {",
              "lineStart": 24,
              "lineEnd": 24
            },
            {
              "type": "function",
              "name": "args",
              "code": "const args = process.argv.slice(2);",
              "lineStart": 25,
              "lineEnd": 25
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: Record<string, string> = {};\n",
              "lineStart": 26,
              "lineEnd": 27
            },
            {
              "type": "function",
              "name": "arg",
              "code": "  for (const arg of args) {\n    if (arg.startsWith('--')) {\n      const [key, value] = arg.slice(2).split('=');\n      result[key] = value || 'true';\n    }\n  }\n\n  return result;\n}\n\n// 运行初始化测试",
              "lineStart": 28,
              "lineEnd": 38
            },
            {
              "type": "function",
              "name": "runInitializationTest",
              "code": "async function runInitializationTest(\n  createState: () => IQuoteState,\n  productCount: number,\n  iterations: number = 1,\n) {",
              "lineStart": 39,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = getAllFields();",
              "lineStart": 44,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "testData",
              "code": "const testData = generateTestData(productCount, fields);\n",
              "lineStart": 45,
              "lineEnd": 46
            },
            {
              "type": "function",
              "name": "times",
              "code": "const times: number[] = [];",
              "lineStart": 47,
              "lineEnd": 47
            },
            {
              "type": "function",
              "name": "finalResult",
              "code": "let finalResult: IQuoteState | undefined;\n",
              "lineStart": 48,
              "lineEnd": 49
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < iterations; i++) {",
              "lineStart": 50,
              "lineEnd": 50
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 51,
              "lineEnd": 51
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = createState();\nstate.update(testData);",
              "lineStart": 52,
              "lineEnd": 53
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  if (i === 0) finalResult = state;\n  times.push(end - start);\n}\n",
              "lineStart": 54,
              "lineEnd": 59
            },
            {
              "type": "function",
              "name": "avgTime",
              "code": "const avgTime = times.reduce((a, b) => a + b, 0) / times.length;",
              "lineStart": 60,
              "lineEnd": 60
            },
            {
              "type": "function",
              "name": "minTime",
              "code": "const minTime = Math.min(...times);",
              "lineStart": 61,
              "lineEnd": 61
            },
            {
              "type": "function",
              "name": "maxTime",
              "code": "const maxTime = Math.max(...times);\n\n// 单独测量内存使用",
              "lineStart": 62,
              "lineEnd": 64
            },
            {
              "type": "function",
              "name": "memoryResult",
              "code": "const memoryResult = await PerformanceTester.measureMemoryUsage(() => {",
              "lineStart": 65,
              "lineEnd": 65
            },
            {
              "type": "function",
              "name": "state",
              "code": "    const state = createState();\n    state.update(testData);\n    return state;\n  });\n\n  return {\n    productCount,\n    avgTime,\n    minTime,\n    maxTime,\n    times,\n    heapUsedDiff: memoryResult.heapUsedDiff,\n  };\n}\n",
              "lineStart": 66,
              "lineEnd": 81
            },
            {
              "type": "function",
              "name": "runUpdateTest",
              "code": "async function runUpdateTest(createState: () => IQuoteState, productCount: number, updateCount: number) {",
              "lineStart": 82,
              "lineEnd": 82
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = getAllFields();",
              "lineStart": 83,
              "lineEnd": 83
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = createState();",
              "lineStart": 84,
              "lineEnd": 84
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, fields);\nstate.update(initialData);\n\n// 生成随机更新",
              "lineStart": 85,
              "lineEnd": 88
            },
            {
              "type": "function",
              "name": "updates",
              "code": "const updates: Record<string, Partial<Record<IQuoteKey, [string, number]>>>[] = [];",
              "lineStart": 89,
              "lineEnd": 89
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < updateCount; i++) {",
              "lineStart": 90,
              "lineEnd": 90
            },
            {
              "type": "function",
              "name": "update",
              "code": "const update: Record<string, Partial<Record<IQuoteKey, [string, number]>>> = {};",
              "lineStart": 91,
              "lineEnd": 91
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(Math.random() * productCount);",
              "lineStart": 92,
              "lineEnd": 92
            },
            {
              "type": "function",
              "name": "productId",
              "code": "const productId = generateProductId(productIndex);",
              "lineStart": 93,
              "lineEnd": 93
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = Math.floor(Math.random() * fields.length);",
              "lineStart": 94,
              "lineEnd": 94
            },
            {
              "type": "function",
              "name": "field",
              "code": "  const field = fields[fieldIndex];\n\n  update[productId] = {\n    [field]: [(Math.random() * 1000).toFixed(4), Date.now()],\n  };\n  updates.push(update);\n}\n",
              "lineStart": 95,
              "lineEnd": 102
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 103,
              "lineEnd": 103
            },
            {
              "type": "function",
              "name": "update",
              "code": "for (const update of updates) {\n  state.update(update);\n}",
              "lineStart": 104,
              "lineEnd": 106
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  return {\n    productCount,\n    updateCount,\n    time: end - start,\n  };\n}\n\n// 运行查询测试",
              "lineStart": 107,
              "lineEnd": 116
            },
            {
              "type": "function",
              "name": "runQueryTest",
              "code": "async function runQueryTest(createState: () => IQuoteState, productCount: number, queryCount: number) {",
              "lineStart": 117,
              "lineEnd": 117
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = getAllFields();",
              "lineStart": 118,
              "lineEnd": 118
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = createState();",
              "lineStart": 119,
              "lineEnd": 119
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, fields);\nstate.update(initialData);\n",
              "lineStart": 120,
              "lineEnd": 122
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 123,
              "lineEnd": 123
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < queryCount; i++) {",
              "lineStart": 124,
              "lineEnd": 124
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(Math.random() * productCount);",
              "lineStart": 125,
              "lineEnd": 125
            },
            {
              "type": "function",
              "name": "productId",
              "code": "const productId = generateProductId(productIndex);",
              "lineStart": 126,
              "lineEnd": 126
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = Math.floor(Math.random() * fields.length);",
              "lineStart": 127,
              "lineEnd": 127
            },
            {
              "type": "function",
              "name": "field",
              "code": "  const field = fields[fieldIndex];\n\n  state.getValueTuple(productId, field);\n}",
              "lineStart": 128,
              "lineEnd": 131
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  return {\n    productCount,\n    queryCount,\n    time: end - start,\n  };\n}\n\n// 运行过滤测试",
              "lineStart": 132,
              "lineEnd": 141
            },
            {
              "type": "function",
              "name": "runFilterTest",
              "code": "async function runFilterTest(createState: () => IQuoteState, productCount: number, filterCount: number) {",
              "lineStart": 142,
              "lineEnd": 142
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = getAllFields();",
              "lineStart": 143,
              "lineEnd": 143
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = createState();",
              "lineStart": 144,
              "lineEnd": 144
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, fields);\nstate.update(initialData);\n\n// 生成随机过滤条件",
              "lineStart": 145,
              "lineEnd": 148
            },
            {
              "type": "function",
              "name": "filters",
              "code": "const filters: { productIds: string[]; fields: IQuoteKey[]; updatedAt: number }[] = [];",
              "lineStart": 149,
              "lineEnd": 149
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < filterCount; i++) {",
              "lineStart": 150,
              "lineEnd": 150
            },
            {
              "type": "function",
              "name": "productIdsCount",
              "code": "const productIdsCount = Math.min(10, Math.max(1, Math.floor(Math.random() * productCount)));",
              "lineStart": 151,
              "lineEnd": 151
            },
            {
              "type": "function",
              "name": "productIds",
              "code": "const productIds: string[] = [];",
              "lineStart": 152,
              "lineEnd": 152
            },
            {
              "type": "function",
              "name": "j",
              "code": "for (let j = 0; j < productIdsCount; j++) {",
              "lineStart": 153,
              "lineEnd": 153
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "  const productIndex = Math.floor(Math.random() * productCount);\n  productIds.push(generateProductId(productIndex));\n}\n",
              "lineStart": 154,
              "lineEnd": 157
            },
            {
              "type": "function",
              "name": "fieldsCount",
              "code": "const fieldsCount = Math.min(5, Math.max(1, Math.floor(Math.random() * fields.length)));",
              "lineStart": 158,
              "lineEnd": 158
            },
            {
              "type": "function",
              "name": "selectedFields",
              "code": "const selectedFields: IQuoteKey[] = [];",
              "lineStart": 159,
              "lineEnd": 159
            },
            {
              "type": "function",
              "name": "j",
              "code": "for (let j = 0; j < fieldsCount; j++) {",
              "lineStart": 160,
              "lineEnd": 160
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "    const fieldIndex = Math.floor(Math.random() * fields.length);\n    selectedFields.push(fields[fieldIndex]);\n  }\n\n  filters.push({\n    productIds,\n    fields: selectedFields,\n    updatedAt: Date.now() - Math.random() * 1000000,\n  });\n}\n",
              "lineStart": 161,
              "lineEnd": 171
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();",
              "lineStart": 172,
              "lineEnd": 172
            },
            {
              "type": "function",
              "name": "filter",
              "code": "for (const filter of filters) {\n  state.filter(filter.productIds, filter.fields, filter.updatedAt);\n}",
              "lineStart": 173,
              "lineEnd": 175
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  return {\n    productCount,\n    filterCount,\n    time: end - start,\n  };\n}\n\n// 运行转储测试",
              "lineStart": 176,
              "lineEnd": 185
            },
            {
              "type": "function",
              "name": "runDumpTest",
              "code": "async function runDumpTest(createState: () => IQuoteState, productCount: number) {",
              "lineStart": 186,
              "lineEnd": 186
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = getAllFields();",
              "lineStart": 187,
              "lineEnd": 187
            },
            {
              "type": "function",
              "name": "state",
              "code": "const state = createState();",
              "lineStart": 188,
              "lineEnd": 188
            },
            {
              "type": "function",
              "name": "initialData",
              "code": "const initialData = generateTestData(productCount, fields);\nstate.update(initialData);\n",
              "lineStart": 189,
              "lineEnd": 191
            },
            {
              "type": "function",
              "name": "start",
              "code": "const start = performance.now();\nstate.dumpAsObject();",
              "lineStart": 192,
              "lineEnd": 193
            },
            {
              "type": "function",
              "name": "end",
              "code": "  const end = performance.now();\n\n  return {\n    productCount,\n    time: end - start,\n  };\n}\n\n// 主函数",
              "lineStart": 194,
              "lineEnd": 202
            },
            {
              "type": "function",
              "name": "main",
              "code": "async function main() {",
              "lineStart": 203,
              "lineEnd": 203
            },
            {
              "type": "function",
              "name": "args",
              "code": "const args = parseArgs();\n\n// 验证必要参数\nif (!args.impl) {\n  console.error(JSON.stringify({ error: 'Missing required parameter: --impl' }));\n  process.exit(1);\n}\n\nif (!args.test) {\n  console.error(JSON.stringify({ error: 'Missing required parameter: --test' }));\n  process.exit(1);\n}\n\nif (!args['product-count']) {\n  console.error(JSON.stringify({ error: 'Missing required parameter: --product-count' }));",
              "lineStart": 204,
              "lineEnd": 221
            },
            {
              "type": "function",
              "name": "implName",
              "code": "const implName = args.impl;",
              "lineStart": 222,
              "lineEnd": 222
            },
            {
              "type": "function",
              "name": "testType",
              "code": "const testType = args.test;",
              "lineStart": 223,
              "lineEnd": 223
            },
            {
              "type": "function",
              "name": "productCount",
              "code": "const productCount = parseInt(args['product-count'], 10);\n\n// 选择实现",
              "lineStart": 224,
              "lineEnd": 226
            },
            {
              "type": "function",
              "name": "createState",
              "code": "let createState: () => IQuoteState;\nif (implName === 'current') {\n  createState = implementations.current;\n} else if (implName === 'baseline') {\n  createState = implementations.baseline;\n} else {\n  console.error(JSON.stringify({ error: `Unknown implementation: ${implName}` }));\n  process.exit(1);\n}\n\ntry {",
              "lineStart": 227,
              "lineEnd": 237
            },
            {
              "type": "function",
              "name": "result",
              "code": "let result: any;\n\nswitch (testType) {\n  case 'init':",
              "lineStart": 238,
              "lineEnd": 241
            },
            {
              "type": "function",
              "name": "iterations",
              "code": "  const iterations = args.iterations ? parseInt(args.iterations, 10) : 1;\n  result = await runInitializationTest(createState, productCount, iterations);\n  break;\n\ncase 'update':\n  if (!args['update-count']) {\n    console.error(\n      JSON.stringify({ error: 'Missing required parameter: --update-count for update test' }),\n    );\n    process.exit(1);\n  }",
              "lineStart": 242,
              "lineEnd": 252
            },
            {
              "type": "function",
              "name": "updateCount",
              "code": "  const updateCount = parseInt(args['update-count'], 10);\n  result = await runUpdateTest(createState, productCount, updateCount);\n  break;\n\ncase 'query':\n  if (!args['query-count']) {\n    console.error(\n      JSON.stringify({ error: 'Missing required parameter: --query-count for query test' }),\n    );\n    process.exit(1);\n  }",
              "lineStart": 253,
              "lineEnd": 263
            },
            {
              "type": "function",
              "name": "queryCount",
              "code": "  const queryCount = parseInt(args['query-count'], 10);\n  result = await runQueryTest(createState, productCount, queryCount);\n  break;\n\ncase 'filter':\n  if (!args['filter-count']) {\n    console.error(\n      JSON.stringify({ error: 'Missing required parameter: --filter-count for filter test' }),\n    );\n    process.exit(1);\n  }",
              "lineStart": 264,
              "lineEnd": 274
            },
            {
              "type": "function",
              "name": "filterCount",
              "code": "    const filterCount = parseInt(args['filter-count'], 10);\n    result = await runFilterTest(createState, productCount, filterCount);\n    break;\n\n  case 'dump':\n    result = await runDumpTest(createState, productCount);\n    break;\n\n  default:\n    console.error(JSON.stringify({ error: `Unknown test type: ${testType}` }));\n    process.exit(1);\n}\n\n// 输出 JSON 结果",
              "lineStart": 275,
              "lineEnd": 288
            },
            {
              "type": "function",
              "name": "output",
              "code": "  const output = {\n    success: true,\n    impl: implName,\n    test: testType,\n    productCount,\n    ...result,\n    timestamp: Date.now(),\n  };\n\n  console.log(JSON.stringify(output, null, 2));\n} catch (error) {\n  console.error(\n    JSON.stringify({\n      success: false,\n      error: error instanceof Error ? error.message : String(error),",
              "lineStart": 289,
              "lineEnd": 329
            }
          ]
        },
        {
          "additions": 7,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/implementations/index.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/implementations/index.ts b/apps/virtual-exchange/src/quote/implementations/index.ts\nnew file mode 100644\nindex 000000000..67c8ae544\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/implementations/index.ts\n@@ -0,0 +1,7 @@\n+import { createQuoteStateV0 } from './v0';\n+import { createQuoteStateV1 } from './v1';\n+\n+export const implementations = {\n+  baseline: createQuoteStateV0,\n+  current: createQuoteStateV1,\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "implementations",
              "code": "export const implementations = {\n  baseline: createQuoteStateV0,\n  current: createQuoteStateV1,\n};",
              "lineStart": 4,
              "lineEnd": 8
            }
          ]
        },
        {
          "additions": 71,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/implementations/v0.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/implementations/v0.ts b/apps/virtual-exchange/src/quote/implementations/v0.ts\nnew file mode 100644\nindex 000000000..8314ca665\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/implementations/v0.ts\n@@ -0,0 +1,71 @@\n+import { IQuoteKey, IQuoteState, IQuoteUpdateAction } from '../types';\n+\n+/**\n+ * 创建一个简单的基于 Map 的实现，用于对比测试\n+ * 这个实现使用嵌套 Map 结构，作为性能对比的基准\n+ */\n+export function createQuoteStateV0(): IQuoteState {\n+  // 使用三层嵌套结构：product_id -> field -> [value, updated_at]\n+  const data = new Map<string, Map<IQuoteKey, [string, number]>>();\n+\n+  const update = (action: IQuoteUpdateAction) => {\n+    for (const product_id in action) {\n+      let productMap = data.get(product_id);\n+      if (!productMap) {\n+        productMap = new Map();\n+        data.set(product_id, productMap);\n+      }\n+\n+      const fields = action[product_id];\n+      for (const field_name in fields) {\n+        const field = field_name as IQuoteKey;\n+        const [value, updated_at] = fields[field]!;\n+        const existing = productMap.get(field);\n+        if (!existing || updated_at >= existing[1]) {\n+          productMap.set(field, [value, updated_at]);\n+        }\n+      }\n+    }\n+  };\n+\n+  const dumpAsObject = (): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    data.forEach((productMap, product_id) => {\n+      const productData: Partial<Record<IQuoteKey, [string, number]>> = {};\n+      productMap.forEach((tuple, field) => {\n+        productData[field] = tuple;\n+      });\n+      result[product_id] = productData;\n+    });\n+    return result;\n+  };\n+\n+  const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {\n+    const productMap = data.get(product_id);\n+    if (!productMap) return undefined;\n+    return productMap.get(field);\n+  };\n+\n+  const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    for (const product_id of product_ids) {\n+      const productMap = data.get(product_id);\n+      if (!productMap) continue;\n+\n+      const productData: Partial<Record<IQuoteKey, [string, number]>> = {};\n+      for (const field of fields) {\n+        const tuple = productMap.get(field);\n+        if (tuple && tuple[1] >= updated_at) {\n+          productData[field] = tuple;\n+        }\n+      }\n+\n+      if (Object.keys(productData).length > 0) {\n+        result[product_id] = productData;\n+      }\n+    }\n+    return result;\n+  };\n+\n+  return { update, dumpAsObject, getValueTuple, filter };\n+}\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "createQuoteStateV0",
              "code": "export function createQuoteStateV0(): IQuoteState {\n  // 使用三层嵌套结构：product_id -> field -> [value, updated_at]",
              "lineStart": 7,
              "lineEnd": 8
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data = new Map<string, Map<IQuoteKey, [string, number]>>();\n",
              "lineStart": 9,
              "lineEnd": 10
            },
            {
              "type": "function",
              "name": "update",
              "code": "const update = (action: IQuoteUpdateAction) => {",
              "lineStart": 11,
              "lineEnd": 11
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id in action) {",
              "lineStart": 12,
              "lineEnd": 12
            },
            {
              "type": "function",
              "name": "productMap",
              "code": "let productMap = data.get(product_id);\nif (!productMap) {\n  productMap = new Map();\n  data.set(product_id, productMap);\n}\n",
              "lineStart": 13,
              "lineEnd": 18
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = action[product_id];",
              "lineStart": 19,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "field_name",
              "code": "for (const field_name in fields) {",
              "lineStart": 20,
              "lineEnd": 20
            },
            {
              "type": "function",
              "name": "field",
              "code": "const field = field_name as IQuoteKey;\nconst [value, updated_at] = fields[field]!;",
              "lineStart": 21,
              "lineEnd": 22
            },
            {
              "type": "function",
              "name": "existing",
              "code": "      const existing = productMap.get(field);\n      if (!existing || updated_at >= existing[1]) {\n        productMap.set(field, [value, updated_at]);\n      }\n    }\n  }\n};\n",
              "lineStart": 23,
              "lineEnd": 30
            },
            {
              "type": "function",
              "name": "dumpAsObject",
              "code": "const dumpAsObject = (): IQuoteUpdateAction => {",
              "lineStart": 31,
              "lineEnd": 31
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};\ndata.forEach((productMap, product_id) => {",
              "lineStart": 32,
              "lineEnd": 33
            },
            {
              "type": "function",
              "name": "productData",
              "code": "    const productData: Partial<Record<IQuoteKey, [string, number]>> = {};\n    productMap.forEach((tuple, field) => {\n      productData[field] = tuple;\n    });\n    result[product_id] = productData;\n  });\n  return result;\n};\n",
              "lineStart": 34,
              "lineEnd": 42
            },
            {
              "type": "function",
              "name": "getValueTuple",
              "code": "const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {",
              "lineStart": 43,
              "lineEnd": 43
            },
            {
              "type": "function",
              "name": "productMap",
              "code": "  const productMap = data.get(product_id);\n  if (!productMap) return undefined;\n  return productMap.get(field);\n};\n",
              "lineStart": 44,
              "lineEnd": 48
            },
            {
              "type": "function",
              "name": "filter",
              "code": "const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {",
              "lineStart": 49,
              "lineEnd": 49
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};",
              "lineStart": 50,
              "lineEnd": 50
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of product_ids) {",
              "lineStart": 51,
              "lineEnd": 51
            },
            {
              "type": "function",
              "name": "productMap",
              "code": "const productMap = data.get(product_id);\nif (!productMap) continue;\n",
              "lineStart": 52,
              "lineEnd": 54
            },
            {
              "type": "function",
              "name": "productData",
              "code": "const productData: Partial<Record<IQuoteKey, [string, number]>> = {};",
              "lineStart": 55,
              "lineEnd": 55
            },
            {
              "type": "function",
              "name": "field",
              "code": "for (const field of fields) {",
              "lineStart": 56,
              "lineEnd": 56
            },
            {
              "type": "function",
              "name": "tuple",
              "code": "        const tuple = productMap.get(field);\n        if (tuple && tuple[1] >= updated_at) {\n          productData[field] = tuple;\n        }\n      }\n\n      if (Object.keys(productData).length > 0) {\n        result[product_id] = productData;\n      }\n    }\n    return result;\n  };\n\n  return { update, dumpAsObject, getValueTuple, filter };\n}",
              "lineStart": 57,
              "lineEnd": 72
            }
          ]
        },
        {
          "additions": 116,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/implementations/v1.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/implementations/v1.ts b/apps/virtual-exchange/src/quote/implementations/v1.ts\nnew file mode 100644\nindex 000000000..1a9c48258\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/implementations/v1.ts\n@@ -0,0 +1,116 @@\n+import { newError } from '@yuants/utils';\n+import { IQuoteKey, IQuoteState, IQuoteUpdateAction } from '../types';\n+\n+// TRICK: 固定字段顺序，方便计算偏移量\n+const FIELDS = ((x: { [key in IQuoteKey]: number }) => Object.keys(x).sort() as IQuoteKey[])({\n+  // TS TRICK: 强制运行时数组具有 IQuoteKey 的所有字段。不重不漏，味道真是好极了\n+  last_price: 0,\n+  ask_price: 0,\n+  ask_volume: 0,\n+  bid_volume: 0,\n+  bid_price: 0,\n+  interest_rate_short: 0,\n+  open_interest: 0,\n+  interest_rate_prev_settled_at: 0,\n+  interest_rate_next_settled_at: 0,\n+  interest_rate_long: 0,\n+});\n+\n+const FIELD_COUNT = FIELDS.length;\n+const mapFieldNameToOffset = Object.fromEntries(FIELDS.map((field, index) => [field, index * 2]));\n+\n+/**\n+ * 高效的行情状态管理器\n+ * 内部使用扁平化数组存储数据，避免内存碎片化和过多的 Map/对象开销\n+ * 提供高效的读写接口，支持按需更新和查询\n+ */\n+export const createQuoteStateV1 = (): IQuoteState => {\n+  // 内部数据结构的设计需要考虑高效的读写性能，防止内存碎片化\n+  const data: (string | number)[] = [];\n+  const products: string[] = [];\n+  const mapProductIdToIndex = new Map<string, number>();\n+  // 0~20 (10 fields * 2 (value, updated_at))\n+  const getFieldOffset = (product_id: string, field: string): number => {\n+    let baseIndex = mapProductIdToIndex.get(product_id);\n+    if (baseIndex === undefined) {\n+      baseIndex = mapProductIdToIndex.size * FIELD_COUNT * 2;\n+      products.push(product_id);\n+      mapProductIdToIndex.set(product_id, baseIndex);\n+    }\n+    const fieldOffset = mapFieldNameToOffset[field];\n+    if (fieldOffset === undefined) throw newError('INVALID_FIELD_NAME', { field, available_fields: FIELDS });\n+    return baseIndex + fieldOffset;\n+  };\n+\n+  const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {\n+    const offset = getFieldOffset(product_id, field);\n+    const value = data[offset] as string;\n+    if (value === undefined) return undefined;\n+    const updated_at = data[offset + 1] as number;\n+    return [value, updated_at];\n+  };\n+\n+  const setValueTuple = (product_id: string, field: IQuoteKey, value: string, updated_at: number) => {\n+    const offset = getFieldOffset(product_id, field);\n+    data[offset] = value;\n+    data[offset + 1] = updated_at;\n+  };\n+\n+  const update = (action: IQuoteUpdateAction) => {\n+    for (const product_id in action) {\n+      const fields = action[product_id];\n+      for (const field_name in fields) {\n+        const field = field_name as IQuoteKey;\n+        const [value, updated_at] = fields[field]!;\n+        const oldTuple = getValueTuple(product_id, field);\n+        if (oldTuple === undefined || updated_at >= oldTuple[1]) {\n+          setValueTuple(product_id, field, value, updated_at);\n+        }\n+      }\n+    }\n+  };\n+\n+  const dumpAsObject = (): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    for (const product_id of products) {\n+      result[product_id] = {};\n+    }\n+    for (let i = 0; i < data.length; i += 2) {\n+      const value = data[i] as string;\n+      if (value === undefined) continue;\n+      const updated_at = data[i + 1] as number;\n+\n+      const productIndex = Math.floor(i / (FIELD_COUNT * 2));\n+      const product_id = products[productIndex];\n+\n+      const fieldIndex = (i % (FIELD_COUNT * 2)) / 2;\n+      const field_name = FIELDS[fieldIndex];\n+\n+      result[product_id][field_name] = [value, updated_at];\n+    }\n+    return result;\n+  };\n+\n+  /**\n+   * 过滤状态，返回指定 product_id 列表和字段列表中，且更新时间不早于指定时间的字段数据\n+   * @param product_ids - 需要过滤的 product_id 列表\n+   * @param fields - 需要过滤的字段列表\n+   * @param updated_at - 需要过滤的更新时间阈值 (仅返回更新时间不早于该值的字段)\n+   * @returns 过滤后的数据\n+   */\n+  const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {\n+    const result: IQuoteUpdateAction = {};\n+    for (const product_id of product_ids) {\n+      result[product_id] = {};\n+      for (const field of fields) {\n+        const tuple = getValueTuple(product_id, field);\n+        if (tuple && tuple[1] >= updated_at) {\n+          result[product_id]![field] = tuple;\n+        }\n+      }\n+    }\n+    return result;\n+  };\n+\n+  return { update, dumpAsObject, getValueTuple, filter };\n+};\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "FIELDS",
              "code": "const FIELDS = ((x: { [key in IQuoteKey]: number }) => Object.keys(x).sort() as IQuoteKey[])({\n  // TS TRICK: 强制运行时数组具有 IQuoteKey 的所有字段。不重不漏，味道真是好极了\n  last_price: 0,\n  ask_price: 0,\n  ask_volume: 0,\n  bid_volume: 0,\n  bid_price: 0,\n  interest_rate_short: 0,\n  open_interest: 0,\n  interest_rate_prev_settled_at: 0,\n  interest_rate_next_settled_at: 0,\n  interest_rate_long: 0,\n});\n",
              "lineStart": 5,
              "lineEnd": 18
            },
            {
              "type": "function",
              "name": "FIELD_COUNT",
              "code": "const FIELD_COUNT = FIELDS.length;",
              "lineStart": 19,
              "lineEnd": 19
            },
            {
              "type": "function",
              "name": "mapFieldNameToOffset",
              "code": "const mapFieldNameToOffset = Object.fromEntries(FIELDS.map((field, index) => [field, index * 2]));\n\n/**\n * 高效的行情状态管理器\n * 内部使用扁平化数组存储数据，避免内存碎片化和过多的 Map/对象开销\n * 提供高效的读写接口，支持按需更新和查询\n */",
              "lineStart": 20,
              "lineEnd": 26
            },
            {
              "type": "function",
              "name": "createQuoteStateV1",
              "code": "export const createQuoteStateV1 = (): IQuoteState => {\n  // 内部数据结构的设计需要考虑高效的读写性能，防止内存碎片化",
              "lineStart": 27,
              "lineEnd": 28
            },
            {
              "type": "function",
              "name": "data",
              "code": "const data: (string | number)[] = [];",
              "lineStart": 29,
              "lineEnd": 29
            },
            {
              "type": "function",
              "name": "products",
              "code": "const products: string[] = [];",
              "lineStart": 30,
              "lineEnd": 30
            },
            {
              "type": "function",
              "name": "mapProductIdToIndex",
              "code": "const mapProductIdToIndex = new Map<string, number>();\n// 0~20 (10 fields * 2 (value, updated_at))",
              "lineStart": 31,
              "lineEnd": 32
            },
            {
              "type": "function",
              "name": "getFieldOffset",
              "code": "const getFieldOffset = (product_id: string, field: string): number => {",
              "lineStart": 33,
              "lineEnd": 33
            },
            {
              "type": "function",
              "name": "baseIndex",
              "code": "let baseIndex = mapProductIdToIndex.get(product_id);\nif (baseIndex === undefined) {\n  baseIndex = mapProductIdToIndex.size * FIELD_COUNT * 2;\n  products.push(product_id);\n  mapProductIdToIndex.set(product_id, baseIndex);\n}",
              "lineStart": 34,
              "lineEnd": 39
            },
            {
              "type": "function",
              "name": "fieldOffset",
              "code": "  const fieldOffset = mapFieldNameToOffset[field];\n  if (fieldOffset === undefined) throw newError('INVALID_FIELD_NAME', { field, available_fields: FIELDS });\n  return baseIndex + fieldOffset;\n};\n",
              "lineStart": 40,
              "lineEnd": 44
            },
            {
              "type": "function",
              "name": "getValueTuple",
              "code": "const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {",
              "lineStart": 45,
              "lineEnd": 45
            },
            {
              "type": "function",
              "name": "offset",
              "code": "const offset = getFieldOffset(product_id, field);",
              "lineStart": 46,
              "lineEnd": 46
            },
            {
              "type": "function",
              "name": "value",
              "code": "const value = data[offset] as string;\nif (value === undefined) return undefined;",
              "lineStart": 47,
              "lineEnd": 48
            },
            {
              "type": "function",
              "name": "updated_at",
              "code": "  const updated_at = data[offset + 1] as number;\n  return [value, updated_at];\n};\n",
              "lineStart": 49,
              "lineEnd": 52
            },
            {
              "type": "function",
              "name": "setValueTuple",
              "code": "const setValueTuple = (product_id: string, field: IQuoteKey, value: string, updated_at: number) => {",
              "lineStart": 53,
              "lineEnd": 53
            },
            {
              "type": "function",
              "name": "offset",
              "code": "  const offset = getFieldOffset(product_id, field);\n  data[offset] = value;\n  data[offset + 1] = updated_at;\n};\n",
              "lineStart": 54,
              "lineEnd": 58
            },
            {
              "type": "function",
              "name": "update",
              "code": "const update = (action: IQuoteUpdateAction) => {",
              "lineStart": 59,
              "lineEnd": 59
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id in action) {",
              "lineStart": 60,
              "lineEnd": 60
            },
            {
              "type": "function",
              "name": "fields",
              "code": "const fields = action[product_id];",
              "lineStart": 61,
              "lineEnd": 61
            },
            {
              "type": "function",
              "name": "field_name",
              "code": "for (const field_name in fields) {",
              "lineStart": 62,
              "lineEnd": 62
            },
            {
              "type": "function",
              "name": "field",
              "code": "const field = field_name as IQuoteKey;\nconst [value, updated_at] = fields[field]!;",
              "lineStart": 63,
              "lineEnd": 64
            },
            {
              "type": "function",
              "name": "oldTuple",
              "code": "      const oldTuple = getValueTuple(product_id, field);\n      if (oldTuple === undefined || updated_at >= oldTuple[1]) {\n        setValueTuple(product_id, field, value, updated_at);\n      }\n    }\n  }\n};\n",
              "lineStart": 65,
              "lineEnd": 72
            },
            {
              "type": "function",
              "name": "dumpAsObject",
              "code": "const dumpAsObject = (): IQuoteUpdateAction => {",
              "lineStart": 73,
              "lineEnd": 73
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};",
              "lineStart": 74,
              "lineEnd": 74
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of products) {\n  result[product_id] = {};\n}",
              "lineStart": 75,
              "lineEnd": 77
            },
            {
              "type": "function",
              "name": "i",
              "code": "for (let i = 0; i < data.length; i += 2) {",
              "lineStart": 78,
              "lineEnd": 78
            },
            {
              "type": "function",
              "name": "value",
              "code": "const value = data[i] as string;\nif (value === undefined) continue;",
              "lineStart": 79,
              "lineEnd": 80
            },
            {
              "type": "function",
              "name": "updated_at",
              "code": "const updated_at = data[i + 1] as number;\n",
              "lineStart": 81,
              "lineEnd": 82
            },
            {
              "type": "function",
              "name": "productIndex",
              "code": "const productIndex = Math.floor(i / (FIELD_COUNT * 2));",
              "lineStart": 83,
              "lineEnd": 83
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "const product_id = products[productIndex];\n",
              "lineStart": 84,
              "lineEnd": 85
            },
            {
              "type": "function",
              "name": "fieldIndex",
              "code": "const fieldIndex = (i % (FIELD_COUNT * 2)) / 2;",
              "lineStart": 86,
              "lineEnd": 86
            },
            {
              "type": "function",
              "name": "field_name",
              "code": "    const field_name = FIELDS[fieldIndex];\n\n    result[product_id][field_name] = [value, updated_at];\n  }\n  return result;\n};\n\n/**\n * 过滤状态，返回指定 product_id 列表和字段列表中，且更新时间不早于指定时间的字段数据\n * @param product_ids - 需要过滤的 product_id 列表\n * @param fields - 需要过滤的字段列表\n * @param updated_at - 需要过滤的更新时间阈值 (仅返回更新时间不早于该值的字段)\n * @returns 过滤后的数据\n */",
              "lineStart": 87,
              "lineEnd": 100
            },
            {
              "type": "function",
              "name": "filter",
              "code": "const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {",
              "lineStart": 101,
              "lineEnd": 101
            },
            {
              "type": "function",
              "name": "result",
              "code": "const result: IQuoteUpdateAction = {};",
              "lineStart": 102,
              "lineEnd": 102
            },
            {
              "type": "function",
              "name": "product_id",
              "code": "for (const product_id of product_ids) {\n  result[product_id] = {};",
              "lineStart": 103,
              "lineEnd": 104
            },
            {
              "type": "function",
              "name": "field",
              "code": "for (const field of fields) {",
              "lineStart": 105,
              "lineEnd": 105
            },
            {
              "type": "function",
              "name": "tuple",
              "code": "        const tuple = getValueTuple(product_id, field);\n        if (tuple && tuple[1] >= updated_at) {\n          result[product_id]![field] = tuple;\n        }\n      }\n    }\n    return result;\n  };\n\n  return { update, dumpAsObject, getValueTuple, filter };\n};",
              "lineStart": 106,
              "lineEnd": 117
            }
          ]
        },
        {
          "additions": 36,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/state.benchmark.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/state.benchmark.ts b/apps/virtual-exchange/src/quote/state.benchmark.ts\nnew file mode 100644\nindex 000000000..075d3c5ba\n--- /dev/null\n+++ b/apps/virtual-exchange/src/quote/state.benchmark.ts\n@@ -0,0 +1,36 @@\n+import { ForkedQuoteStateComparisonTest } from './benchmark/ForkedQuoteStateComparisonTest';\n+\n+/**\n+ * 主函数 - 命令行入口点\n+ * 仅支持 --fork-compare 和 --fork-compare --quick 模式\n+ */\n+async function main() {\n+  const args = process.argv.slice(2);\n+\n+  // 检查是否使用正确的模式\n+  if (!args.includes('--fork-compare')) {\n+    console.log('使用方法:');\n+    console.log('  --fork-compare         运行完整的子进程隔离内存对比测试');\n+    console.log('  --fork-compare --quick 运行快速的子进程隔离内存对比测试');\n+    console.log('');\n+    console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n+    return;\n+  }\n+\n+  // 子进程隔离内存对比测试模式\n+  console.log('运行子进程隔离内存对比测试模式...');\n+  console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n+\n+  const forkedComparisonTest = new ForkedQuoteStateComparisonTest('Current', 'Baseline');\n+\n+  if (args.includes('--quick')) {\n+    await forkedComparisonTest.runQuickComparisonTest();\n+  } else {\n+    await forkedComparisonTest.runComparisonTestSuite();\n+  }\n+}\n+\n+// 如果直接运行此文件，则执行测试\n+if (require.main === module) {\n+  main().catch(console.error);\n+}\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "main",
              "code": "async function main() {",
              "lineStart": 7,
              "lineEnd": 7
            },
            {
              "type": "function",
              "name": "args",
              "code": "const args = process.argv.slice(2);\n\n// 检查是否使用正确的模式\nif (!args.includes('--fork-compare')) {\n  console.log('使用方法:');\n  console.log('  --fork-compare         运行完整的子进程隔离内存对比测试');\n  console.log('  --fork-compare --quick 运行快速的子进程隔离内存对比测试');\n  console.log('');\n  console.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');\n  return;\n}\n\n// 子进程隔离内存对比测试模式\nconsole.log('运行子进程隔离内存对比测试模式...');\nconsole.log('注意：每个实现都在独立的子进程中运行，确保内存测试的公平性');",
              "lineStart": 8,
              "lineEnd": 23
            },
            {
              "type": "function",
              "name": "forkedComparisonTest",
              "code": "  const forkedComparisonTest = new ForkedQuoteStateComparisonTest('Current', 'Baseline');\n\n  if (args.includes('--quick')) {\n    await forkedComparisonTest.runQuickComparisonTest();\n  } else {\n    await forkedComparisonTest.runComparisonTestSuite();\n  }\n}\n\n// 如果直接运行此文件，则执行测试\nif (require.main === module) {\n  main().catch(console.error);\n}",
              "lineStart": 24,
              "lineEnd": 37
            }
          ]
        },
        {
          "additions": 2,
          "deletions": 115,
          "path": "apps/virtual-exchange/src/quote/state.ts",
          "changeType": "modified",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/state.ts b/apps/virtual-exchange/src/quote/state.ts\nindex fdfe73151..5486b9b7b 100644\n--- a/apps/virtual-exchange/src/quote/state.ts\n+++ b/apps/virtual-exchange/src/quote/state.ts\n@@ -1,2 +1 @@\n-import { newError } from '@yuants/utils';\n-import { IQuoteKey, IQuoteUpdateAction } from './types';\n+import { implementations } from './implementations';\n@@ -4,113 +3 @@ import { IQuoteKey, IQuoteUpdateAction } from './types';\n-// TRICK: 固定字段顺序，方便计算偏移量\n-const FIELDS = ((x: { [key in IQuoteKey]: number }) => Object.keys(x).sort() as IQuoteKey[])({\n-  // TS TRICK: 强制运行时数组具有 IQuoteKey 的所有字段。不重不漏，味道真是好极了\n-  last_price: 0,\n-  ask_price: 0,\n-  ask_volume: 0,\n-  bid_volume: 0,\n-  bid_price: 0,\n-  interest_rate_short: 0,\n-  open_interest: 0,\n-  interest_rate_prev_settled_at: 0,\n-  interest_rate_next_settled_at: 0,\n-  interest_rate_long: 0,\n-});\n-\n-const FIELD_COUNT = FIELDS.length;\n-const mapFieldNameToOffset = Object.fromEntries(FIELDS.map((field, index) => [field, index * 2]));\n-\n-/**\n- * 高效的行情状态管理器\n- * 内部使用扁平化数组存储数据，避免内存碎片化和过多的 Map/对象开销\n- * 提供高效的读写接口，支持按需更新和查询\n- */\n-export const createQuoteState = () => {\n-  // 内部数据结构的设计需要考虑高效的读写性能，防止内存碎片化\n-  const data: (string | number)[] = [];\n-  const products: string[] = [];\n-  const mapProductIdToIndex = new Map<string, number>();\n-  // 0~20 (10 fields * 2 (value, updated_at))\n-  const getFieldOffset = (product_id: string, field: string): number => {\n-    let baseIndex = mapProductIdToIndex.get(product_id);\n-    if (baseIndex === undefined) {\n-      baseIndex = mapProductIdToIndex.size * FIELD_COUNT * 2;\n-      products.push(product_id);\n-      mapProductIdToIndex.set(product_id, baseIndex);\n-    }\n-    const fieldOffset = mapFieldNameToOffset[field];\n-    if (fieldOffset === undefined) throw newError('INVALID_FIELD_NAME', { field, available_fields: FIELDS });\n-    return baseIndex + fieldOffset;\n-  };\n-\n-  const getValueTuple = (product_id: string, field: IQuoteKey): [string, number] | undefined => {\n-    const offset = getFieldOffset(product_id, field);\n-    const value = data[offset] as string;\n-    if (value === undefined) return undefined;\n-    const updated_at = data[offset + 1] as number;\n-    return [value, updated_at];\n-  };\n-\n-  const setValueTuple = (product_id: string, field: IQuoteKey, value: string, updated_at: number) => {\n-    const offset = getFieldOffset(product_id, field);\n-    data[offset] = value;\n-    data[offset + 1] = updated_at;\n-  };\n-\n-  const update = (action: IQuoteUpdateAction) => {\n-    for (const product_id in action) {\n-      const fields = action[product_id];\n-      for (const field_name in fields) {\n-        const field = field_name as IQuoteKey;\n-        const [value, updated_at] = fields[field]!;\n-        const oldTuple = getValueTuple(product_id, field);\n-        if (oldTuple === undefined || updated_at >= oldTuple[1]) {\n-          setValueTuple(product_id, field, value, updated_at);\n-        }\n-      }\n-    }\n-  };\n-\n-  const dumpAsObject = (): IQuoteUpdateAction => {\n-    const result: IQuoteUpdateAction = {};\n-    for (const product_id of products) {\n-      result[product_id] = {};\n-    }\n-    for (let i = 0; i < data.length; i += 2) {\n-      const value = data[i] as string;\n-      if (value === undefined) continue;\n-      const updated_at = data[i + 1] as number;\n-\n-      const productIndex = Math.floor(i / (FIELD_COUNT * 2));\n-      const product_id = products[productIndex];\n-\n-      const fieldIndex = (i % (FIELD_COUNT * 2)) / 2;\n-      const field_name = FIELDS[fieldIndex];\n-\n-      result[product_id][field_name] = [value, updated_at];\n-    }\n-    return result;\n-  };\n-\n-  /**\n-   * 过滤状态，返回指定 product_id 列表和字段列表中，且更新时间不早于指定时间的字段数据\n-   * @param product_ids - 需要过滤的 product_id 列表\n-   * @param fields - 需要过滤的字段列表\n-   * @param updated_at - 需要过滤的更新时间阈值 (仅返回更新时间不早于该值的字段)\n-   * @returns 过滤后的数据\n-   */\n-  const filter = (product_ids: string[], fields: IQuoteKey[], updated_at: number): IQuoteUpdateAction => {\n-    const result: IQuoteUpdateAction = {};\n-    for (const product_id of product_ids) {\n-      result[product_id] = {};\n-      for (const field of fields) {\n-        const tuple = getValueTuple(product_id, field);\n-        if (tuple && tuple[1] >= updated_at) {\n-          result[product_id]![field] = tuple;\n-        }\n-      }\n-    }\n-    return result;\n-  };\n-\n-  return { update, dumpAsObject, getValueTuple, filter };\n-};\n+export const createQuoteState = implementations.current;\n",
          "codeSnippets": [
            {
              "type": "function",
              "name": "createQuoteState",
              "code": "export const createQuoteState = implementations.current;",
              "lineStart": 3,
              "lineEnd": 4
            }
          ]
        },
        {
          "additions": 6,
          "deletions": 0,
          "path": "apps/virtual-exchange/src/quote/types.ts",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/apps/virtual-exchange/src/quote/types.ts b/apps/virtual-exchange/src/quote/types.ts\nindex 664658d76..e07316e2e 100644\n--- a/apps/virtual-exchange/src/quote/types.ts\n+++ b/apps/virtual-exchange/src/quote/types.ts\n@@ -28,0 +29,6 @@ export type IQuoteUpdateAction = Record<\n+export interface IQuoteState {\n+  update: (action: IQuoteUpdateAction) => void;\n+  dumpAsObject: () => IQuoteUpdateAction;\n+  getValueTuple: (product_id: string, field: IQuoteKey) => [string, number] | undefined;\n+  filter: (product_ids: string[], fields: IQuoteKey[], updated_at: number) => IQuoteUpdateAction;\n+}\n",
          "codeSnippets": [
            {
              "type": "interface",
              "name": "IQuoteState",
              "code": "export interface IQuoteState {\n  update: (action: IQuoteUpdateAction) => void;\n  dumpAsObject: () => IQuoteUpdateAction;\n  getValueTuple: (product_id: string, field: IQuoteKey) => [string, number] | undefined;\n  filter: (product_ids: string[], fields: IQuoteKey[], updated_at: number) => IQuoteUpdateAction;\n}",
              "lineStart": 29,
              "lineEnd": 35
            }
          ]
        },
        {
          "additions": 10,
          "deletions": 0,
          "path": "common/changes/@yuants/app-virtual-exchange/2025-12-12-21-42.json",
          "changeType": "added",
          "patch": "commit 3eab2932ebf784ad6ffdeebb72791764e85d24bb\nAuthor: CZ <zheng.chen@no-trade-no.life>\nDate:   Sat Dec 13 06:41:38 2025 +0800\n\n    feat: add benchmark suite for quote state performance testing (#2314)\n    \n    - Introduced QuoteStateTestRunner for comprehensive performance testing of quote state implementations.\n    - Implemented various performance tests: initialization, update, query, filter, and dump.\n    - Created helper functions for generating test data and random product IDs.\n    - Added worker script for running tests in a child process with command-line arguments.\n    - Established two implementations (v0 and v1) for performance comparison.\n    - Updated types to include IQuoteState interface for better structure.\n    - Added a main entry point for executing benchmark tests via command line.\n\ndiff --git a/common/changes/@yuants/app-virtual-exchange/2025-12-12-21-42.json b/common/changes/@yuants/app-virtual-exchange/2025-12-12-21-42.json\nnew file mode 100644\nindex 000000000..50c5c51b2\n--- /dev/null\n+++ b/common/changes/@yuants/app-virtual-exchange/2025-12-12-21-42.json\n@@ -0,0 +1,10 @@\n+{\n+  \"changes\": [\n+    {\n+      \"packageName\": \"@yuants/app-virtual-exchange\",\n+      \"comment\": \"add benchmark\",\n+      \"type\": \"minor\"\n+    }\n+  ],\n+  \"packageName\": \"@yuants/app-virtual-exchange\"\n+}\n\\ No newline at end of file\n",
          "codeSnippets": []
        }
      ]
    }
  ],
  "analysis": {
    "domains": [
      {
        "name": "API请求优化与限速",
        "commits": [
          "8552e9d99",
          "e74337870",
          "53e361eb4",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "安全与鉴权",
        "commits": [
          "8552e9d99",
          "e74337870",
          "53e361eb4",
          "a2c68d358",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "订单与交易",
        "commits": [
          "8552e9d99",
          "e74337870",
          "53e361eb4",
          "a2c68d358",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "账户管理",
        "commits": [
          "8552e9d99",
          "e74337870",
          "53e361eb4",
          "a2c68d358",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "市场数据",
        "commits": [
          "8552e9d99",
          "e74337870",
          "53e361eb4",
          "a2c68d358",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "配置与环境",
        "commits": [
          "8552e9d99",
          "e74337870",
          "328e8765b",
          "53e361eb4",
          "037ce992a",
          "a2c68d358",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "文档",
        "commits": [
          "8552e9d99",
          "e74337870",
          "328e8765b",
          "53e361eb4",
          "037ce992a",
          "3eab2932e"
        ],
        "files": [
          "docs/reports/git-changes-2025-12-12.json",
          "docs/reports/git-changes-report-2025-12-12.md",
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts"
        ]
      },
      {
        "name": "接口重构",
        "commits": [
          "e74337870",
          "fdd39ba65",
          "3eab2932e"
        ],
        "files": [
          "apps/virtual-exchange/src/credential.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-09-42.json",
          "common/changes/@yuants/secret/2025-12-12-09-42.json",
          "libraries/secret/benchmark/index.ts",
          "libraries/secret/etc/secret.api.md",
          "libraries/secret/src/index.ts",
          "libraries/secret/src/listSecrets.ts",
          "libraries/secret/src/makeSecret.ts",
          "libraries/secret/src/readSecret.ts",
          "libraries/secret/src/setupSecretProxyService.ts"
        ]
      },
      {
        "name": "错误处理与观测",
        "commits": [
          "a2c68d358"
        ],
        "files": [
          "apps/virtual-exchange/src/credential.ts",
          "apps/virtual-exchange/src/position.ts",
          "common/changes/@yuants/app-virtual-exchange/2025-12-12-11-41.json"
        ]
      },
      {
        "name": "测试",
        "commits": [
          "3eab2932e"
        ],
        "files": [
          "apps/virtual-exchange/src/quote/QUOTE_STATE_PERFORMANCE_REPORT.md",
          "apps/virtual-exchange/src/quote/benchmark/ForkedQuoteStateComparisonTest.ts",
          "apps/virtual-exchange/src/quote/benchmark/PerformanceTester.ts",
          "apps/virtual-exchange/src/quote/benchmark/QuoteStateComparisonTest.ts",
          "apps/virtual-exchange/src/quote/benchmark/QuoteStateTestRunner.ts",
          "apps/virtual-exchange/src/quote/benchmark/index.ts",
          "apps/virtual-exchange/src/quote/benchmark/test-helpers.ts",
          "apps/virtual-exchange/src/quote/benchmark/worker.ts",
          "apps/virtual-exchange/src/quote/implementations/index.ts",
          "apps/virtual-exchange/src/quote/implementations/v0.ts"
        ]
      }
    ],
    "riskIndicators": []
  },
  "metadata": {
    "tool": "git-changes-reporter",
    "version": "3.0.0",
    "repository": "/home/runner/work/Yuan/Yuan"
  }
}