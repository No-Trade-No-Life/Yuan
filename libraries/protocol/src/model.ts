import { NativeSubject } from '@yuants/utils';
import { ValidateFunction } from 'ajv';
import { JSONSchema7 } from 'json-schema';
import { ObservableInput } from 'rxjs';
import { IService, ITerminalMessage } from './services';

/**
 * ServiceInfo
 * 服务信息
 *
 * @public
 */
export interface IServiceInfo {
  /**
   * Service ID
   *
   * Once set, it cannot be changed.
   *
   * UUID() is recommended
   *
   * for backward compatibility reason, we cannot enforce this field to be required.
   * oneday we will use this field to identify the service.
   * if not provided, we will use the `method` as the service_id.
   */
  service_id: string;
  /**
   * Service name
   * 服务的名称
   */
  method: string;
  /**
   * The message must conform to this schema for the server to process it (JSON Schema)
   * 消息符合此模式时，服务端才会处理
   */
  schema: JSONSchema7;
}

/**
 * 终端基本信息
 *
 * @public
 */
export interface ITerminalInfo {
  /**
   * Terminal ID
   * 终端 ID
   *
   * Reported by the terminal, cannot be duplicated, required to be readable, and specified or generated by the terminal.
   * 终端上报，不可重复，要求可读，终端指定或生成。
   *
   * It is recommended to specify all TERMINAL_ID through environment variables in the project. If not, it can be fallback to the generated one.
   * 工程上建议所有的 TERMINAL_ID 可以通过环境变量指定，如果没有，可以 fallback 到生成的。
   */
  terminal_id: string;

  /**
   * Terminal startup timestamp
   * 终端本次启动的时间戳
   *
   * Used to calculate uptime_in_ms = Date.now() - created_at
   * 用于计算 uptime_in_ms = Date.now() - created_at
   *
   * When empty, it is equivalent to Date.now()
   * 为空时，等同于 Date.now()
   */
  created_at?: number;

  /**
   * Terminal Information Update Timestamp
   */
  updated_at?: number;

  /**
   * Terminal service name
   * 终端服务名称
   *
   * Can be duplicated, readable by humans
   * 可重复, 人类可读
   */
  name?: string;

  /**
   * Service information provided by the terminal
   * 终端提供的服务信息
   */
  serviceInfo?: Record<string, IServiceInfo>;

  /**
   * A flag to indicate whether the terminal enables WebRTC messaging tunnel
   */
  enable_WebRTC?: boolean;

  /**
   * Status text
   * 状态文字
   *
   * Short, human-readable
   * 简短的，人类可读的
   *
   * Conventionally, it is initialized to "INIT" at startup;
   * 约定，启动时，初始化为 "INIT";
   *
   * "OK" is the normal value for everything else.
   * 约定 "OK" 为一切正常的取值，其余的都是不正常。
   *
   * @deprecated - Remove this field
   */
  status?: string;

  tags?: Record<string, string>;
}

/**
 * Service Options
 * 服务选项
 *
 * @public
 */
export interface IServiceOptions {
  /**
   * Maximum number of concurrent requests to handle
   * 处理的最大并发请求数
   *
   * by default not limited, all requests will be handled concurrently
   * 默认不限制 并发处理所有请求
   */
  concurrent?: number;
  /**
   * Maximum number of pending requests
   * 最大排队请求数
   *
   * by default not limited
   * 默认不限制
   *
   * if exceeded, the request will be rejected with 503 status code
   * 如果超出限制，请求将被拒绝，返回 503 状态码
   */
  max_pending_requests?: number;
  /**
   * Rate limit configuration
   * 速率限制配置
   *
   * by default not limited
   * 默认不限制
   *
   * if exceeded, the request will be rejected with 429 status code
   * 如果超出限制，请求将被拒绝，返回 429 状态码
   *
   * use token bucket algorithm
   * 使用令牌桶算法
   */
  rateLimitConfig?: {
    /**
     * Maximum number of requests allowed in a period
     * 在一个周期内允许的最大请求数
     */
    count: number;
    period: number;
  };
}

/**
 * @internal
 */
export type IServiceHandler<T extends string = string> = T extends keyof IService
  ? (
      msg: ITerminalMessage & Pick<IService[T], 'req'> & { method: T },
      ctx: {
        output$: NativeSubject<
          Omit<ITerminalMessage, 'method' | 'trace_id' | 'source_terminal_id' | 'target_terminal_id'> &
            Partial<Pick<IService[T], 'res' | 'frame'>>
        >;
        isAborted$: AsyncIterable<boolean>;
      },
    ) => ObservableInput<
      Omit<ITerminalMessage, 'method' | 'trace_id' | 'source_terminal_id' | 'target_terminal_id'> &
        Partial<Pick<IService[T], 'res' | 'frame'>>
    >
  : // ISSUE: Allow custom methods between terminals
    (
      msg: ITerminalMessage,
      ctx: {
        output$: NativeSubject<
          Omit<ITerminalMessage, 'method' | 'trace_id' | 'source_terminal_id' | 'target_terminal_id'>
        >;
        isAborted$: AsyncIterable<boolean>;
      },
    ) => ObservableInput<
      Omit<ITerminalMessage, 'method' | 'trace_id' | 'source_terminal_id' | 'target_terminal_id'>
    >;

/**
 * @internal
 */
export interface IServiceInfoServerSide {
  serviceInfo: IServiceInfo;
  handler: IServiceHandler;
  options: IServiceOptions;
  // cache the compiled validator
  validator: ValidateFunction;
}

/**
 * @internal
 */
export interface IServiceCandidateClientSide {
  service_id: string;
  serviceInfo: IServiceInfo;
  terminal_id: string;
  validator?: ValidateFunction;
}
