## API Report File for "@yuants/utils"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

/// <reference types="node" />

import { IRegistry } from '@yuants/prometheus';
import { Observable } from 'rxjs';
import { OperatorFunction } from 'rxjs';
import { SchedulerLike } from 'rxjs';
import { Subject } from 'rxjs';

// @public
export const batchGroupBy: <T>(keyFunc: (obj: T) => string) => (source$: Observable<T[]>) => Observable<Observable<T> & {
    key: string;
}>;

// @public
export const convertDurationToOffset: (duration: string) => number;

// @public
export const createKeyPair: () => {
    public_key: string;
    private_key: string;
};

// @public
export const decodeBase58: (data: string) => Uint8Array;

// @public
export const decodeBase64: (data: string) => Uint8Array;

// @public
export const decodeHex: (data: string) => Uint8Array;

// @public
export const decodePath: (path: string) => string[];

// @public
export const decrypt: (data: Uint8Array, base58_key: string) => Promise<Uint8Array>;

// @public
export const decryptByPrivateKey: (data: Uint8Array, privateKey: string) => Uint8Array;

// @public
export const decryptByPrivateKeyAsync: (data: Uint8Array, privateKey: string) => Promise<Uint8Array>;

// @public
export const deriveSharedKey: (publicKey: string, privateKey: string) => string;

// @public
export const encodeBase58: (data: Uint8Array) => string;

// @public
export const encodeBase64: (data: Uint8Array) => string;

// @public
export const encodeHex: (data: Uint8Array) => string;

// @public
export const encodePath: (...params: any[]) => string;

// @public
export const encrypt: (data: Uint8Array, base58_key: string) => Promise<Uint8Array>;

// @public
export const encryptByPublicKey: (data: Uint8Array, publicKey: string) => Uint8Array;

// @public
export const encryptByPublicKeyAsync: (data: Uint8Array, publicKey: string) => Promise<Uint8Array>;

// @public (undocumented)
export const errorRegistry: IRegistry;

// @public
export const escapeRegExp: (string: string) => string;

// @public
export const fnv1a64Hex: (bytes: Uint8Array) => string;

// @public
export const formatTime: (time: Date | number | string, timeZone?: string | undefined) => string;

// @public
export const fromPrivateKey: (privateKey: string) => IEd25519KeyPair;

// @public
export const fromSeed: (seed: Uint8Array) => IEd25519KeyPair;

// @public
export const generateX25519KeyPair: () => {
    public_key: string;
    private_key: string;
};

// @public
export function HmacSHA256(data: Uint8Array, key: Uint8Array): Promise<Uint8Array>;

// @public
export function HmacSHA512(data: Uint8Array, key: Uint8Array): Promise<Uint8Array>;

// @public
export interface IEd25519KeyPair {
    // (undocumented)
    private_key: string;
    // (undocumented)
    public_key: string;
}

// @public
export interface IResourcePool {
    acquire(tokens?: number, signal?: AbortSignal): Promise<void>;
    acquireSync(tokens?: number): void;
    read(): number;
    release(tokens?: number): void;
}

// @public
export interface IResourcePoolOptions {
    capacity?: number;
}

// @public
export interface ISemaphore {
    acquire(perms?: number, signal?: AbortSignal): Promise<void>;
    acquireSync(perms?: number): void;
    read(): number;
    release(perms?: number): void;
}

// @public
export interface ITokenBucket extends Disposable {
    acquire(tokens?: number, signal?: AbortSignal): Promise<void>;
    acquireSync(tokens?: number): void;
    read(): number;
}

// @public
export const listWatch: <T, K>(keyFunc: (item: T) => string, consumer: (item: T) => Observable<K>, comparator?: (a: T, b: T) => boolean) => OperatorFunction<T[], K>;

// @public
export const listWatchEvent: <T>(keyFunc?: (item: T) => string, comparator?: (a: T, b: T) => boolean) => OperatorFunction<T[], [old: T | undefined, new: T | undefined][]>;

// @public
export type NativeSubject<T> = AsyncIterable<T> & AsyncIterator<T, void, T>;

// @public
export const nativeSubjectToSubject: <T>(source: NativeSubject<T>) => Subject<T>;

// @public
export function newError(type: string, context: Record<string, any>, originalError?: unknown): Error;

// @public
export const observableToAsyncIterable: <T>(source: Observable<T>) => AsyncIterable<T>;

// @public
export const rateLimitMap: <A, B, C>(fn: (obj: A) => Observable<B>, reject: (obj: A) => Observable<C>, rateLimitConfig?: {
    count: number;
    period: number;
}, scheduler?: SchedulerLike) => (source$: Observable<A>) => Observable<B | C>;

// @public
export const resourcePool: (poolId: string, options?: IResourcePoolOptions) => IResourcePool;

// @public (undocumented)
export function roundToStep(value: number, step: number,
roundFn?: (x: number) => number): number;

// @public
export function scopeError<T>(type: string, context: Record<string, any> | (() => Record<string, any>), staff: () => T): T;

// @public
export const semaphore: (semaphoreId: string) => ISemaphore;

// @public
export function sha256(data: Uint8Array): Promise<Uint8Array>;

// @public
export function sha512(data: Uint8Array): Promise<Uint8Array>;

// @public
export const signMessage: (message: string, privateKey: string) => string;

// @public
export const signMessageByEd25519: (message: Uint8Array, privateKey: Uint8Array) => Uint8Array;

// @public
export const subjectToNativeSubject: <T>(subject$: Subject<T>) => NativeSubject<T>;

// @public
export const switchMapWithComplete: <T, U>(fn: (obj: T) => Observable<U>) => (source$: Observable<T>) => Observable<U>;

// @public
export const tokenBucket: (bucketId: string, options?: TokenBucketOptions) => ITokenBucket;

// @public
export interface TokenBucketOptions {
    capacity?: number;
    refillAmount?: number;
    refillInterval?: number;
}

// @public
export const UUID: () => string;

// @public
export const verifyMessage: (message: string, signature: string, publicKey: string) => boolean;

```
